---

title: Performing predictive modeling of virtual machine relationships
abstract: An exemplary method may include collecting performance data of present operating conditions of network components operating in an enterprise network, extracting ontological component data of the network components from the collected performance data, comparing the collected performance data with predefined service tier threshold parameters, and determining if the ontological component data represents operational relationships between the network components, and establishing direct and indirect relationships between the network components based on the determined operational relationships and establishing a business application service group based on the ontological component data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09477572&OS=09477572&RS=09477572
owner: Red Hat, Inc.
number: 09477572
owner_city: Raleigh
owner_country: US
publication_date: 20101227
---
This application relates to applications U.S. patent application Ser. No. 11 767 173 filed on Jun. 22 2007 titled Method and system for cloaked observation and remediation of software attacks now issued U.S. Pat. No. 8 191 141 U.S. patent application Ser. No. 11 867 456 filed on Oct. 4 2007 titled Method and system for collaboration involving enterprise nodes now issued U.S. Pat. No. 8 336 108 and U.S. patent application Ser. No. 12 626 872 filed on Nov. 27 2009 titled Network traffic analysis using a dynamically updating ontological network description now issued U.S. Pat. No. 8 429 748.

U.S. patent application Ser. No. 12 905 565 filed on Oct. 15 2010 titled Identification of business process application service groups now issued U.S. Pat. No. 8 825 838.

U.S. patent application Ser. No. 12 905 645 filed on Oct. 15 2010 titled System and method for migration of network entities to a cloud infrastructure. 

U.S. patent application Ser. No. 12 905 688 filed on Oct. 15 2010 titled Monitoring system performance changes based on configuration modification now issued U.S. Pat. No. 8 938 489.

U.S. patent application Ser. No. 12 905 761 filed on Oct. 15 2010 titled Indicating an impact of a change in state of a node now issued U.S. Pat. No. 8 656 009.

U.S. patent application Ser. No. 12 905 850 filed on Oct. 15 2010 titled System and method for enterprise nodes that are contained within a public cloud to communicate with private enterprise infrastructure dependencies. 

U.S. patent application Ser. No. 12 905 879 filed on Oct. 15 2010 titled System and method for determination of the root cause of an overall failure of a business application service now issued U.S. Pat. No. 8 156 378.

U.S. patent application Ser. No. 12 979 229 filed on Dec. 27 2010 titled Automatic Determination of Required Resource Allocation of Virtual Machines. 

U.S. patent application Ser. No. 12 979 237 filed on Dec. 27 2010 titled Assigning Virtual Machines To Business Application Service Groups Based On Ranking Of The Virtual Machines now issued U.S. Pat. No. 9 354 960

U.S. patent application Ser. No. 12 979 245 filed on Dec. 27 2010 titled Automatic Baselining of Business Application Service Groups Comprised of Virtual Machines. 

U.S. patent application Ser. No. 12 979 222 filed on Dec. 27 2010 titled Performing Dependency Analysis on Nodes of a Business Application Service Group. 

U.S. patent application Ser. No. 12 979 259 filed on Dec. 27 2010 titled Automatic Simulation of Virtual Machine Performance. 

The entire contents of each of the above mentioned applications are specifically incorporated herein by reference in their entireties.

Embodiments of the invention relate to performing predictive modeling in an enterprise network environment and in particular to performing predictive modeling of virtual machines based on predetermined simulation and baseline data.

Traditionally enterprises are comprised of various nodes that contribute to an overall business process. An enterprise may be thought of as a geographically dispersed network under the jurisdiction of one organization. It often includes several different types of networks and computer systems from different vendors.

These network nodes that are part of the enterprise may be comprised of both physical and virtual machines. Enterprise networks that include a plurality of virtual machines may require a physical host which is required to allocate resources among the virtual machines.

Groups of network nodes included in the enterprise may form business process application service groups BASGs . The components of these groups are comprised of virtual machines hosts storage devices and network devices. Each of these components may be dependent on one another. In an operational enterprise environment enterprise nodes change dynamically. For instance nodes are configured re configured migrated placed off line and may experience varying changes throughout the life of the node.

Enterprise network nodes naturally or by way of network design form groups of nodes that perform a business process. These groups are referred to as business process application service groups BASGs . The components of these groups are comprised of virtual machines hosts storage devices and network devices. It is the responsibility of virtual administrators to predict how the virtual machines will perform in a particular network environment. If it were possible to simulate a virtual machine s interaction with a BASG then it would also be reasonable to make predictions regarding the simulated virtual machines impact on the operating service group.

Example embodiments of the present invention may include a method of performing predictive modeling of virtual machine performance in an enterprise network. The method may include collecting performance data of present operating conditions of a plurality of network components operating in the enterprise network and storing the performance data in memory. The method may also include extracting ontological component data of the plurality of network components from the collected performance data comparing the collected performance data with predefined service tier threshold parameters determining if the ontological component data represents operational relationships between the plurality of network components and establishing direct and indirect relationships between the plurality of network components based on the determined operational relationships establishing a business application service group based on the ontological component data and storing the established business application service group in memory.

Another example embodiment of the present invention may include an apparatus to perform predictive modeling of virtual machine performance in an enterprise network. The apparatus may include a memory and a receiver to collect performance data of present operating conditions of a plurality of network components operating in the enterprise network and storing the performance data in the memory. The apparatus may also include a processor to extract ontological component data of the plurality of network components from the collected performance data compare the collected performance data with predefined service tier threshold parameters determine if the ontological component data represents operational relationships between the plurality of network components establish direct and indirect relationships between the plurality of network components based on the determined operational relationships and establish a business application service group based on the ontological component data and store the established business application service group in the memory.

It will be readily understood that the components of the present invention as generally described and illustrated in the figures herein may be arranged and designed in a wide variety of different configurations. Thus the following detailed description of the embodiments of a method apparatus and system as represented in the attached figures is not intended to limit the scope of the invention as claimed but is merely representative of selected embodiments of the invention.

The features structures or characteristics of the invention described throughout this specification may be combined in any suitable manner in one or more embodiments. For example the usage of the phrases example embodiments some embodiments or other similar language throughout this specification refers to the fact that a particular feature structure or characteristic described in connection with the embodiment may be included in at least one embodiment of the present invention. Thus appearances of the phrases example embodiments in some embodiments in other embodiments or other similar language throughout this specification do not necessarily all refer to the same group of embodiments and the described features structures or characteristics may be combined in any suitable manner in one or more embodiments.

In addition while the term message has been used in the description of embodiments of the present invention the invention may be applied to many types of network data such as packet frame datagram etc. For purposes of this invention the term message also includes packet frame datagram and any equivalents thereof. Furthermore while certain types of messages and signaling are depicted in exemplary embodiments of the invention the invention is not limited to a certain type of message and the invention is not limited to a certain type of signaling.

Specific example embodiments of the present invention will now be described with reference to the accompanying drawings. This invention may however be embodied in many different forms and should not be construed as limited to the embodiments set forth herein. Rather these embodiments are provided so that this disclosure will be thorough and complete and will fully convey the scope of the invention to those skilled in the art.

It will be understood that when an element is referred to as being connected or coupled to another element it can be directly connected or coupled to the other element or intervening elements may be present. Furthermore connected or coupled as used herein may include wirelessly connected or coupled. It will be understood that although the terms first and second are used herein to describe various elements these elements should not be limited by these terms.

According to an example embodiment elements of system may utilize the Java software platform and Enterprise Java Bean EJB architecture to provide certain functionality. These well known terms may be used in the description that follows. Other software platforms and architectures providing similar functionality may be used without departing from the scope of the present invention.

System may include an application server which interacts across a network with a number of data collection agents . Application server may be an element of an administrative console AC that also provides a suite of network management tools. A system administrator may perform network traffic analysis and or other network management tasks by accessing application server through a web browser . Application server may consist of an EJB module an ontological description creation engine and a web application . Web browser may include a rendering engine B and a knowledge browser A.

In operation data collection agent s may be deployed onto network nodes including physical and or virtual machines in an enterprise information technology IT infrastructure environment. After such deployment application server receives messages from data collection agents . These messages may include data representing for example state and relationship information about the network nodes configuration information related to the IT infrastructure performance utilization data and network communication. Thresholds are assigned to a component and or can be assigned to an entire business application service groups BASG . A host may provide CPU usage as a resource allocated to a virtual machine the CPU operational usage performance is an example metric. The virtual machine and host machine are both examples of components.

The received messages may be initially handled by EJB module . For example message driven EJB may initially inspect a received message. A received message relating to network traffic or node status may be forwarded by message driven EJB to the business logic EJB . Business logic EJB may call network traffic analysis engine for messages relating to network traffic. Alternatively infrastructure messages i.e. those messages relating to node status may be forwarded directly to the state and profiling engine .

Messages forwarded to the state and profiling engine may undergo sorting and processing. The state and profiling engine for example may identify the entities within the IT infrastructure as well as their dependency on one another based on messages received from the platform. In addition state and profiling engine may perform further processing to determine the state of one or more entities. State may be based on a threshold that has been defined for example by the system administrator. The threshold may include a metric that either exceeds or underperforms in a specific area of interest to the system administrator. An example threshold may be set for a server operating in the enterprise network that is exceeding a specified CPU utilization percentage a disk utilization percentage and or a memory utilization percentage.

A data output from state and profiling engine may be sent to ontological description creation engine . Initially the data may be handled by a resource description framework RDF application programming interface API knowledge base where the data is categorized and stored utilizing a predefined entity relationship determined by ontology web language OWL API or ontology model .

Messages handled by the network traffic analysis engine may include source to destination data qualified by a communicating application within the operating system of the originating node as well as frequency of communication information. This received data is analyzed by processing the number and type of connections to determine if an ontological communicates with relationship exists. A determination may be made by tracking the number of connections of a specific application over a period of time. The period of time may be preselected for example by the system administrator.

Data output from network traffic analysis engine may be sent to ontological description creation engine . Initially the data may be handled by the RDF API knowledge base where the data is categorized and stored utilizing a predefined entity relationship determined by OWL API ontology model . For example OWL API ontology model may define what entity classes exist their possible relationship to each other and their possible state.

The model and structure the system uses to create and update the knowledge base is contained within a web ontology language OWL file present on the application server . OWL is a family of knowledge representation languages for authoring ontologies which are a formal representation of the knowledge by a set of concepts within a domain and the relationships between those concepts. Ontologies are used to reason about the properties of that domain and may be used to describe the domain. The ontology provides the direct and indirect dependency information the SPARQL query engine requires to infer the impact a change in state will have on the rest of a service group or BASG.

In an enterprise network a business application will typically include a primary application with one or more executables that execute on one or more nodes of the network. These nodes may have direct and indirect dependencies on other nodes of the network. The business application may be described by a network ontology. When an alert state occurs for the business application the components of the business application ontology may be analyzed to determine what adjustments are required to achieve a steady state based on assigned thresholds. The root cause may be a direct or indirect root cause which may then be reported to the system administrator.

According to an example embodiment a visualization of a current network state and or communication activity may be provided to an administrator. The system administrator may be provided with a visual rendering e.g. on a computer monitor of the knowledge base. The visualization may be filtered to any selected entity of interest. For example referring again to the system administrator or other user may use a web browser to request rendering of data via web application from controllers .

Controllers may pass along any filtering information such as a specific host ID. Next business logic EJB may be called by the controllers. Business logic EJB may query RDF API knowledge base for requested data. The requested data may be returned through controllers to the web browser. The requested data may then be converted into a directed graph by a rendering engine.

Example embodiments of the present invention may provide the ability to automatically determine allocation adjustments that may be required for virtual machine performance and monitor the service tier thresholds assigned to a specified virtual machine. Thresholds are directly related to a node state . The state may be defined as an indicator to the system and the user of a business application service such as whether the business application service meets a specified or threshold requirement. The process to determine the state of an individual element may be based on a threshold that has been defined for example by the system administrator. The threshold may include a metric that either exceeds or underperforms in a specific area of interest of the system administrator. An example would be a server in a network that is exceeding a specified CPU utilization percentage.

Example embodiments of the present invention may also provide the ability to baseline business process application service groups BASGs within an operational enterprise environment. A service group may be comprised of one to many nodes operating on a network. The automatic base lining may be performed based on the ontological structure of the categorized BASGs.

Example embodiments of the present invention will provide predictive modeling such that the ontological relationships can be used to demonstrate the predicted state a BASG component member is likely to achieve with a user selectable mix of baselined BASG components. The baselined BASG components that have an ontological designation relationship of communicates with should not be separated when mixing and matching components for predictive analysis.

In order for the system to achieve an accurate prediction on the likely state that will be achieved on a baselined BASG component within an ontological structure the system should first produce historic operating data. For example the historic performance service tier threshold conditions that utilize CPU and memory metrics which have been observed by the systems agents. Embodiments of the present invention will provide a model in which the system can utilize generally available inference and probabilistic engines to predict the achieved state of baselines of the BASG components and roll up the state to achieve an overall BASG state to predict whether a BASG will succeed or fail within an operational environment.

According to one aspect of the disclosure there is provided a method for identifying a predictive model where the ontological relationships can be used to demonstrate the likely impact on a virtual machine s resulting from the predicted changes in the operational performance of peer virtual machines. The ontological structure may be comprised of a plurality of entities. In the method one or more virtual machines comprising one or more nodes may be categorized. An ontological definition of the enterprise network may then be analyzed to predict one or more structures within the enterprise network that correlate to the one or more categorized BASGs.

According to another example embodiment the system may be used to identify a BASG within an enterprise network. The system may comprise an administration console that includes a knowledge base module and an inference engine . The knowledge base module may store an ontological description of the enterprise network. The inference engine may be configured to analyze an ontological definition of the enterprise network to identify one or more structures within the enterprise network that correlate to one or more categorized BASG.

According to one example embodiment of the present invention there is provided a non transitory computer readable storage medium comprising computer executable instructions for execution by at least one processor that when executed cause the at least one processor to process an ontological definition of an enterprise network to identify one or more structures within the enterprise network that correlate to a structure of a defined BASGs. The present invention will provide predictive modeling where the ontological relationships can be used to show the predicted state a BASG component member is likely to achieve with a user selectable mix of baselined BASG components. It will be understood that baselined BASG components that have a ontological designation relationship of communicates with should not be separated when mixing and matching components for predictive analysis.

In order for the system to achieve a prediction on the likely state that will be achieved on a baselined BASG component within an ontological structure the system should first provide historic data of the performance service tier threshold conditions that have occurred specifically those that utilize CPU and memory metrics that have been observed by the systems agents.

Embodiments of the present invention will provide a model in which the system can utilize generally available inference and probabilistic engines to predict the achieved state of baselined BASG components and then roll up the determined state to an overall BASG state for the purposes of predicting whether a BASG will succeed or fail within a particular operating environment.

A file may be created and stored in memory. The file may be a resource definition framework RDF based knowledge base file included in the ontology web language OWL format. The format of the file may be constructed of triples and data values. A triple may include a particular format for example CLASS Object Property CLASS. The specific classes are referred to as individuals for instance Person Drove Car may be an example triple. Another example may be John Individual Drove Object Property Car Class . In this example Car is an example class and Drove is an object value. If for example a TRIPLE existed that included CAR Has name Ferrari Individual then the inference engine may infer that if only one car existed in the knowledge base then John Individual Drove Object property Ferrari Individual and car would be the class. This is referred to as a triple because there are 3 objects.

Data values provide information about the objects contained within the triple. The system will automatically look for other triples that contain the same objects to build an ontology for the overall knowledge base . For example after reading John Drove Car the inference engine will look for other triples that have John Drove and Car. When an analysis is required of the originating component John the system may discover that only one car component and one class and car exist.

The knowledge base file may contain a structure that includes classes object properties and data values that may be utilized for any analysis. Classes may be represented as components such as hosts virtual machines storage devices network devices users primary applications regular applications owners etc. Object properties may be thought of as verbs associated with the relationship. For example host uses storage devices and virtual machine uses network devices. Data values are the specific values associated with a class or object property and are usually associated with the state or volume of relationships. For example a virtual machine identified as w2k3004 uses 4 storage devices and may have a state of Red. In the preceding example both 4 and Red are data values.

An analysis may be performed on a single service group component and the analysis data may then be applied to a BASG baseline. For example a component Virtual Machine w2k3004 may be analyzed to convey information to the user and to the system . The inference engine may traverse the RDF frame work file and read the specific entries for a specific component that the system with read. For example for Virtual Machine w2k3004 uses storage device Gig2Network traversing this triple will result in the system being directed to read the triples for the classes that end the component triple of the originating query. If the component being analyzed is John Drove Car the inference engine will search for Car triples and analyze those triples in the same way until all avenues are exhausted. The resulting ontology is based on the results of this analysis. Further analysis can be performed on the resulting ontology by taking into account the data values in the form of a state or explicit data received from external sources that also describes the triple members as well as the individual components.

Analyzing a triple yields a relationship and following all the members of that triple as references for other triples yields an aggregated analysis. Taking into account the data values of triple members that are not related to the original analyzed triple and correlating the results based on data values provides an advanced aggregated analysis. For example an analysis that yields the result John Drove Car yields an aggregated advanced analysis John Drove Ferrari. Continuing with the same analysis another advanced aggregated analysis may yield that John Drove Ferrari Ferrari Exceeded 190 mph and that Lamborghini also Exceeded 190 mph. 

The baseline is processed for a single entity comprised of an aggregate of component nodes. For example the baseline may be performed for a BASG that includes multiple different components. A baseline may be established for a business process such as corporate E mail. The components of the BASG may include various components as included in the example baseline configuration of . Referring to baseline components may include examples such as class storage device individual storage Netapp class storage device individual storage Netapp class storage device individual storage Netapp class primary application individual e mail class primary application host individual ESX class application individual logging class primary application primary application individual e mail class application individual message tracking class primary application primary application individual E mail class application individual queuing class primary application primary application individual e mail class application individual storage driver class primary application primary application individual e mail class application individual transport components virtual machine individual SMTP server virtual machine individual SMTP message server .

As noted above the components along with their object properties and data values are used to provide a base lined state. A modification to the baseline such as accepting a greater or lesser state for an individual entity of the BASG will result in a new baseline being established for this particular BASG.

In operation the system monitors for a steady state condition of a currently operating BASG by tracking BASG service tier thresholds that have been assigned to accomplish a business process cycle completed task while operating within the thresholds identified as normal Green . When the BASG being monitored operates within normal service tier threshold parameters through three consecutive business application cycles the system will consider the operating conditions of that BASG base lined based on those currently assigned and observed service tier thresholds.

A business application process cycle may be comprised of a session that contains an initiation of network activity that is observed by the executables that are part of the primary application for the BASG. Once the communications have ceased and are verified by the user to have been completed successfully the business application process cycle is recorded in the database.

The business application process cycle is assigned as a baseline candidate for the BASG. The system creates candidates automatically by creating a record of the service tier threshold performance during a business application process cycle BAPC which may be validated by the user initially. The system will then automatically create a baseline as illustrated in . The BAPC yields the components that are involved in the communicates with object value and the indirect components that support those components. The result is an automatic base lining of service groups which form the basis for the components included in the BASG. That is the components are used to create a relative match to a user selected categorized BASG.

The process to automatically baseline a BASG is achieved by the business logic requesting the known service groups from the RDF API knowledge base . The SQARQL query engine then initiates a query to gather all the class object properties and data values from the knowledge base . The SQARQL query engine simultaneously initiates a query for performance threshold data in a database. This performance data is comprised of three separate instances of normal threshold data obtained within a business application process cycle.

The business application process cycle may be comprised of a session that contains an initiation of network activity that is observed by an agent of the executables included in the primary application for the BASG. Once the communication has ceased and is verified by the user via the web browser a message is sent through the controllers to the business logic . This business application process cycle is assigned as a baseline candidate by the resulting EJB which in turn records the established candidate into the database.

Candidates may be created automatically by the system via the SPARQL query engine initiating a query for any existing candidates upon startup of the application server such as JBOSS. The SPARQL query engine creates a Java Bean EJB which in turn sends a Java message service JMS message to the agent to observe network traffic that is initiated by an executable contained within a primary application. The agent will then observe for a successful completion of the business application cycle. The web browser then updates the user that a baseline for a given BASG exists. The BASG baseline see may then be monitored for changes by utilizing a configuration drift analysis.

A drift analysis method will now be described with reference to . Referring to a user selection of a node that has been reported to have changed state via an administrative console interface inventory view is received. Nodes that are of particular importance may include those nodes that are now indicated to be in an alert state. The web browser via the administrative console interface inventory view receives the request and processes the network ontology for a given node to determine any related enterprise entities that also include a changed state including other network nodes applications service groups etc. In one embodiment related entities that are now in an alert state are determined whether or not the indicated node is in an alert state. An RDF API knowledge base engine uses the state information for the node s network ontology to generate an impact summary view that indicates the states of the related enterprise entities. The impact summary view may then be displayed to the user through the web application interface .

One example for generating an impact summary will now be described. When an agent first begins acquiring data inventory configuration and events messages are sent from the agent to the message driven engine as illustrated in . The data is received and forwarded to an I O processor for routing to a queue of the business logic EJB . Once routed an appropriate entity java bean EJB is created in the EJB message driven engine for the agent message. Entity Java beans EJB are created for the inventory configuration and event messages separately. A notification is sent to a real time bus once the EJB message driven bean engine has created the entity bean. At the same time notification is sent to the RDF resource definition frame work API knowledge base engine and the OWL ontological web language file is updated.

The agent continues to periodically report the node inventory configuration and events in subsequent messages which create further beans at the EJB message driven engine . Entity beans are sent to a database as configuration tables via an object relational mapping ORM library such as Hibernate or Toplink. For example Hibernate provides a framework for mapping an object oriented domain model to a traditional relational database and controls object relational impedance mismatch problems by replacing direct persistence related database accesses with high level object handling functions.

The web application interface may be configured to provide an inventory view to the web browser . An example inventory view may provide a list of available nodes as well as related data for that node such as a state. The inventory view may be ranked by state so that nodes that have a high alert level are listed at the top. Selecting a node ID e.g. virtual machine WXP32 bit fse 4025 creates a summary view for that node. An example summary view is generated when the user selects a node ID by first sending the node ID in a query to the database. The query returns data relating to the node ID. The impact summary view is then generated by the web application from the returned query data.

In one example embodiment the query returns any related applications and nodes that have been placed into an alert state. For example the query may return nodes and applications having a service tier threshold change that is Red Error or an infrastructure status condition warning or a communication severed message. These state messages may be returned by the state and profiling engine . The user is able to view the impact that a changed state of a particular node has had on other nodes of the enterprise network particularly when that node enters an alert state. Using this view the user is able to determine whether the changed state is critical or not. A critical changed state will be a state where the business applications are no longer able to function adequately whereas a less critical alert state will have had minimal impact on other applications and nodes.

An example of a virtual machine summary indicates the configuration of the VM properties and relationships such as an assigned baseline cluster host and service tier. Each of the elements may be summarized by a hyperlink that when selected provides more detailed data. For example selecting a number of application hyperlinks of the configuration menu provides a table listing of all applications executed by the VM.

The impact summary for the virtual machine indicates the current CPU and memory status as well as any alert messages. In one example the CPU may be indicated to be critical at 100 usage while the memory may be indicated to be operating within normal parameters below 80 . The impact summary may also indicate any dependent nodes and any affected applications. Examples of affected applications may be listed as SQL SAP and EXCHANGE. The affected nodes may include storage and network device nodes. With configuration drift analysis of a BASG the only difference is that these items are grouped and a change to any one or more of these components will result in a configuration drift of the whole BASG.

When the RDF API knowledge base subsequently reports the existence of a new BASG the configuration will be compared to the newly assigned BASG baseline to determine whether any parameters of the configuration are outside of the allowable limits set by the baseline. Over time natural use and evolution of the network will cause changes to occur. The RDF knowledge base will continue to report the current configuration of BASG nodes by configuration messages that include the updated configuration information.

The configuration messages are received at the state and profiling engine included in a configuration bean that details the relevant data elements included within the aggregate of network nodes. For example configuration messages may include the BASG baseline which may include node ID system properties security users and groups applications and resource allocations e.g. media CPU memory and other system resources . These data elements are then compared by the state and profiling engine by comparing their current components such as classes having specific individuals and data values and the object properties with corresponding specific data values.

Virtual infrastructure messages may also be generated and communicated via the data agents and these may indicate memory CPU disk allocations by the infrastructure and infrastructure warning messages provided by the vendor management system such as a VMware ESX server. The state and profiling engine analyzes the configuration beans to determine whether there are any differences present when compared to the assigned baseline information. Configuration changes either relative to the baseline or to a previously reported configuration may cause the state and profiling engine to create a corresponding tracking entity bean that details the changes that have been made and the timing of these changes.

According to example embodiments of the present invention tracking beans may be created for every detected configuration change. In another example tracking beans may be created for configuration changes that violate previously defined allowable baseline drifts. In a further alternative a combination of these methods and operations may be utilized to permit tracking beans to be created for drifts in some parameters yet selectively created for drifts in other parameters.

In general configuration drifts may be present in the operating conditions of the BASG s which would cause tracking beans to be created each time the RDF API knowledge base reports the node configuration. To avoid unnecessary and persistent configuration drift alerts from being generated comparisons may be made between a configuration report from the agent and earlier generated tracking beans for that node so that tracking beans are created only for new configuration drifts.

The following terminology is used only to distinguish one element from another element. Thus for example a first user terminal could be termed a second user terminal and similarly a second user terminal may be termed a first user terminal without departing from the teachings of the present invention. As used herein the term and or includes any and all combinations of one or more of the associated listed items. The symbol is also used as a shorthand notation for and or .

Networks including computer entities physical and or virtual machines operating on network nodes etc. may be advantageously described via an ontology that describes the operational usage and current state of the entities rather than being based on a fixed IT infrastructure architecture. The ontological description may be automatically and dynamically updated based on data acquired from data collection agents deployed to the nodes of the network. The data collection agents observe communicative relationships based on connections between nodes in operational use while annotating a class state. Using the ontological description a network analyst or system operator may be provided with an improved ability to analyze network traffic.

Data relating to actual connections may be acquired automatically in near real time. For example an actual connection may be monitored in an interrupt driven way while collecting information regarding an application that made the connection. Moreover a volume for the connections may be derived. A software based data collection agent may be received by a computing device at a node within a communications network. The agent may be distributed to one or more nodes from a central node via the network. Once the software based data collection agent is received it may be inserted in an operating system of the receiving node. Advantageously the agent may be inserted in the kernel of the operating system or in a user space i.e. an area in virtual memory of a computer that contains user applications that execute at the application layer . The installation may be performed such that it is transparent or undetectable by a user of the node. The installed data collection agent may monitor data packet traffic between an adaptive driver layer and a protocol layer and report results of the monitoring to the central node.

In one example the data collection agent may have an interface to an operating system s network stack and may periodically determine what applications are using the network stack. As a result the data collection agent may track information regarding a network connection the connection duration and any applications and systems involved in the connection. The data collection agent may normalize the foregoing information and report it to an administration console so that different operating systems may be correlated by the administration console.

As a further example the data collection agent may include a network filter inserted into the network stack to determine exactly when a connection is made between entities. The filter component of the data collection agent may be inserted at one or more layers of the OSI model. For example a data collection agent may have a filter interface at the transport layer and or a filter interface at the network layer. The data collection agent may track information regarding a network connection the connection duration and any applications and systems involved in the connection. Moreover the data collection agent may normalize the foregoing information and report it to the administration console so that different operating systems may be correlated by the administration console.

As yet a further example the data collection agent described in the preceding paragraph may also include a packet filter inserted into the network stack to track connection data. For example a data collection agent may have a filter interface at the data link layer. Then the data collection agent may correlate and normalize if required data from the network filter and the packet filter to track information regarding the network connection the connection duration any applications and systems involved in the connection connection status and connection resource usage information. Moreover the data collection agent may normalize the foregoing information and report it to the administration console so that different operating systems may be correlated by the administration console.

Referring again to an illustrative system for deploying data collection agents onto network nodes monitoring network connections instantiated at each network node acquiring resulting data automatically creating an ontological description of the network from the acquired data and dynamically updating the ontological description will be described. The system may further be used for monitoring configuration drifts within an enterprise network as will be described in more detail below.

In another example embodiment elements of system utilize the Java software platform and Enterprise Java Bean EJB architecture to provide certain functionality and these well known terms may be used in the description that follows.

According to example embodiments of the present invention the process to automatically determine a performance allocation may begin by monitoring those virtual machines that have sustained a service tier threshold in either a critical low and or a critical high level for more than 24 hours. Such an observation may be observed by the virtual machine agent. The SQARQL query engine simultaneously initiates a query for current performance threshold data stored in a database.

The components states may be determined because they have thresholds that are achieved overachieved or underachieved. Nodes executables and the business application service groups BASGs may also incorporate status and alerts from infrastructure providers. The Executables may have a state that relates to the communicates with relationship. For example if an executable such as sqlservr.exe no longer communicates with node X it may be designated critical high and indicated on a user interface as red or as a warning. This example may be true of a node that represents a communicates with relationship as well as a primary application represented as a node.

The state and profiling engine may set the state of the business application service group BASG using the agent data and system information. When any component of the BASG has achieved a High Warning state the user may view the component as red indicating a high warning as well as the BASG as in red on a graphical user interface.

The process to determine the state of an individual element may be based on a threshold that has been defined for example by the system administrator. The threshold may include a metric that either exceeds or underperforms in a specific area of interest to the system administrator. An example would be where a server in a network is exceeding a specified CPU utilization percentage.

Example embodiments of the present invention may automatically determine the optimum pairing of virtual machines in a business process application service group BASG to maximize performance as measured by a service tier threshold system. Example may include automatically analyzing the baseline of direct and indirect connections based on network interactivity of the applications that are utilized to perform a process.

A BASG is comprised of one to many nodes operating on the enterprise network. The basis for an automatic base lining procedure may be in the ontological structure of the categorized BASG. The resulting data file may contain a structure that includes classes object properties and data values. The system creates a profile type for each selected BASG host storage device and other network dependent components elements. This profile may include specific attributes that are used to pair virtual machines with BASGs that allow the virtual machine to execute optimally.

Example operations may provide identifying specific virtual machines to pair with a specific business BASG. One or more virtual machines may be paired with one or more BASGs. The system may determine which BASGs are best suited for a pairing based on parameters that include high availability high capacity high speed moderate capacity moderate speed moderate availability low capacity low speed and low availability. These are considered by the system to be the BASG types. The virtual machines that require these attributes are then paired to these BASGS.

Initially the system may analyze each of the BASGs performance data to determine if any of the BASGs would benefit from a newly added virtual machine pairing. This analysis may be performed by processing the aggregate service tier thresholds of the host member s of the BASG. For example by processing the state information of both the storage and network BASG dependencies the need for additional virtual machines may be apparent. The storage and network state information may be factored with the host performance threshold data and state information to determine a profile of the BASG The BASG profile may include categories such as categories which may include but are not limited to high availability high capacity high speed moderate capacity moderate speed moderate availability low capacity low speed and low availability.

The system may analyze the virtual machines to determine the optimal combination of host applications storage required and network performance by analyzing the service tier threshold performance data acquired. Each virtual machine is assigned a profile requirement such as high availability high capacity high speed moderate capacity moderate speed moderate availability low capacity low speed and low availability. The system then pairs the virtual machine with at least one host network and storage group that has availability and may be assigned to a BASG. Or alternatively the BASG can produce availability by migrating one or more less optimally paired virtual machine elsewhere.

The system may also provide a work order that can be processed by an orchestration system or individual who is responsible for executing the changes. The system routinely as defined through the user interface monitors the networking environment to maintain optimum virtual machine pairings with host storage and speed groups that include one or more BASGs.

In a physical capacity summary is also provided for easy summarization of the total CPU capacity memory capacity and disk capacity. This baseline summary provides a system administrator with a snapshot of operating conditions of the BASGs virtual machines and overall available resources. This provides the system administrator with the information necessary to determine if the BASGs virtual machines and available resources are being utilized efficiently throughout the network.

Resource icon is the physical host hardware for the virtual machine along with other virtual machines and is referred to as the hypervisor. Resource icon is the network for virtual machine . It is the same as a logical network in the Enterprise and is associated with a device at the virtual infrastructure management level i.e. ESX Server which is a name for the network as it is known to the enterprise for our purposes.

Resource icon is a datastore for virtual machine . It represents a physical allocation of disk storage and is associated with a hard disk storage device at the virtual infrastructure management level. Resource icon is the User assigned to both virtual machines and . It has been defined and assigned by this virtualization management software. Resource icon is the host for virtual machine . The host is a physical host hardware that the virtual machine is running on along with other virtual machines and may be referred to as the hypervisor. Resource icon is the primary application that is being executed on the virtual machine . Lastly is the datastore for the virtual machine . These resource icons may be dragged and dropped to reassign resources to the virtual machines and in turn modify the allocations of the BASGS.

According to example embodiments of the present invention the system will automatically determine the optimum pairing of virtual machines with BASGs to maximize performance as measured by a service tier threshold monitoring system. In operation upon initiation by the user through the web browser interface the application server may receive a message to survey the virtual machines for their respective CPU and memory usage over the past 30 days. The survey may be performed by the web application server sending a request to the state and profiling engine to compile the usage data from the database.

The state and profiling engine may transmit a JMS message to the business logic that compiles the database query. The business logic generates an EJB based query that includes a request for CPU and memory usage data for the last 30 days. A ranking may be performed by the SPARQL query engine . An example of the data returned by the database is described with reference to . This data is used to rank the virtual machines. The ranking is averaged over the range of virtual machines returned. The ranked virtual machines are then assigned a profile by the state and profiling engine . The profiles may include high availability high capacity high speed moderate capacity moderate speed moderate availability low capacity low speed and low availability.

The breakpoints for the profiles may match the predefined service tier thresholds assigned by the system. Once all of the virtual machines have been assigned a profile based on their usage the state and profiling engine sends this list via a profile EJB to the RDF API knowledge base . Once completed the system initiates the process to compile a candidate list of BASG dependencies. The virtual machines that reside in the described ontological structures are not considered for the candidate process. The BASG candidate process is initiated by the state and profiling engine .

The state and profiling engine sends a JMS request message to the business logic to compile a list of candidate hosts networks and storage groups that are configured within the BASGs. The request is included within a profile EJB. This results in a database query for usage data for the last 30 days from the database. The business logic sends a request to the RDF API knowledge base for state data for host network and storage roll up data based on 24 hour roll ups for the last 30 days.

The state data may contain warning or errors that resulted in a red state for the given nodes. The usage and state information are sent back to the state and profiling engine where they are used to rank and profile the BASGs. The ranked BASGs are then assigned a profile by the state and profiling engine. The BASG profiles may include high availability high capacity high speed moderate capacity moderate speed moderate availability low capacity low speed and low availability. The breakpoints for the profiles may match the service tier thresholds previously assigned by the system.

The state information for each BASG may be used to assign a profile by automatically assigning a low profile to any BASG that is experiencing a warning or error red indication . The error may be based on a 20 margin of exceeding the predefined resource threshold and may be based on a 24 hour data roll up for a 30 day period. No virtual machines are used to rank a BASG. The virtual machine itself is ranked in the virtual machine profile process mentioned above. Once all BASGs have been profiled the state and profiling engine may use a standard matching algorithm to pair the virtual machines with BASGs. The state and profiling engine generates a report that details the recommended change in virtual machine assignment to BASGs. This list may be formatted in XML to be utilized by an orchestration system to complete the changes or to be read by a user for manual adjustments to assignments.

The states of the individual business application service components may be aggregated to calculate an overall state for the BASG. Any support nodes within the BASG ontology that have achieved a high warning may be labeled under the BASG as having a high warning. The ontology begins as a file and then it is migrated to memory. If any one node with a communicates with relationship achieves a high warning status it may be identified as having a high warning for its associated BASG. High errors may be identified in a similar manner. For example in order for a node to achieve these states the states should have been observed and processed by the state and profiling engine three times within one hour or within a similar time frame. As a result spurious errors and random faults will not lead to warnings being generated for the overall business application process.

One example method for processing state information of elements of a business process ontology and more specifically for a BASG that is in an error state will now be described with reference to . The method of may be performed by processing logic that may comprise hardware e.g. circuitry dedicated logic programmable logic microcode etc. software such as instructions run on a processing device firmware or a combination thereof. In one embodiment the method is performed by a server e.g. application server of .

At operation a query is sent to the RDF knowledge base that identifies the BASG that is currently in an error state. The RDF knowledge base returns the list of components of the BASG e.g. hardware nodes virtual nodes executables processes primary applications etc and their state.

It should be noted that the primary application of the BASG is considered by the RDF knowledge base to be a node. Any of these components of the BASG may have independent thresholds assigned by the system administrator. Examples of components may include virtual machines host machines storage devices network devices. Examples of resources that are allocated may include memory CPU storage disk space network adapters. Examples of metrics may include a CPU utilization of 1024 Ghz a memory utilization of 8 gigabytes a network adapter operating at 100 Mbps etc.

At operation a filter is applied to determine those components that may have contributed to the high warning threshold that was exceeded and which triggered an alarm. In one example embodiment the filter omits any individual component that has not exceeded a high warning threshold individually from the process. This may reduce the chances of false alarms occurring due to random instances of a predefined threshold being exceeded.

At operation the process continues by inspecting each of the filtered components to determine a root cause. The inspection process looks up performance data previously reported by the agents deployed to the nodes. The inspection process may yield all of the component s relevant data for determining a root cause. In one example the data used for this determination is service tier data such as CPU memory disk and network operation threshold roll up data last 30 days though other relevant data may also be used.

The root cause process may also use virtualization infrastructure alarms and network status updates. These are available to the system for host virtual machines disks and network devices and may be sent in messages from a proxy agent. The proxy agent may contain an instruction for translating virtual infrastructure messages to a format that the state and profile engine can process. If for example the proxy agent receives a message from the virtual infrastructure stating a disk has achieved full capacity and has an error level of 3 the proxy agent will modify the received message with a translation on the level of 3 to High Error . This is then sent to the message driven bean factory where an EJB is created with the contents received from the proxy agent. The business logic then routes the new state EJB to the state and profiling engine . This data is provided to the user as support evidence for the root cause conclusion.

The SPARQL Engine determines the state of the primary applications and the contributing executables that make up the primary application by requesting the ontology for the business application service. The ontology is analyzed for breaks in communication with nodes as described in the Applicant s co pending applications referenced above.

The SPARQL query engine will send a request to the agent to send back the performance statistics of the executables that make up the primary application of the business application service. This will provide the user with the real time performance statistics of the executables to provide support for a conclusion that a root cause of failure is due to the failure of the primary application support nodes at operation . The result of conclusion may automatically trigger a recommendation to perform an increase and or decrease in the present resource allocation of resources provided by a virtual machine s at operation . For example CPU resources and disk space may be reallocated from among the network resources by the system administrator as a result or receiving the recommendation. Or alternatively certain reallocation measures may be performed automatically.

System may comprise an application server which interacts across a network with a number of data collection agents deployed in various nodes of the network. Advantageously application server may be an element of an administrative console AC that also provides a suite of network management tools. A system administrator may perform network traffic analysis and or other network management tasks by accessing application server by way of web browser . Application server may comprise an EJB module an ontological description creation engine and a web application .

Data collection agents as described hereinabove may be deployed onto network nodes including physical and or virtual machines in an enterprise IT infrastructure environment. After such deployment application server receives messages from data collection agents . These messages may include data representing for example state and relationship information about the network nodes configuration information related to the IT infrastructure performance utilization data and network communication.

The received messages may be initially handled by EJB module . For example message driven EJB module may initially inspect a received message. A received message relating to network traffic or node status may be forwarded by message driven EJB to the business logic EJB . Business logic EJB may call network traffic analysis engine for messages relating to network traffic. Alternatively infrastructure messages i.e. those relating to node status may be forwarded directly to the state and profiling engine .

Messages forwarded to the state and profiling engine may there undergo sorting and processing. The state and profiling engine for example may identify the entities within the IT infrastructure as well as their dependency on one another based on messages received from the platform. In addition state and profiling engine may perform further processing to determine the state of one or more entities. The states may be based on a threshold that has been defined for example by the system administrator. The threshold may be based on a metric that either exceeds or underperforms in a specific area of interest to the system administrator. An example would be a server operating in a network that is exceeding a specified CPU utilization percentage. The threshold may be set to 80 CPU utilization and if the server is operating at 81 the threshold is being exceeded.

Example embodiments for determining a required resource allocation of a virtual machine based on thresholds are discussed below. The web application server business logic creates a message request to provide the necessary changes in virtual machine performance allocation variables to create a condition of no critical low and or no critical high conditions for the next 24 hours. If the recommended change is not successful the cycle repeats by incrementing the 24 hour period with no critical low and or no critical high warning by the service tier threshold system. Another 24 hour monitoring period may then begin.

A recommendation of a change in a variable by a factor of 10 increase or reduction may be a general modification used to satisfy a threshold condition that has been exceeded underperformed. The 10 factor modification may be used until the virtual machine exceeds a performance request which results in the web browser initiating a message to the web application and controllers of the virtual machine. This modification in turn creates a message driven entity bean that contains the request which is transferred to a rules engine. The rules engine sends a request to gather a historical period of information to the web browser . Such historical information may be for a period of 1 to 90 days. The rules engine not shown may be part of creation engine and or EJBs .

The rules engine message is sent to a database not shown to gather the data tables requested. The database sends the data back to the rules engine. The rules engine factors the data resulting in a recommendation to increase or decrease the allocation for each of the performance threshold criteria which may include for example CPU utilization memory utilization data storage utilization and network resource utilization.

The resource modification recommendation is created by the rules engine . The creation engine may also be referred to as the rules engine. The rules engine may perform averaging the actual threshold observed by the service tier threshold integer 0 100 scale . The average is only taken from metrics observed while the virtual machine is observed in its normal operating range. If no normal range is observed than the rules engine will increment the recommended change by increasing or decreasing the allocated resource s by 20 until a normal range is observed over a period of 24 hours. According to one example the recommended increase or decrease is only 10 for a period following 24 hours if the data gathered does contain normal range input data.

A proxy agent not shown may be part of the local agent that 500 that is used to collect data. In operation the proxy agent collects data from the virtual infrastructure management provider. The user will utilize the default thresholds or adjust them as deemed necessary. Thresholds are used by the state and profile engine for tracking the state of the nodes that make up the components for a business application process. The inventory in the database may be updated by the proxy agent with a list of virtual machines storage hosts and network devices.

The agent may be deployed via the physical hosts connected directly to the virtual machine s O S. The state and profile engine assigns the state of the various network components and receives additional input from the proxy agent to factor into the state e.g. alarms network and communicates with relationship status and updates the RDF knowledge base ontologies to reflect the assignments. The agent tracks executable applications to see what other nodes are communicating with the virtual machines VMs in the enterprise.

The traffic analysis engine determines which executable applications and services are communicating with other nodes that constitute a communicates with relationship. A determination may be made as to whether any pairs of nodes have a communicates with relationship. Upon the assignment of a communicates with relationship to the ontology of a node and its direct and indirect relationships the state and profiling engine assigns the group of nodes as a service group. 

The RDF knowledge base contains an ontology for each individual node. The model and structure the system uses to create and update the knowledge base is contained within the ontology web language OWL file present on the application server . The state and profiling engine tracks the state continually of the components and receives additional input from the proxy agent to factor into the state e.g. alarms network and Communication with relationship status .

The user may identify a service group of network nodes as a business application service group BASG by selecting a name for the group of nodes and the executables that are the basis for the communicates with relationship. The user may also add nodes that the system did not auto detect as a component of the service group. Those added nodes will be recorded and stored in the ontology model .

A determination may then be made as to whether the user has assigned additional nodes and or names to the service group. The ontology itself provides the direct and indirect dependency information of the nodes that the SPARQL query engine requires to infer the impact a change in state will have on the rest of the service group. For instance if a storage device s component state is changed to RED because it is almost full e.g. only two gigabytes left of a 1500 gigabyte memory then this may cause the physical host to start the paging memory which will effect the performance of any and all virtual machines running on that physical host.

The SPARQL query engine parses the service group ontology for the components that have a communicates with relationship which forms the basis for a primary application. The state and profiling engine tracks the state of the BASG by requesting the current state from the RDF knowledge base and updating the ontology when any new messages are received from the business logic EJB factory . A new message can be created by an agent or the virtual infrastructure provider management system. The new message will include items such as new hosts virtual machines network devices storage devices as well as statuses for these items. The inference engine adds these items into the RDF API knowledge base while it is in memory. If any of these items exist as components then the new data is added modified in the ontology stored in memory.

The ontology itself provides the direct and indirect dependency information the SPARQL query engine requires to infer the impact a change in state will have on the rest of the BASG. SPARQL query engine parses the BASG ontology for the components that have a communicates with relationship which forms the basis for a primary application.

For example SPARQL query engine provides a list of candidate BASG members for base lining and adjusting that may be needed to achieve normal acceptable performance levels. By parsing the BASG ontology for primary applications that have communicates with relationships with virtual machines that have operated in a normal level of threshold for 3 consecutive business cycles may yield a list of qualifying components. SPARQL query engine may parse the BASG ontology to determine the components that have a communicates with relationship. Such components may be used to form the basis for a primary application. SPARQL query engine may generate a list of virtual machine BASG members pairing recommendation.

Web application server may receive the message to survey the virtual machines for their CPU and or memory usage over the past 30 days. Web application server may send a request to the state and profiling engine to compile the usage data from the database. The state and profiling engine sends a message to the business Logic that compiles the Database Query. The business logic generates an EJB based query that includes a request for CPU and memory usage data for the last 30 days.

According to example embodiments of the present invention the SPARQL query engine may parse the service group ontology data to determine the components that have a communicates with relationship. This relationship information may be used to form the basis for a primary application. The user may communicate via a web interface of the web application and assign a name to the service group.

The state and profiling engine tracks the state of the BASG as an aggregate of each of the components of the BASG by requesting the current state from the RDF API knowledge base and updating the ontology information when any new messages are received from the business logic of the EJBs . SPARQL query engine provides a list of BASGs that may be used for base lining and for making any adjustments to achieve normal acceptable performance levels. Parsing the BASG ontologies for primary applications that have communicates with relationships with virtual machines that have operated in a normal threshold level for three consecutive business cycles may yield a list of primary applications that have associated triples with data values associated with those triple members.

The business logic may perform requesting the service groups from the RDF API knowledge base . The SPARQL query engine then initiates a query to gather all the class object properties and data values from the API knowledge base . The SQARQL query engine may simultaneously initiate a query for performance threshold data from a remote database not shown . The performance threshold data may include three separate instances of normal threshold data within a business application process cycle BAPC . The BAPC may include a session that provokes network activity that is observed by the agent of the corresponding executable of the primary application for the BASG.

Once the communication has ceased and is verified by the user via the web browser a message may be sent through the controllers to the business logic . The BAPC may be assigned as a baseline candidate by the resulting EJB which in turn records the candidate into a database. Candidates are then created automatically by the system via the SPARQL query engine which performs initiating a query for any existing candidates. The query may be performed upon startup of the application server . The SPARQL query engine creates an EJB which in turn sends a Java message service JMS message to the agent to observe network traffic that is created by an executable contained within a primary application. This results in a base lined BASG that can be monitored for changes just as a single entity may be monitored within the configuration drift system.

The BASG baseline may be monitored for changes by utilizing a configuration drift analysis by the state and profiling engine. SPARQL query engine may provide a list of identified BASG baselines. These baselines may then be inserted into the state and profiling engine for a configuration drift analysis. Drifting may include any changes that have occurred from a previous BASG configuration. For example a component class an object value verb or a data value such as the state of any of the assets of a BASG each represent examples of potential changes that may occur.

After a drift analysis is performed the SPARQL query engine provides the business logic of the EJB with a message detailing a list of BASGs and updates the user by providing the information via the web browser . The user selects one or more of the baselines of the BASGs. The baseline may be selected for use by a future simulation engine and or for use by a future prediction engine.

The user may interface with the web browser to request to select a BASG from the knowledge browser A. A message may be sent to the controller Viper within the web application to gather the specific ontological components of the BASG selected. The web application controller sends a message to the ontology Viper business logic requesting a baseline for the BASG contained in the RDF API knowledge base . A baseline is provided to the ontology Viper business logic which sends the ontology to the rules engine which generates an EJB containing the list of components to be monitored by the inference engine . The inference engine analyzes the ontology by iterating through the ontology XML EJB message which comprises a baseline score that is generated by the BASG baseline process.

The state and profiling engine tracks the state of the BASG as an aggregate of each of the components of the BASG by requesting the current state from the RDF API knowledge base and updating the ontology information when any new messages are received from the business logic of the EJBs . SPARQL query engine provides a list of BASGs that may be used for base lining and for making any adjustments to achieve normal acceptable performance levels. Parsing the BASG ontologies for primary applications that have Communicates with relationships with virtual machines that have operated in a normal threshold level for three consecutive business cycles may yield those virtual machines and or states that have remained in a green state.

The business logic may perform requesting the service groups from the RDF API knowledge base . The SQARQL query engine then initiates a query to gather all the class object properties and data values from the API knowledge base . The SQARQL query engine may simultaneously initiate a query for performance threshold data from a remote database not shown . The performance threshold data may include three separate instances of normal threshold data within a business application process cycle BAPC . The BAPC may include a session that provokes network activity that is observed by the agent of the corresponding executable of the primary application for the BASG.

Once the communication has ceased and is verified by the user via the web browser a message may be sent through the controllers to the business logic . The BAPC may be assigned as a baseline candidate by the resulting EJB which in turn records the candidate into a database. Candidates are then created automatically by the system via the SPARQL query engine which performs initiating a query for any existing candidates. The query may be performed upon startup of the application server . The SPARQL query engine creates an EJB which in turn sends a Java message service JMS message to the agent to observe network traffic that is created by an executable contained within a primary application. This results in a base lined BASG that can be monitored for changes just as a single entity may be monitored within the configuration drift system.

The BASG baseline may be monitored for changes by utilizing a configuration drift analysis by the state and profiling engine. SPARQL query engine may provide a list of identified BASG baselines. These baselines may then be inserted into the state and profiling engine for a configuration drift analysis. Drifting may include any changes that have occurred from a previous BASG configuration. For example a component class an object value verb or a data value such as the state of any of the assets of a BASG each represent examples of potential changes that may occur.

After a drift analysis is performed the SPARQL query engine provides the business logic of the EJB with a message detailing a list of BASGs and updates the user by providing the information via the web browser . The user selects one or more of the baselines of the BASGs. The baseline may be selected for use by a future simulation engine and or for use by a future prediction engine.

The service tier threshold performance values that are recorded for CPU memory storage and network may be produced for the historical data. These values are recorded for each dependent node that is applicable. The SPARQL query engine reports the direct or indirect dependency node s current state as derived from the historical data last 24 hour data collection roll up with what impact it is likely to have to the BASG s process.

The message also contains the classes object properties and data values for the BASG process baseline. The SPARQL query engine uses the score to compare with the ontology components that were sent with the message. The inference engine is used to accomplish a predictive analysis of the BASG dependencies. The inference engine is instantiated to accomplish a predictive analysis of the BASG dependencies. The inference engine performs the predictive analysis to examine the triples to determine if an inference can be made. Determined states are migrated into the RDF API knowledge base by the state and profiling engine . State Service tier metrics are converted to state color names by the state and profiling engine .

States are migrated into the RDF API knowledge base by the state and profiling engine . Triples are created for each member of the BASG for example ESX has state RED. The structure of this triple may be represented as CLASS Object Property Class or in this example specifically HOST HAS STATE STATE NAME. These state triples are analyzed by the predictive engine which may be incorporated into the inference engine by utilizing a generally available probabilistic logic network.

A probabilistic logic network PLN is a novel conceptual mathematical and computational approach to uncertain inference. In order to carry out effective reasoning in real world circumstances artificial intelligence software should robustly handle uncertainty. The PLN is able to encompass within uncertain logic such ideas as induction abduction analogy fuzziness and speculation and reasoning about time and causality. By utilizing a PLN model the predictive engine can reason the STATE of a BASG without other variables being introduced.

The predictive engine assigns TruthValues to ranges of observed performance of ontological components when combined with other components that form a BASG. These TruthValues are the observed ranges that translate to a StateName. For example a TruthValue for HOST ESX is 98.6 for CPU. CPU TruthValue 98.6. The value was inferred from historic data and likely data results that have not been realized. The PLN utilizes these TruthValues to return a new TruthValue. Each TruthValue contains a rule. The predictive engine contains TruthValue rules for BASG components such as CPU and memory as well as for other BASG components. It also contains rules for triple based object properties the predicate such as has primarly application has host uses network uses storage etc. TruthValue rules that are utilized may include a lookup rule deduction rule and generic link2link rules.

The rules provide the probabilistic logic network PLN a basis for traversing a forward chain. In general forward chaining is a popular method of reasoning when using inference rules i.e. artificial intelligence . Forward chaining is a popular implementation strategy for expert systems business and production rule systems. The opposite of forward chaining is backward chaining.

Forward chaining begins with the available data and uses inference rules to extract more data for example from an end user until a predefined goal is reached. The inference engine may use forward chaining searches of established inference rules until it finds a rule where the antecedent if clause is known to be true. When found it can conclude or infer the consequent then clause resulting from what is true. This results in the addition of new information to its already existing data. The inference engine will iterate through this process until a predetermined goal is reached. For example suppose that the goal is to conclude the color of a pet named Fritz given that he croaks and eats flies and that the rule base contains the following four rules 1. If X croaks and eats flies Then X is a frog 2. If X chirps and sings Then X is a canary 3. If X is a frog Then X is green and If X is a canary Then X is yellow then the result will be that he is a frog.

According to another example each PLN rule can provide templates for the fundamental data units atoms it requires as input. In each inference operation the forward chainer operation selects a rule and then looks up a sequence of atoms that match the input templates. Using a deduction rule solving the classic Mortal Socrates problem the deduction rule requires two atoms in the form Inheritance A B and Inheritance B C which may be interpreted as A is a B and B is a C. It then produces Inheritance A C For the first argument the forward chainer looks up any Atom that matches Inheritance A B that is any Inheritance link stored in the system. Assuming it finds Socrates is a man Inheritance Socrates man it may deduce A Socrates and B man. So to find the second argument it looks for Inheritance man C i.e. man men is are . Suppose it finds Men are mortal Inheritance man mortal then it provides these two premises into the DeductionRule which produces Inheritance Socrates mortal . Since this is an example of forward chaining other possibilities may have been discovered. For example the second argument Men tend to be bald then it would have produced Socrates is likely bald. 

These example rules are utilized by the PLN reasoner. The TruthValues with the assigned rules return a new TruthValue. The PLN inference engine utilizes a BITNodeRoot and PLN forward chainer to accomplish the inferencing.

By utilizing these rules the prediction engine employs a PLN based inference engine that returns the predicted state that the components will achieve if no changes are made. The web browser rendering engine B updates the ontology workspace with the predicted state of each BASG member component as well as the overall BASG state. The web browser rendering engine B updates the ontology workspace with the predicted state of each BASG member component as well as the overall BASG State.

According to an example method of operation of the system a prediction may be performed by performing various example operations. In one example data is collected by the agents . Data from the agents is transformed into ontological components. The components performance is observed by the agents and processed against service tier parameters to determine a state. Ontological component s network communication is observed to determine if a operational relationship exists. For ontological component s that are determined to have an operational relationship the ontological dependencies direct and indirect relationships are observed and transformed into a service group.

Once a service group s primary application has been identified it is labeled and identified by the system as a BASG. The BASG s are baselined in order to provide the system with a model for further analysis. Baselined BASG s are analyzed to determine their dependencies. For example historic CPU and memory usage data values are recorded in memory for baselined BASG component members. Query engine may process a baselined BASG to determine historic state data which may be stored in a database.

The inference engine is employed to provide inferences on which BASG members will most likely achieve a state change. A generally available inference probabilistic logic network reasoning engine is employed to determine the state that a particular BASG will achieve if no other variables are introduced. A generally available inference probabilistic logic network reasoning engine is employed to determine the state a BASG will achieve if no other variables are introduced. A generally available inference probabilistic logic network reasoning engine may be used to determine the state a BASG will achieve if no other variables are introduced. TruthValues and rules are assigned to the baselined BASG components within that ontology model.

The PLN predictive engine may return state value derived from the returned TruthValue. The operator may change any component from a baselined BASG and apply a new prediction as long as communicates with pairs are inserted together and not separated. The web browser rendering engine B updates the ontology workspace with the predicted state of each BASG member component as well as the overall BASG state.

According to one example when a node is dragged and dropped into the BASG in the workspace GUI see the BASG nodes will display a predicted state which displays nodes and any changes that have occurred or will likely occur. The predicted state may expressed as a percentage service tier threshold state description and may also have a corresponding color representation. For example a VM with a high capacity requirement is dropped into a low capacity profiled BASG. The system will display a now RED VM with a storage service tier threshold state description of 90 100 threshold for CPU 90 100 memory both of which are deemed Critical High. 

The system determines these alarming states and allows the user to provide feedback as to what the system should consider a good poor or normal condition through the service tier threshold settings. The system determines the actually operating conditions and records them over time and applies inference and reason to determine what will happen if a node was selected and dropped into a new environment based on what past operating conditions and observations. By using the default settings on the service tier thresholds the user can simulate the conditions of a change without having to actually modify any of the currents operating conditions.

Referring to state prediction results as illustrated in the drag and drop portion of may be illustrated in . The state prediction results illustrate that the simulation pair caused high error prediction results for the host state and the datastore as indicated in state prediction results .

In an embodiment of the invention the process to provide a method to determine the predictive state of a BASG. The process begins with the database returning the historical data associated with any direct or indirect dependency component that is determined to be a delta from the baseline score. This historical data is requested to provide an impact of the change. The historical data is comprised of last 30 days and may be based on service tier threshold performance values that are recorded for CPU memory storage and network. These values are recorded for each dependent node that is applicable. The query engine reports the business application direct or indirect dependency node s current state derived from the historical data last 24 hour roll up data . Next the impact the current state is likely to have on the BASG process is determined.

The message may also contain the classes object properties and data values associated with the BASG baseline. The query engine uses the score data and compares it with the ontology components that were sent with the message. The inference engine is instantiated to accomplish a predictive analysis of the BASG dependencies. For example adding a new VM may yield a result that current operating thresholds will be exceeded unless a new data storage device is added to the network.

The prediction inference engine examines the triples to determine if any inference can be made. Determined states are migrated into the RDF knowledge base by the state and profiling engine . State service tier metrics are converted to state colors names by the state and profiling engine . States are migrated into the RDF knowledge base by the state and profiling engine . Triples are created for each member of the BASG. For example ESX has state RED the structure of this triple is CLASS Object Property Class specifically HOST HAS STATE STATE NAME. These state triples are analyzed by the predictive engine by utilizing a generally available probabilistic logic network. 

A probabilistic logic network PLN is a conceptual mathematical and computational approach to performing uncertain inferences. In order to perform effective reasoning in real world circumstances artificial intelligence software should robustly handle uncertainty. By utilizing a PLN model the predictive engine can reason the state that a BASG will achieve if no other variables are introduced. The predictive engine assigns TruthValues to ranges of observed performance of ontological components when combined with other components that form a BASG.

These TruthValues are the observed ranges that translate to a StateName. For example a TruthValue for HOST ESX is 98.6 for CPU is CPU TruthValue 98.6. The PLN utilizes these TruthValues to return a new TruthValue. Each TruthValue contains a rule. The predictive engine contains TruthValue rules for BASG component CPU and memory. It also contains rules for triple based object properties such as has primarly application has Host uses network uses storage and the like.

By utilizing these rules the prediction engine employs a PLN based Inference engine that returns the predicted state the components will achieve if no changes are made. The web browser rendering engine updates the ontology workspace with the predicted state of each BASG member component as well as the overall BASG state. The web browser rendering engine updates the ontology workspace with the predicted state of each BASG member component as well as the overall BASG state. The operator may change any component from a baselined BASG and apply a new prediction as long as communicates with pairs are inserted together and not separated.

The method may include parsing service group ontology information stored in a memory of an established service group to determine components of a business application service group that are communicating with one another at operation . The method may also include tracking the current state of the business application service group to determine if any changes have occurred since a previous service business application service group configuration and if so updating the ontology information to reflect those changes at operation and generating a list of candidate virtual machines that are candidates for participating in the established baseline at operation .

Another example method of operation of the present invention is illustrated in the flow diagram of . Referring to one example operation may include collecting performance data of present operating conditions of a plurality of network components operating in the enterprise network and storing the performance data in memory at operation . The method may include extracting ontological component data of the plurality of network components from the collected performance data at operation . The method may also include comparing the collected performance data with predefined service tier threshold parameters at operation . The method may further include determining if the ontological component data represents operational relationships between the plurality of network components at operation and establishing direct and indirect relationships between the plurality of network components based on the determined operational relationships and establishing a business application service group based on the ontological component data and storing the established business application service group in memory at operation .

The exemplary computer system includes a processing device a main memory e.g. read only memory ROM flash memory dynamic random access memory DRAM such as synchronous DRAM SDRAM or Rambus DRAM RDRAM etc. a static memory e.g. flash memory static random access memory SRAM etc. and a secondary memory e.g. a data storage device which communicate with each other via a bus .

Processing device represents one or more general purpose processing devices such as a microprocessor central processing unit or the like. More particularly the processing device may be a complex instruction set computing CISC microprocessor reduced instruction set computing RISC microprocessor very long instruction word VLIW microprocessor processor implementing other instruction sets or processors implementing a combination of instruction sets. Processing device may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. Processing device is configured to execute instructions for performing the operations and steps discussed herein.

The computer system may further include a network interface device . The computer system also may include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT an alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse and a signal generation device e.g. a speaker .

The secondary memory may include a machine readable storage medium or more specifically a computer readable storage medium on which is stored one or more sets of instructions embodying any one or more of the methodologies or functions described herein. The instructions may also reside completely or at least partially within the main memory and or within the processing device during execution thereof by the computer system the main memory and the processing device also constituting machine readable storage media.

The machine readable storage medium may also be used to store software performing the operations discussed herein and or a software library containing methods that call this software. While the machine readable storage medium is shown in an exemplary embodiment to be a single medium the term machine readable storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine readable storage medium shall also be taken to include any medium that is capable of storing or encoding a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention. The term machine readable storage medium shall accordingly be taken to include but not be limited to solid state memories and optical and magnetic media.

Some portions of the detailed description above are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as receiving determining encrypting decrypting sending or the like refer to the actions and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical e.g. electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage devices.

Embodiments of the invention also relate to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct a more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear from the description below. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.

The operations of a method or algorithm described in connection with the embodiments disclosed herein may be embodied directly in hardware in a computer program executed by a processor or in a combination of the two. A computer program may be embodied on a computer readable medium such as a storage medium. For example a computer program may reside in random access memory RAM flash memory read only memory ROM erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM registers hard disk a removable disk a compact disk read only memory CD ROM or any other form of storage medium known in the art.

An exemplary storage medium may be coupled to the processor such that the processor may read information from and write information to the storage medium. In the alternative the storage medium may be integral to the processor. The processor and the storage medium may reside in an application specific integrated circuit ASIC . In the alternative the processor and the storage medium may reside as discrete components.

It is to be understood that the above description is intended to be illustrative and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reading and understanding the above description. Although the present invention has been described with reference to specific exemplary embodiments it will be recognized that the invention is not limited to the embodiments described but can be practiced with modification and alteration within the spirit and scope of the appended claims. Accordingly the specification and drawings are to be regarded in an illustrative sense rather than a restrictive sense. The scope of the invention should therefore be determined with reference to the appended claims along with the full scope of equivalents to which such claims are entitled.

While preferred embodiments of the present invention have been described it is to be understood that the embodiments described are illustrative only and the scope of the invention is to be defined solely by the appended claims when considered with a full range of equivalents and modifications e.g. protocols hardware devices software platforms etc. thereto.

