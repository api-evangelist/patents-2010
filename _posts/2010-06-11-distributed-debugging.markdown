---

title: Distributed debugging
abstract: In an embodiment, a first debug agent at a first computer receives a packet. The first debug agent adds a debug command and an identifier of the first debug agent to the packet and sends the packet to a receiving computer. A second debug agent at the receiving computer removes the debug command and the identifier of the first debug agent from the packet and sends the packet to a second program that executes at the receiving computer. The second debug agent further executes the debug command, which causes the second program that executes on the receiving computer to halt execution at a breakpoint or address watch memory location. The second debug agent sends the state of the second program to the first debug agent, which presents, at the first computer, the state and a listing of the second program.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08856742&OS=08856742&RS=08856742
owner: International Business Machines Corporation
number: 08856742
owner_city: Armonk
owner_country: US
publication_date: 20100611
---
An embodiment of the invention generally relates to computer systems and more particularly to debugging computer programs on distributed computer systems.

Computer systems typically comprise a combination of computer programs and hardware such as semiconductors transistors chips and circuit boards. The computer programs are stored in the storage devices and are executed by the processors. As the sophistication and complexity of computer programs increase the programs become more difficult to debug. Bugs are problems faults or errors in a computer program. Locating analyzing and correcting suspected faults in a computer program is a process known as debugging. Typically a programmer uses another computer program commonly known as a debugger to debug the program under development.

Conventional debuggers typically support three primary types of operations which a computer programmer may request via a user interface. A first type is a breakpoint or address watch operation which permits a programmer to identify with a breakpoint a precise instruction at which to halt execution of the program by the processor or identify via an address watch a memory location for the processor to monitor for content modification at which time the program s execution is halted. As a result when a program is executed by the debugger the program executes on the processor in a normal fashion until the breakpoint is reached or the contents of the monitored memory location are written to at which time the debugger halts execution of the program. A second type is a step operation which permits a computer programmer to cause the processor to execute instructions in a program either one by one or in groups. After each instruction or group of instructions are executed the debugger then halts execution of the program. Once the execution of the program is halted either by step or breakpoint operations conventional debuggers provide a third type of operation which displays the content that is stored at various storage locations in response to requests by the programmer. By this debugging process of halting the program at various instructions and examining the content of various storage locations the programmer might eventually find the storage location whose stored content such as an instruction or data is incorrect or unexpected.

A method computer readable storage medium and distributed debug system are provided. In an embodiment a first debug agent at a first computer receives a packet from a first program. The first debug agent adds a debug command and an identifier of the first debug agent to the packet and sends the packet to a receiving computer. A second debug agent at the receiving computer removes the debug command and the identifier of the first debug agent from the packet and sends the packet to a second program that executes at the receiving computer. The second debug agent further executes the debug command which causes the second program that executes on the receiving computer to halt execution at a breakpoint or halt when the address watch memory location is updated. The second debug agent sends the state of the second program to the first debug agent which presents at the first computer the state and a listing of the second program.

It is to be noted however that the appended drawings illustrate only example embodiments of the invention and are therefore not considered a limitation of its scope for the invention may admit to other equally effective embodiments.

Referring to the Drawings wherein like numbers denote like parts throughout the several views depicts a high level block diagram representation of a computer system connected to a network according to an embodiment of the present invention. The major components of the computer system include one or more processors a main memory a terminal interface a storage interface an I O Input Output device interface and a network adapter all of which are communicatively coupled directly or indirectly for inter component communication via a memory bus an I O bus and an I O bus interface unit .

The computer system contains one or more general purpose programmable central processing units CPUs A B C and D herein generically referred to as the processor . In an embodiment the computer system contains multiple processors typical of a relatively large system however in another embodiment the computer system may alternatively be a single CPU system. Each processor executes instructions stored in the main memory and may include one or more levels of on board cache.

The main memory is a random access semiconductor memory storage device or storage medium for storing or encoding data and programs. In another embodiment the main memory represents the entire virtual memory of the computer system and may also include the virtual memory of other computer systems coupled to the computer system or connected via the network . The main memory is conceptually a single monolithic entity but in other embodiments the main memory is a more complex arrangement such as a hierarchy of caches and other memory devices. For example memory may exist in multiple levels of caches and these caches may be further divided by function so that one cache holds instructions while another holds non instruction data which is used by the processor or processors. Memory may be further distributed and associated with different CPUs or sets of CPUs as is known in any of various so called non uniform memory access NUMA computer architectures.

The main memory stores or encodes programs a packet network resources a debug agent and saved debug data . Although the programs the packet the network resources the debug agent and the saved debug data are illustrated as being contained within the memory in the computer system in other embodiments some or all of them may be on different computer systems and may be accessed remotely e.g. via the network . The computer system may use virtual addressing mechanisms that allow the programs of the computer system to behave as if they only have access to a large single storage entity instead of access to multiple smaller storage entities. Thus while the programs the packet the network resources the debug agent and the saved debug data are illustrated as being contained within the main memory these elements are not necessarily all completely contained in the same storage device at the same time. Further although the programs the packet the network resources the debug agent and the saved debug data are illustrated as being separate entities in other embodiments some of them portions of some of them or all of them may be packaged together.

The programs comprise code that executes on the processor of the computer system and copies of programs that execute on other computer systems that are connected to the computer system via the network . The program is a program being debugged via the debug agent . The program may be any type of executable or interpretable code or statements whether in source or object form. In various embodiments the program may be an application program an operating system program a network application an application server a server program a grid program a scientific calculation manager a query optimizer or any other type of program.

The packet comprises data which the programs read write and send receive to other computer systems via the network . In various embodiments the packet may comprise data a database objects classes code a file a hierarchy of directories subdirectories and files a data structure or any other type of data or information repository.

The network resources manage the sending and receiving of packets via the network . In various embodiments the network resources comprise a socket an API Application Programming Interface an object request broker or a configuration file. In another embodiment the network resources comprise a program module method class or object that comprises units of instructions or statements that execute on the computer system .

The debug agent manages breakpoints and address watches in the programs in response to receiving a debug command which may be issued on a command line entered through a graphical user interface or issued via an application. A breakpoint is a statement or instruction within the programs at which the user desires to halt execution of the programs . An address watch monitors a memory location such as an address field object record or file and halts execution of the program in response to the program modifying updating or writing to the contents of that memory location. As a result when the programs are executed by the debug agent the programs execute on the processor in a normal fashion until the breakpoint is reached or the monitored memory location is modified. The debug agent then stops execution of the program at the breakpoint instruction or the instruction that modified the memory location and displays the results and or state of the program and or the state of the computer system to the user for analysis on a debugger user interface via the user input output device .

The debug agent sets breakpoints in the program e.g. by replacing a valid statement or instruction at a breakpoint location in the program with an invalid instruction and by creating a record for the breakpoint in a breakpoint table. The debug agent initiates an address watch via a function of the processor which monitors a memory location specified by the debug agent . After the breakpoints and or the address watch are set the user provides an input to a debug user interface that resumes execution of the program . In response to the execution of the program eventually encountering the invalid statement or instruction or the contents of the monitored memory location eventually being modified a system exception or interrupt occurs which halts execution of the program and gives control of the processor to the debug agent . The debug agent then gives control to the user via a debug user interface and the user may then issue commands to the debug agent via the user interface which the debug agent interprets to find and display the statements or instructions that define the content of an input storage location to display the contents of storage locations to set or remove breakpoints or address watch functions to resume execution of the program or any other appropriate operations.

The saved debug data comprises data that the debug agent has saved. The saved debug data is further described below with reference to . The debug agent uses the saved debug data to implement distributed debugging as further described below with reference to and .

In an embodiment one some or all of the programs the network resources and the debug agent include instructions or statements that execute on the processor or instructions or statements that are interpreted by instructions or statements that execute on the processor to carry out the functions as further described below with reference to and . In an embodiment one some or all of the programs the network resources and the debug agent are implemented in hardware via semiconductor devices chips logical gates circuits circuit cards and or other physical hardware devices in lieu of or in addition to a processor based system.

The memory bus provides a data communication path for transferring data among the processor the main memory and the I O bus interface unit . The I O bus interface unit is further coupled to the system I O bus for transferring data to and from the various I O units. The I O bus interface unit communicates with multiple I O interface units and which are also known as I O processors IOPs or I O adapters IOAs through the system I O bus .

The I O interface units support communication with a variety of storage and I O devices. For example the terminal interface unit supports the attachment of one or more user input output devices which may include user output devices such as a video display device speaker printer and or television set and user input devices such as a keyboard mouse keypad touchpad trackball buttons light pen or other pointing device . A user may manipulate the user input devices in order to provide input to the user input output device and the computer system via a user interface and may receive output via the user output devices. For example a user interface may be presented via the user input output device such as displayed on a display device played via a speaker or printed via a printer.

The storage interface unit supports the attachment of one or more direct access storage devices DASD and which are typically rotating magnetic disk drive storage devices although they could alternatively be other devices including arrays of disk drives configured to appear as a single large storage device to a host . In another embodiment the devices and or may be implemented via any type of secondary storage device. The contents of the main memory or any portion thereof may be stored to and retrieved from the direct access storage devices and as needed.

The I O device interface provides an interface to any of various other input output devices or devices of other types such as printers or fax machines. The network adapter provides one or more communications paths from the computer system to other digital devices and computer systems such paths may include e.g. one or more networks .

Although the memory bus is shown in as a relatively simple single bus structure providing a direct communication path among the processors the main memory and the I O bus interface in fact the memory bus may comprise multiple different buses or communication paths which may be arranged in any of various forms such as point to point links in hierarchical star or web configurations multiple hierarchical buses parallel and redundant paths or any other appropriate type of configuration. Furthermore while the I O bus interface and the I O bus are shown as single respective units the computer system may in fact contain multiple I O bus interface units and or multiple I O buses . While multiple I O interface units are shown which separate the system I O bus from various communications paths running to the various I O devices in other embodiments some or all of the I O devices are connected directly to one or more system I O buses.

In various embodiments the computer system may be a multi user mainframe computer system a single user system or a server or similar device that has little or no direct user interface but receives requests from other computer systems clients . In other embodiments the computer system may be implemented as a desktop computer portable computer laptop or notebook computer tablet computer pocket computer telephone pager automobile teleconferencing system appliance or any other appropriate type of electronic device.

The network may be any suitable network or combination of networks and may support any appropriate protocol suitable for communication of data and or code to from the computer system . In various embodiments the network may represent a storage device or a combination of storage devices either connected directly or indirectly to the computer system . In another embodiment the network may support wireless communications. In another embodiment the network may support hard wired communications such as a telephone line or cable. In another embodiment the network may be the Internet and may support IP Internet Protocol .

In another embodiment the network may be a local area network LAN or a wide area network WAN . In another embodiment the network may be a hotspot service provider network. In another embodiment the network may be an intranet. In another embodiment the network may be a GPRS General Packet Radio Service network. In another embodiment the network may be a FRS Family Radio Service network. In another embodiment the network may be any appropriate cellular data network cell based radio network. In still another embodiment the network may be any suitable network or combination of networks. Although one network is shown in other embodiments any number of networks of the same or different types may be present.

It should be understood that is intended to depict the representative major components of the computer system and the network at a high level that individual components may have greater complexity than represented in that components other than or in addition to those shown in may be present and that the number type and configuration of such components may vary. Several particular examples of such additional complexity or additional variations are disclosed herein it being understood that these are by way of example only and are not necessarily the only such variations.

The various program components illustrated in and implementing various embodiments of the invention may be implemented in a number of manners including using various computer applications routines components programs objects modules data structures etc. and are referred to hereinafter as computer programs or simply programs. The computer programs comprise one or more instructions or statements that are resident at various times in various memory and storage devices in the computer system and that when read and executed by one or more processors in the computer system or when interpreted by instructions that are executed by one or more processors cause the computer system to perform the actions necessary to execute steps or elements comprising the various aspects of embodiments of the invention.

As will be appreciated by one skilled in the art aspects of embodiments of the present invention may be embodied as a system method or computer program product. Accordingly aspects of embodiments of the present invention may take the form of an entirely hardware embodiment an entirely program embodiment including firmware resident programs micro code etc. which are stored in a storage device or an embodiment combining program and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore embodiments of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples an non exhaustive list of the computer readable storage media may comprise an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may comprise a propagated data signal with computer readable program code embodied thereon for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that communicates propagates or transports a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wire line optical fiber cable Radio Frequency RF or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of embodiments of the present invention may be written in any combination of one or more programming languages including object oriented programming languages and conventional procedural programming languages. The program code may execute entirely on the user s computer partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of embodiments of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products. Each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams may be implemented by computer program instructions embodied in a computer readable medium. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified by the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions that implement the function act specified by the flowchart and or block diagram block or blocks. The computer programs defining the functions of various embodiments of the invention may be delivered to a computer system via a variety of tangible computer readable storage media that may be operatively or communicatively connected directly or indirectly to the processor or processors.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowcharts and or block diagram block or blocks.

The flowchart and the block diagrams in the figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowcharts or block diagrams may represent a module segment or portion of code which comprises one ore more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It should also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flow chart illustrations can be implemented by special purpose hardware based systems that perform the specified functions or acts in combinations of special purpose hardware and computer instructions.

Embodiments of the present invention may also be delivered as part of a service engagement with a client corporation nonprofit organization government entity or internal organizational structure. Aspects of these embodiments may comprise configuring a computer system to perform and deploying computing services e.g. computer readable code hardware and web services that implement some or all of the methods described herein. Aspects of these embodiments may also comprise analyzing the client company creating recommendations responsive to the analysis generating computer readable code to implement portions of the recommendations integrating the computer readable code into existing processes computer systems and computing infrastructure metering use of the methods and systems described herein allocating expenses to users and billing users for their use of these methods and systems.

In addition various programs described hereinafter may be identified based upon the application for which they are implemented in a specific embodiment of the invention. But any particular program nomenclature that follows is used merely for convenience and thus embodiments of the invention should not be limited to use solely in any specific application identified and or implied by such nomenclature.

The exemplary environments illustrated in are not intended to limit the present invention. Indeed other alternative hardware and or program environments may be used without departing from the scope of embodiments the invention.

The server computer system node comprises a server program network resources a debug agent and saved debug data . The server computer system node comprises a server program network resources a debug agent and saved debug data . The server computer system node comprises a server program network resources a debug agent and saved debug data . The load balancer computer system server node comprises a server program network resources a debug agent and saved debug data . The client computer system node comprises a program server programs and network resources a debug agent and saved debug data . The programs and are examples of and are generically referred to by the programs . The network resources and are examples of and are generically referred to by the network resources . The debug agents and are examples of and are generically referred to by the debug agent . The saved debug data and are examples of and are generically referred to by the saved debug data .

The programs and comprise the instructions that the debug agents and debug. In an embodiment all of the programs and are identical. In another embodiment some or all of the programs and are different from each other.

The program in the client computer system node comprises code that executes on a processor at the client computer system node . The server programs and in the client computer system node are copies of the server programs and at the server computer system nodes and and the load balancer computer system node respectively. The server programs and do not execute at the client computer system node . Instead the client computer system node may display the program listings of one or more of the server programs and and their state information in order to aid in debugging as further described below with reference to in addition to displaying the program listings of the program and its state information. Program listings include the source code and or compiled object code instructions or statements that are included in the program. The program listing may also include instruction or statement numbers that identify the instructions or statements and the order of the instructions or statements within the listing.

The load balancer computer system node receives requests or packets of data from the client computer system node and distributes them for processing to the server computer system nodes and . The use of the terms client and server are for convenience and a computer system node that acts as a client in one scenario may act as a server in another scenario and vice versa.

In an embodiment a user interacts with the debug agent via the user input output device to debug the programs and or .

While the program is halted the user requests via a debug command entered via the input output device that the debug agent set a breakpoint at an instruction in one or more of the server programs and or that execute on the server nodes and or or establish an address watch on the contents of an address in the memory of the server nodes and or . The debug agent saves the debug command in the saved debug data . The user then requests via the user input output device that the debug agent start the program executing on the client . The program executes and creates a packet of data and or command s for sending to the load balancer . The debug agent intercepts the packet adds the saved debug command and identifier of the debug agent to the packet and sends the packet to the load balancer which sends the packet to one or more of the servers or where the packet is processed handled or executed.

The debug agent or at the respective server or intercepts or receives the packet from the respective network resources or removes or deletes the debug command and identifier of the debug agent from the packet saves the debug command and identifier of the debug agent in the respective saved debug data or sets the requested breakpoint or address watch in the respective server program or that executes at the respective computer node or respectively and then forwards the packet to the respective server program or .

In response to the execution of the server program or encountering the instruction at which the breakpoint is set or that modifies the contents of the memory location monitored by an address watch the debug agent or halts execution of the server program or finds the identifier of the debug agent in the saved debug data or and sends the state of the halted server program or to the debug agent . The debug agent finds the copy of the server program or at the client computer system node that encountered the breakpoint while executing at the computer system nodes or and presents or displays the copy of the server program or at the client computer system node with the state information.

The grid computer system node comprises a grid program objects an object request broker a debug agent and saved debug data . The grid computer system node comprises a grid program objects an object request broker a debug agent and saved debug data . The grid computer system node comprises a grid program objects an object request broker a debug agent and saved debug data . The grid computer system node comprises a grid program objects an object request broker a debug agent and saved debug data . The client computer system node comprises grid programs and objects an object request broker a debug agent and saved debug data .

The grid programs and are examples of and are generically referred to by the grid programs . The objects and are examples of and are generically referred to by the packet . The object request brokers and are examples of and are generically referred to by the network resources . The debug agents and are examples of and are generically referred to by the debug agent . The saved debug data and are examples of and are generically referred to by the saved debug data .

The grid programs and comprise the instructions that the debug agents and debug. In an embodiment all of the grid programs and are identical. In another embodiment some or all of the grid programs and are different from each other.

The grid program in the client computer system node comprises code that executes on a processor at the client computer system node . The grid programs and in the client computer system node are copies of the grid programs and at the grid computer system nodes and and the grid computer system node respectively. The grid programs and do not execute at the client computer system node . Instead the client computer system node may display the program listings of one or more of the grid programs and and their state information in order to aid in debugging as further described below with reference to in addition to displaying the program listings of the grid program and its state information. The term client is used only for convenience and a grid computer system node that acts as a client in one scenario may act as a server in another scenario and vice versa.

The object request brokers and or may send the objects to various of the grid computer system nodes and or for processing by the various grid programs and or . The objects may travel between the grid computer system nodes any number of times.

In an embodiment a user interacts with the debug agent via the user input output device to debug the grid programs and or . While execution of the grid program is halted the user requests via a debug command entered via the input output device that the debug agent set a distributed address watch on the object or on any field or fields in the object . The debug agent saves the debug command in the saved debug data . The user then requests via the via the user input output device that the debug agent start the grid program executing on the client . The grid program executes and creates the object for sending to the grid computer system node and or via the object request broker . The debug agent intercepts the object adds the saved debug command and identifier of the debug agent to the object and sends the object to the grid computer system node and or .

The debug agent or at the grid computer system node or intercepts the object via the object request broker or removes the debug command and identifier of the debug agent from the object saves the debug command and identifier of the debug agent in the saved debug data or sets the distributed address watch on the object and then forwards the object to the grid program or for processing.

In response to the execution of the grid program or modifying the object or a field or fields in the object the debug agent or halts execution of the grid program or finds the identifier of the debut agent in the saved debug data or and sends the state of the halted grid program or to the debug agent . The debug agent finds the copy of the grid program or that modified the object while executing at the computer system nodes or and displays the copy of the grid program or with the state information.

The debug user interface provides breakpoints and address watches to be established by interacting with a user via the user input output device . In some embodiments the user may define these breakpoints by issuing a debugger command that refers to high level language HLL references in the programs such as line or statement numbers or software object references such as a program or module name from which the physical storage address may be cross referenced. In various embodiments the debugger command may be issued on a command line or through a graphical user interface.

The parser parses debug commands from the debug user interface to create code which the interpreter interprets for execution on the processor . The parser parses debug commands using a table that was produced by a compiler or interpreter stored with the programs to map code line numbers code statement numbers variables names object names or field names in debugger commands to the actual physical storage address in the memory . The interpreter stores the physical storage addresses in memory such as in a breakpoint table. The interpreter further runs a program to set breakpoints in the programs and to establish address watches via processor functions. In an embodiment the interpreter sets breakpoints at breakpoint instructions in programs by replacing the breakpoint instruction with an invalid instruction which when executed on the processor halts execution of the program and causes the processor to send a system exception or interrupt to the breakpoint trap handler .

After the user requests that breakpoints and or address watches be set the user provides an input to the debug user interface that requests that execution of the program be resumed. Execution of the program eventually results in an encounter of a breakpoint or a modification of the contents at a storage location that has an address watch established which causes a system exception or interrupt. The breakpoint trap handler receives the exception or interrupt and passes information regarding the exception or interrupt to the debug hook .

Then the debug user interface utilizes the debug hook in order to obtain debugger commands. The debug hook is illustrated for instances where an interface is required between the debug user interface and the breakpoint trap handler . In an embodiment the debug hook may utilize an unillustrated result buffer to cache data for the debug user interface .

In response to a command entered via the debug user interface that requests resumption of execution of the program following execution of the program encountering a breakpoint instruction the interpreter replaces the invalid instruction at the breakpoint location with the original valid instruction of the program and restarts the program executing on the processor .

The example debug user interface includes a program listing program listing commands and a set breakpoint command a set distributed address watch command a run command an enable debug command and a disable debug command . Although the various commands and are illustrated as buttons displayed on a display device which are selected via an input device such as a mouse touch pad trackpad pointing device or keyboard in other embodiments the commands may be implemented as dials sliders widgets menu options line commands commands entered via a microphone and speech recognition commands or any other appropriate type of user input. Although the commands and are illustrated as line commands in other embodiments the commands and may be implemented as buttons dials sliders widgets menu options commands entered via a microphone and speech recognition commands or any other appropriate type of user input.

The program listing displays a listing of the source and or object code statements or instructions within the program or . If execution of the program is halted the program listing further comprises an indication of the statement or instruction number at which execution of the program is halted.

The program listing commands and request that the debug agent change the program listing between the programs or . In response to the program listing commands and the debug agent displays the program listing for the selected program including an indication of the statement or instruction number if any at which execution of the program is halted at the computer on which the displayed program executes. The computer system node on which the displayed program executes may be the same or different from the client at which the program listing is displayed.

The breakpoint command requests that the debug agent set a breakpoint at location within a program at a computer system node. The computer system node at which the breakpoint is requested to be set may be the same or different than the client at which the breakpoint command is issued. The command may specify the location by a statement or instruction number or by a function module method or procedure.

The set distributed address watch command requests that the debug agent establish a watch on a memory address at a computer system node or at all computer system nodes where the object is stored or will be stored in the future. The computer system node at which the address watch is requested to be set may be the same or different than the client at which the address watch command is issued. The distributed address watch command may specify the address by an object name pointer name variable name field name or file name. In response to the distributed address watch command the debug agent sets an address watch function in the processor at a specified computer system node or at all computer system nodes which causes the processor to raise an interrupt or system exception when the processor modifies the contents of memory at an address that the debug agent specifies. In response to the program modifying the contents of the storage location specified by the address watch the debug agent stops the program at the instruction that is modifying the storage. Thus an address watch breakpoint instruction is a load or store instruction accessing a location within a memory page being monitored as an address watch breakpoint.

The run command requests that execution be resumed for the halted program that is displayed by the program listing regardless of at which computer system node the program executes. In response to the run command the debug agent restarts execution of the halted program. The debug user interface may include other debug commands such as a step command which requests that the halted program execute for one instruction or for any specified number of instructions.

The enable debug command requests that debug processing be enabled. In response to the enable debug command the debug agent enables the instrumentation code within the network resources . The instrumentation code calls the debug agent in response to execution of a request to send or receive a packet or object to from a computer system node.

The disable debug command requests that debug processing be turned off or halted. In response to the disable debug command the debug agent disables the instrumentation code within the network resources so that the instrumentation code no longer calls the debug agent in response to execution of a request to send or receive a packet or object to from a computer system node.

The example debug user interface of includes a program listing a display state command and a display of the state of the server program represented by the program listing . The program listing displays a listing of the source and or object code statements or instructions within the server program that executes at the server computer system node A which is a different computer system node than the client computer system node at which the program listing is displayed. The debug agent at the client computer system node displays the program listing in response to the program listing command .

In the example of the state is the contents of a memory location at the server computer system node A that is named as the variable J which is read or written by the program executing at the server computer system node A . In other embodiments the state may be the contents of any variable parameter memory location pointer data structure file register database field or record that is read or written by a program that executes at any server computer system node or grid computer system node. In an embodiment the state may include an identifier of the statement or instruction that encountered the breakpoint or that modified the contents at the address monitored by the address watch and an identifier of a thread of the program that encountered the breakpoint or that modified the contents at the address monitored by the address watch. A thread of execution of a program results from a fork of the program into two or more concurrently running tasks or threads. In an embodiment the multiple threads share resources such as memory but in another embodiment the threads do not share memory. In an embodiment the multiple threads may execute simultaneously or concurrently on different processors. In another embodiment the multiple threads execute on a single processor via time division multiplexing or multitasking where the single processor switches between different threads via context switches that happen frequently enough so that a user perceives the threads as executing simultaneously.

In other embodiments the state may be a call stack execution stack run time stack function stack or invocation stack of the program whose listing is displayed in the program listing . A call stack stores information about the active methods procedures or subroutines of an executing program including some or all of the return address of a subroutine the location of the instruction to return to after the subroutine ends the values of local variables read or written by the subroutine parameters passed to the subroutine an evaluation stack of operands for arithmetic or logical operations a pointer to the current instance of the subroutine the enclosing subroutine context and or the privilege or authority level of the subroutine.

The example saved debug data comprises example rows and each of which comprises a debug command field a client computer system debug agent identifier field and a processing computer system node identifier field . The debug command field stores a debug command that the client debug agent identified by the client computer system debug agent identifier field in the same row received from a user interface. In an embodiment the client computer system debug agent identifier identifies both the debug agent and the client computer system node or network address of the client computer system node on which the client debug agent executes.

The processing computer system node identifier field stores an identifier of the computer system node where the user via the user interface requested that that debug command in the same row be processed executed or performed. For example the row indicates that the debug command of set breakpoint when packet received which was received from a user interface at the client computer system node Node E requests that a breakpoint be set at the statement in the processing computer system nodes of Node A Node B and Node C that receives a packet. As another example the row indicates that the debug command of set distributed address watch on all fields of object A which was received from a user interface at the client computer system node Node E requests that an address watch function be established at all computer system nodes.

Control then continues to block where the debug agent at the client receives an enable debug command from the debug user interface. In response to the enable debug command control then continues to block where the debug agent at the client computer system node enables turns on or adds instrumentation code in the network resources or the object request broker at the client computer system node and all of the server computer system nodes or grid computer system nodes. In an embodiment the debug agent sends a request to all of the server computer system nodes or grid computer system nodes instructing them to add turn on or enable instrumentation code in their respective network resources or object request brokers. The debug agents at the server computer system nodes or grid computer system nodes receive the request and in response add turn on or enable instrumentation code in their respective network resources or object request brokers. Control then continues to block where the logic of returns.

In response to the receipt of the debug command control then continues to block where if the debug command specifies that the debug command is to be performed at the client or if the debug command specifies that the debug command is to be performed at all computer system nodes then the debug agent performs or executes the debug command such as setting a breakpoint in a program that executes at the client computer system node setting an address watch on an object stored at the client computer system node starting a program executing at the client computer system node or stepping execution of a program at the client computer system node by one instruction or statement or a specified number of instructions or statements.

If the debug command specifies a server grid node that is different from the client computer system node or if the debug command specifies all nodes then the debug agent at the client computer system node saves the received debug command set breakpoint command set distributed address watch command run command or step command an identifier of the client debug agent and the identifier of the processing node a specified server or grid computer system node or nodes or all nodes at which the debug command is to be performed to the saved debug data in the memory of the client computer system node.

Control then continues to block where the program at the client computer system node or any server computer system node or grid computer system node creates a packet of data creates an object or finds a pre existing packet object that was previously received from another computer system node as further described below with reference to block and sends the packet or object to the network resources or the object request broker. The packet specifies a destination computer node identifier that identifies the destination computer node for the packet. The destination computer identified by the destination node identifier comprises a program that executes at that destination computer and that is intended to receive and process the packet. Control then continues to block where the network resources or the object request broker determines whether its instrumentation code is enabled or present.

If the determination at block is true then the instrumentation code is enabled or present so control continues to block where the instrumentation code in the network resources or the object request broker sends the packet or object to the debug agent at the same computer node as the network resources instead of sending the packet or object to the destination computer system node identified by the destination computer node identifier via the network. Control then continues to block where the debug agent receives the packet or object and in response determines whether any saved debug data is present at the computer system node of the debug agent .

If the determination at block is true then the saved debug data is present at the computer system node of the debug agent so control continues to block where the debug agent adds the saved identifier of the client debug agent the saved identifier of the processing node or nodes or an indication of all nodes for the debug command and the saved debug command from the saved debug data for all rows in the saved debug data to the packet or object. In an embodiment the processing node identifier is identical to the destination node identifier that identifies the computer node to which the packet is sent. In another embodiment the processing node identifier is different than the destination node identifier. The processing node identifier and the destination node identifier may be different in embodiments where the packet or object is sent between multiple nodes.

For example in the user at the client computer system node may desire to set a breakpoint or address watch at one or more of the servers or but not on the load balancer server node yet packets from the client computer system node are first sent to the load balancer server node which sends packets to the other nodes. Thus the program at the client computer system node sets the destination node identifier in the packet to indicate the load balancer server node since that is the destination node to which the client computer system node sends the packet but the debug agent sets the processing node identifier to indicate server and or where the user desires the breakpoint or address watch to be set.

As another example in the user at the client grid node may desire to set a breakpoint or address watch at the grid node but the grid program sends an object to the grid node . The grid node subsequently sends to the object to the grid node which sends the object to the grid node which ultimately sends the object to the grid node . Thus the debug agent at the client grid node sets the processing node identifier to indicate the grid node but the grid program sets the destination node identifier in the object to indicate the grid node .

The saved identifier of the client debug agent identifies the client debug agent at the client computer system node that initially requested the saved debug command which may be different but is not necessarily different from the computer system node that is currently executing the logic of . The debug agent performs the processing of block for all records all saved debug commands in the saved debug data .

Control then continues to block where the debug agent sends the packet or object with the identifier s of the client debug agent s the debug command s and the processing node identifier s for the debug commands to the destination server computer system node or destination grid computer system node of the packet object. Control then continues to block where the logic of returns.

If the determination at block is false then a saved debug command is not present in the saved debug data at the computer system node so control continues to block where the debug agent sends the packet or object to the destination computer system node without adding a saved debug command a saved processing node identifier or a saved client debug agent identifier to the packet or object. Control then continues to block where the logic of returns.

If the determination at block is false then the instrumentation code in the network resources or object request broker is not present or is not enabled so control continues to block where the network resources or object request broker sends the packet or object to the destination computer system node without sending the packet object to the debug agent and without adding a saved debug command a saved processing node identifier or identifier of a client debug agent to the packet or object. Control then continues to block where the logic of returns.

Control then continues to block where the network resources or object request broker at a receiving computer node at any client computer system node or at any server grid computer system node receives a packet or object from an origin computer system node via the network .

Control then continues to block where the network resources or object request broker determines whether the received packet or object comprises a debug command e.g. a set breakpoint command set address watch command a run command or a step command an identifier of a client debug agent that initiated the debug command and an identifier of a processing node where the debug command is to be performed.

If the determination at block is true then the received packet or object comprises a debug command an identifier of a client debug agent and a processing node identifier so control continues to block where the instrumentation code in the network resources or object request broker sends the received packet or object to the debug agent at the local computer system node where the instrumentation code and debug agent execute instead of sending the packet object to the grid server program at the local computer system node.

Control then continues to block where the debug agent receives the packet object and removes the debug command the identifier of the client debug agent and the processing node identifier from the packet object . Control then continues to block where the debug agent saves the removed debug command the removed processing node identifier and the removed identifier of the client debug agent to the saved debug data .

Control then continues to block where the debug agent determines whether the receiving computer node identifier of the receiving computer node the node where the network resources and the debug agent execute matches is identical to is included or encompassed by or is one of the processing node identifier in the packet or object. If the determination at block is true then the receiving computer node identifier matches the processing node identifier so control continues to block where the debug agent executes or performs the removed and saved debug command. For example the debug agent sets the breakpoint in the local program establishes the address watch on a memory location in the receiving computer node or causes the local program at the receiving computer node to start executing or step execute for a specified number of instructions or statements. Control then continues to block where the debug agent sends the packet or object to the local program at the receiving computer system node of the debug agent without the removed debug command the removed processing node identifier and the removed client agent identifier. The local program executes at the same receiving computer node and receives and processes the packet object e.g. by reading or writing data or performing a request or command indicated by the packet object . The processing of the program may include requesting that the packet object be sent to another computer system node which was previously described above with reference to .

If the determination at block is false then the receiving computer node identifier of the receiving computer node that received the packet object does not match the processing node identifier of the debug command in the packet object so control continues to block where the debug agent sends the packet object to the local program at the receiving computer system node of the debug agent without the removed debug command the removed processing node identifier and the client agent identifier and the debug agent does not execute or perform the removed debug command. The local program executes at the same computer node and receives and processes the packet or object e.g. by reading or writing data or performing a request or command indicated by the packet or object. The processing of the program may include requesting that the packet object be sent to another computer system node which was previously described above with reference to . Control then continues to block where the logic of returns.

If the determination at block is false then the received packet object does not comprise a debug command a processing node identifier and an identifier of a client debug agent so control continues to block where the network resources or object request broker sends the packet object to the local program at the same computer node the receiving computer node without sending the packet or object to the debug agent . The local program executes at the same computer node and receives and processes the packet or object e.g. by reading or writing data or performing a request or command as indicated by the packet or object. The processing of the program may include requesting that the packet object be sent to another computer system node which was previously described above with reference to .

Control then continues to block where the debug agent at any computer system node receives an interrupt or system exception and the execution of the program or one particular thread of the program at that computer system node is halted at an instruction. The interrupt or system exception indicates that the execution of the instruction in the program or thread of the program encountered or attempted to execute an instruction at which a breakpoint is set or the memory contents at the address being monitored by the address watch function was modified by the instruction of the executing program or thread.

In an embodiment the program encountered the breakpoint or modified the contents at the address monitored by the address watch while processing executing performing handling or responding to the packet or object to which a debug command was added that caused that breakpoint or address watch function to be set or initialized. In another embodiment the instruction in the program encountered the breakpoint or modified the contents at the address monitored by the address watch processing while processing executing performing handling or responding to the packet or object to which no debug command was added or while performing processing unrelated to any packet received by the program. In another embodiment the instruction in the program encountered the breakpoint or modified the contents at the address monitored by the address watch processing while processing executing performing handling or responding to the packet or object to which a different debug command was added that is unrelated to the breakpoint encountered or monitored address that caused that interrupt.

Control then continues to block where the debug agent finds in the saved debug data the saved identifier of the client debug agent that requested the breakpoint or address watch that caused the interrupt or system exception. Control then continues to block where the debug agent sends the state of halted program and an identifier of the halted program and or an identifier of the thread of the halted program to the client debug agent that is identified by the saved client debug agent identifier . Control then continues to block where the logic of returns.

Control then continues to block where the client debug agent receives via the network the state of a program thread and an identifier of a program thread that halted execution by encountering a breakpoint or modifying contents of a memory location that was monitored by an address watch on another computer system node that is different from the computer system node on which the client debug agent executes.

Control then continues to block where the client debug agent finds the copy of the halted program which in an embodiment does not execute at the local computer of the client debug agent that has identifier that matches the received identifier of the halted program at the local computer on which the client debug agent executes and presents via the user I O device displays via a display device prints via a printer or plays via a speaker device the received state and a copy of the program listing of the program. Control then continues to block where the logic of returns.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of the stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

In the previous detailed description of exemplary embodiments of the invention reference was made to the accompanying drawings where like numbers represent like elements which form a part hereof and in which is shown by way of illustration specific exemplary embodiments in which the invention may be practiced. These embodiments were described in sufficient detail to enable those skilled in the art to practice the invention but other embodiments may be utilized and logical mechanical electrical and other changes may be made without departing from the scope of the present invention. In the previous description numerous specific details were set forth to provide a thorough understanding of embodiments of the invention. But embodiments of the invention may be practiced without these specific details. In other instances well known circuits structures and techniques have not been shown in detail in order not to obscure embodiments of the invention.

Different instances of the word embodiment as used within this specification do not necessarily refer to the same embodiment but they may. Any data and data structures illustrated or described herein are examples only and in other embodiments different amounts of data types of data fields numbers and types of fields field names numbers and types of rows records entries or organizations of data may be used. In addition any data may be combined with logic so that a separate data structure is not necessary. The previous detailed description is therefore not to be taken in a limiting sense and the scope of the present invention is defined only by the appended claims.

