---

title: Lifecycle stable user interface adaptations
abstract: Various embodiments of systems and methods for lifecycle stable user interface adaptations are described herein. All adaptations done by partners/key users/end users to a user interface of a computer software application are preserved during the lifecycle of the application. In one aspect, the adaptations are persisted as additional metadata used for the generation of the user interface. In another aspect, the lifecycle stability is achieved by attaching the adaptations to semantically coherent set of fields placed in the UI that reappear in future releases of the computer software application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08555249&OS=08555249&RS=08555249
owner: SAP AG
number: 08555249
owner_city: Walldorf
owner_country: DE
publication_date: 20101213
---
The field relates to user interfaces UIs . More precisely the field relates to preserving user adaptations over a base UI model during its lifecycle.

There are many business oriented computer applications providing the user with the ability to modify parts of the UI of the application for better visibility and or functionality. The user is given the option to show and hide elements change the location of UI elements on the screen rename some text elements add custom fields etc. When the computer application is updated due to an upgrade the user adaptations to the old version are lost and the user partner is forced to apply his customizations again with every release of the computer application.

There is a need for improved methods and systems that allow lifecycle stable UI adaptations. Thus the user is not forced to react on updates of the computer application and is able to utilize the computer application undisturbed from any new releases. The only acceptable change from the user s point of view is minor repositioning of the change as long as it preserves the semantics derived from the surrounding context. For example in a business environment if a user adds a custom field distance in the screen area supplier after an upgrade the field distance must again be placed in the section supplier and not in an area bill to party or a generic area lost and found where the semantics of the field cannot be preserved. The semantic should be preserved even if the section is moved to a new UI screen.

Various embodiments of systems and methods for lifecycle stable UI adaptations are described herein. In one embodiment the method includes receiving one or more user interface UI adaptations to a default UI and saving the one or more UI adaptations in a metadata file maintained for storing the one or more UI adaptations. The method also includes reconstructing the one or more UI adaptations by combining the metadata file together with a data file used for generation of the default UI.

In other embodiments the system includes at least one processor for executing program code and memory a display to visualize a UI an input device to receive user s UI adaptations and a file system repository to persist information for the generation of the UI. The system also includes an extractor module within the memory to store the user s UI adaptations to the file system repository as a secondary source of information for UI generation and a UI generator module within the memory to generate the UI by combining a default source of information for UI generation and the secondary source of information for UI generation.

These and other benefits and features of embodiments of the invention will be apparent upon consideration of the following detailed description of preferred embodiments thereof presented in connection with the following drawings.

Embodiments of techniques for lifecycle stable UI adaptations are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring aspects of the invention.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

Attaching extensions to UI entities and avoiding lifecycle issues during updates upgrades is achieved by attaching the extensions to strictly defined extension points that are called stable anchors. These stable anchors define a contract for the extension. The provider guarantees that all stable anchors released to users will exist in follow up releases. A stable anchor is defined by a system wide unique identification ID and a referenced entity. The stable anchors are semantically coherent set of fields placed in the UI. This set may either be a section group list query defaultSet floorplan in or outport pane container button group workcenter view work center assigned objects global settings quick link overview page or Really Simple Syndication RSS usage. Even when parts of the UI are rearranged in future releases of the UI these parts reappear in new revised versions of the UI as no functionalities are removed. Thus all UI parts for which there is additional metadata indicating what changes have been performed on the UI along the UI development process with the purpose of reconstructing any user adaptation are referred to as stable UI anchors. UI developers may delete stable anchors created during the current UI development until the UI is shipped to the user system. Then the stable anchors remain stable as their deletion is not allowed any more only movements of the stable anchors are allowed.

In the purchase order factsheet has the following screen areas that may be treated as stable anchors Purchase Order Overview General Information Supplier Bill to party Purchase Order Items . Button groups and outports are also considered as good candidates for stable anchors. Outports are output ports used for performing data binding between UI components. Thus changes to data displayed in one UI component affect data in another component. For example a list of employee names in a table view is displayed that lists all the employees in a company. This view can be connected to an output form that enables the user to select certain employees from the list and display them with all of their details. The information between the two forms is therefore bound together. 

The reference field is for ensuring that the field is added at the proper place of the repository behind the user interface. For example the field is added on the correct node of a business object BO . However the reference field has no information about how this field translates in a position in the UI and survives upgrades of the UI. For the position is used a stable anchor in the UI. For the use case of adding extension fields the best suited anchor is a group of fields in the UI. This group of fields can be a section group or a list . An extension field then has a reference to a reference field and to a stable anchor in the UI. The reference field takes care to recreate the field in the proper place in the BO for instance and the stable UI anchor takes care that the field will be again positioned into the right section group or list in the UI. The placement in the UI always happens relative to a stable anchor. Even if the exact placement of this field inside the correct section group cannot be guaranteed it is sufficient to have the field in the correct section group.

Every stable UI anchor has a unique name and a reference to a reference field. One single section group in the UI may be host for multiple anchors with different reference fields. This is the case when the UI developer has decided to put fields from different business contexts into one section group. In that case the key user or partner has to select the business context when trying to add an extension field to a section group. After the key user partner selects the business context for adding an extension field this field is created with a reference to the anchor selected. This mechanism ensures that even in future releases if the developer decides to split the fields from different business contexts into separate section groups or even UIs the extension fields follow the anchor that was selected during creation. This mechanism allows to re apply the addition of an extension field in the following cases moving a section group to another position of the same UI displaying data in a list instead of a form or in a form instead of a list merging to sections moving a section group to another UI splitting a section group into two section groups splitting a UI into two specialized UIs and distributing the section groups between the two UIs and creating a follow up UI that replaces two UIs.

In one embodiment for adding a mashup component in a floorplan an outport has to be available in the floorplan that exports the attributes needed for the mashup component. A mashup is a web page or application that uses and combines data presentation or functionality from two or more sources to create new services. For already known use cases address maps etc. these ports are defined and an adoption task is created to enable all floorplans with the already known outports. A mashup can connect to these outports and consume the attributes that are exported in the outports. A mashup has no way to access any data from a UI component if the data are not exposed via an outport. All outports which are supposed to be used by partners key users end users to enable mashups must be treated as stable UI anchors. For the ports the same applies as for the stable UI anchors described for extension fields. As soon as a stable anchor is released for the customers this anchor cannot be deleted from the UI instead identification is needed for where this outport has been moved to ensure that all configured mashups are also moved along the anchor to the new position. Together with the outports the port types used by these outports have also to be treated as stable UI anchors. In the above example of two outports qualify for stable anchors for mashup. The first is the outport Supplier Address and the other is the outport Bill to Address . Both outports adhere to the same port type Address and can be used for example to display map information for the addresses. The purchase order factsheet as any other floorplan exposes many more outports e.g. supplier Purchasing unit Buyer responsible but these outports may not be treated as stable UI anchors. Only for the ports that are defined as stable UI anchors the developer has to make sure that they will be available in all follow up releases. The outports may move to a completely new floorplan but they must be available in a followup release.

For the positioning of the mashup component on the UI some additional precaution is needed. For the example in the positioning of the mashup may add to the semantics of the displayed component. For example even a component is added for address on the floorplan it may be important to display the map for supplier under the supplier data and the map for Bill To data under the section of the Bill To data. In normal case the partner or key user positions the component in a meaningful way but in case the UI is changed in a follow up release for example the Supplier and Bill To data are displayed in two separate tabs instead of two separate sections then a fallback has to be defined that ensures that the business semantic remains intact. In one embodiment additional elements may be defined to exist on the UI screen for the business semantic to remain intact. In one embodiment the additional elements are selected from a contract section to the stable anchor by checking desired elements.

In one embodiment additional read only information in a floorplan is added. This use case is handled in a similar way as the before mentioned mashup use case. This means the user has to provide a UI component which can be embedded in an existing UI component e.g. factsheet as a loosely coupled component that gets the information via an outport of the embedding component. As discussed in the mashup use case a corresponding outport marked as stable anchor is needed in the floorplan. The loosely coupled component can then by itself retrieve any data needed from the backend. To enable this use case it makes sense to expose an outport in every floorplan that exports the key of the main BO of the floorplan in an outport that is marked as stable anchor.

In one embodiment navigation to an own UI component in a floorplan is added. This is launching a Customer UI component out of a standard floorplan. Here the same mechanism and stable anchors can be used. This outport can then be used to trigger navigation to a UI component. The easiest way is to place a button in the button group of the Contextual navigation Region top most button group of the UI. Another possibility is to introduce stable anchors that can be placed inside specific button groups and can be handled as all other stable UI anchors described before. In any follow up release it must be ensured that the stable UI anchors for buttons are again positioned in a button group. From Identity Access management viewpoint the additional UI component must be assigned to a Workcenter View that is assigned to a user to enable the navigation at runtime. There are two possible ways to achieve this either the user adds his UI component as assigned object to an already existing Workcenter View or the user creates an own Workcenter View which has to be assigned to the user separately. For both ways there are valid use cases. To support the first use case it is needed to treat all released workcenter views as stable anchors which means if a workcenter view is ever deleted a follow up workcenter view has to be maintained where the user extension will be taken over.

In one embodiment to achieve stability during upgrade for partner key user end user extensions according the described use cases it is essential to change the way the repository behind the UI handles extensions. This may be achieved by replacing a generic XML based diff merge mechanism by a mechanism of modeled change records that are applied to a UI component by a plug in that deals with this kind of change. Furthermore a tool that creates these changes either UI runtime authoring or UI designer is able to store and access these changes explicitly in the repository. In one embodiment a dispatcher module determines which changes have to be applied to the Base XML in which order and call the right plug in to apply the changes after an upgrade change in a system. Furthermore the repository has to provide a mechanism to handle stable anchors and use these anchors as a reference for change records to make sure that it collects all the change records that have to be applied to a UI component even if stable anchors have moved to a new UI component. These mechanisms cannot always run at runtime therefore a load for a UI component is to be created with all changes applied. It is important to separate the end user personalization aspect completely. The key user adaptations are applied in the backend once a change is applied. The result is stored separately and is used if the client requests the UI at runtime. The end user personalization change records must also be handled by the repository but when the UI runtime requests a UI component it needs to retrieve the company wide load of the UI component plus the list of change records that have to be applied for end user personalization. For the company wide load in the repository the key user personalization and the dynamic adaptation of UI files do not overlap. The end user dynamic adaptation overrides any key user personalization if the changes are applied to the same entity in the same way. For example if the key user defines an entity of the UI to be hidden while the end user defines the same as visible the entity will be present at end user runtime.

At decision block each UI adaptation is saved as a reference field to a specific entity in a repository behind the UI. In one embodiment an extensible markup language XML file is used for saving the UI adaptation.

At decision block the position in the UI of the UI adaptations is saved. In one embodiment the position is saved in an XML file.

Finally at block the UI adaptations are reconstructed by combining the saved UI adaptations and their position in the UI to the default UI. In one embodiment the UI adaptations are reconstructed by merging XML files used for saving the UI adaptations and their position in the UI with an XML file used for generation of the default UI.

The system further includes a file system repository to persist information for UI generation. The memory also includes an extractor module and a UI generator module . The extractor module is intended to store the user s UI adaptations to the file system repository as a secondary source of information for UI generation. In one embodiment the secondary source of information for UI generation is an XML file comprising the user s UI adaptations.

The generator module is in communication with the repository and is intended to generate UIs by combining a default source of information for UI generation and the secondary source of information for UI generation. In one embodiment the default source of information comprises default elements and organization of the UI before the user s UI adaptations. In one embodiment the default source of information for UI generation is an XML file. In yet another embodiment the default source of information is updated periodically by a UI provider.

Some embodiments of the invention may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments of the invention may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. Examples of computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment of the invention may be implemented using Java C or other object oriented programming language and development tools. Another embodiment of the invention may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments of the present invention are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the present invention. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments of the invention including what is described in the Abstract is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of and examples for the invention are described herein for illustrative purposes various equivalent modifications are possible within the scope of the invention as those skilled in the relevant art will recognize. These modifications can be made to the invention in light of the above detailed description. Rather the scope of the invention is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

