---

title: Rendering text in a brew device
abstract: Methods, systems and program products for hiding the presentation of a first input field that would obscure the presentation of a distinct second input field on a display device. User input directed to the second input field is accepted and provided the first input field instead of to the second input field. The contents of the first input field are copied to the second input field. The presentation of the second input field is updated on the display device to include the copied contents.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08443299&OS=08443299&RS=08443299
owner: Adobe Systems Incorporated
number: 08443299
owner_city: San Jose
owner_country: US
publication_date: 20100611
---
This application is a continuation of and therefore claims priority to U.S. patent application Ser. No. 11 670 333 filed on Feb. 1 2007 now U.S. Pat. No. 7 743 339 the contents of which are incorporated by reference in this specification.

The Binary Runtime Environment for Wireless BREW is an application development framework for mobile phones and other devices based on a chip set manufactured by QUALCOMM Incorporated of San Diego Calif. The BREW system provides by way of an Application Programming Interface API a visual text input control for applications to capture and display key presses received from a device keypad. However the text input control typically occupies a large portion of the display obscuring all else and renders text without any style. For rich content applications this brings a reduced user experience since whenever there is a need to input text a full screen sized dialog box will pop up and obscure the rich content.

In general one aspect of the subject matter described in this specification can be embodied in a method that includes hiding the presentation of a first input field that would obscure the presentation of a distinct second input field on a display device. User input directed to the second input field is accepted and provided to the first input field instead of to the second input field. The contents of the first input field is copied to the second input field. The presentation of the second input field is updated on the display device to include the copied contents. Other implementations of this aspect include corresponding systems apparatus and computer program products.

These and other implementations can optionally include one or more of the following features. The first input field is a Binary Runtime Environment for Wireless BREW text input control and the second input field is a BREW text field. A character in a first current position for the first input field is copied to a second current position for the second input field. The copying is performed if the character in the first current position is different from the character in the second current position. A second cursor position for the second input field is automatically updated based on a first cursor position for the first input field. Providing the user input to the first text field includes detecting when the second input field has input focus. The user input is a key press or a gesture on the display device.

Particular implementations of the subject matter described in this specification can be implemented to realize one or more of the following advantages. Users can input text into text fields without the text fields being obscured by a text input control. Users can interact with rich content directly. The BREW text input control is utilized without requiring the control to be displayed. Content of the BREW text input control is automatically copied to a text field that is visible on a display device. The cursor positions of the BREW text input control and a text field are automatically synchronized.

Text input control shown in can be used to convert numeric input retrieved from a numeric keypad into alpha numeric characters and is normally displayed when users attempt to type characters in text field . In some environments such as in a Flash application running in a BREW environment the text input control is displayed in an enlarged size on top of the application text field . In various implementations the text input control can interpret input from a numeric keypad such as a numeric keypad of a cellular phone. The text input control can convert user input for example by converting a numeric digit input e.g. 2 into an alphabetic character e.g. a . Conversion from numeric digits to alphabetic characters can be necessary for devices that do not include a full sized keyboard. For example if the user repeatedly presses a digit key e.g. 2 the text input control can interpret those presses as cycling to other characters represented by the key being pressed e.g. 2 can represent a b c and also the character 2 . In some environments the text input control does not support the ability to show styled text.

Graphical content such as the text field can be presented on the display by being first rendered on a bitmap. In various implementations the text input control is rendered to a hidden back bitmap and the text field is rendered to a visible front bitmap . In a BREW application an IDISPLAY SetDestination BREW API function can be used to control which bitmap is associated with the display . The back bitmap is associated with the display in order to intercept users key press events. The contents of the back bitmap will not be presented on the display however. After the user input has been interpreted by the text input control and copied to the text field the front bitmap can be associated with the display . In a BREW environment an IDISPLAY BitBlt API function can then be used to copy the front bitmap to a frame buffer which will cause the bitmap including text field to be presented e.g. composited on the display .

The text input control and the text field can each have an associated text buffer. A text buffer can be used to store characters. A text buffer is associated with the text input control and a text buffer is associated with the text field . Text buffers can have associated cursors which represent a position within the buffer where new characters can be inserted. For example a cursor is associated with the text buffer and a cursor is associated with the text buffer

The contents of the text buffers and can be synchronized with the use of a timer . The timer can trigger processing at specific intervals for example every 30 milliseconds. At each timer interval the cursor position can be compared to the cursor position . If the cursor positions are different the contents of the text buffer can be copied to the text buffer and the cursor position can be set to be equal to the cursor position

The timer can be also used to recognize when a numeric input should be accepted and interpreted. For example if the user presses the 2 key after a certain interval of time has elapsed with no further input the 2 input can be accepted as an a . However if the user presses the 2 key repeatedly with relatively short periods of time between key presses the input can be interpreted as first an a and then a b after the second press a c after the third press a 2 after the fourth press and an a after the fifth press and so on. An input can also be accepted if subsequently a different key is pressed. For example if a 3 input follows a 2 input the 2 input can be accepted as a immediately after the 3 input. The 3 input can be interpreted initially as a d pending further input from the user.

A timer is initialized e.g. timer and the display destination is set to the back bitmap e.g. bitmap step . The timer is configured so that processing is repeatedly performed after a certain interval of time e.g. 30 milliseconds has elapsed. In a BREW environment the display destination is set to the back bitmap by using an IDISPLAY SetDestination BREW API function. A text input control e.g. is created and associated with the back bitmap and configured to intercept user input.

After the timer has been initialized and the display destination has been set to the back bitmap one of several events can occur. For example the timer interval can elapse step the text field can lose input focus step or a character input can be detected in the text input control step . If the user enters a character while the text field has the input focus the new character is detected by the text input control step . For example the user can press the 2 key with the intention of having the 2 be interpreted as an a . As another example a new input can be a 3 key interpreted as d which has been pressed after a 2 key interpreted as a .

The current character e.g. a in the text field can be replaced with the new character e.g. b step . For example a new input of 2 received shortly after a previous input of 2 can be interpreted as cycling from an a input to a b input. An a character in the text field can be replaced with a b character and the b character can be highlighted. Alternatively the current character in the text field is replaced only if the new character is different than the current character.

After the character has been replaced the display destination is set to the front bitmap e.g. bitmap step . In a BREW environment the destination can be set to the front bitmap by using an IDISPLAY SetDestination API function. The text field e.g. is rendered to the front bitmap e.g. which is then copied to the frame buffer e.g. step . After the contents of the front bitmap are presented on the display the display destination can be set back to the back bitmap so that additional user input events will be intercepted by the text input control.

After a timer e.g. interval has elapsed a timeout can be recognized step . If a cursor position e.g. associated with the text field e.g. is different than a cursor position e.g. associated with the text input control e.g. the text field cursor can be set equal to the text input control cursor step . For example the cursors may be different if the user had previously pressed a key e.g. 2 interpreted as a and then paused without pressing any other keys. In this example the text field cursor can be changed so that it is positioned after the a rather than on the a . The a character which may have been previously highlighted can be displayed without highlighting.

If input focus is transferred to another input control the loss of focus of the text field is detected step . For example the user may have put focus on another control using an arrow key. The text input control e.g. can be destroyed e.g. in a BREW application an ITEXTCTL Release API function can be used the display destination can be set to the front bitmap e.g. and the back bitmap e.g. can be destroyed e.g. in a BREW environment an IBITMAP Release API function can be used .

The memory is a computer readable medium such as volatile or non volatile random access memory that stores information within the system . The memory could store data structures representing a text field and a text input control for example. The storage device is capable of providing persistent storage for the system . The storage device can be a floppy disk device a hard disk device an optical disk device a flash drive or a tape device or other suitable persistent storage means.

The input output devices provide input output operations for the system . In one implementation the input output device includes a keyboard stylus and or pointing device. In another implementation the input output device includes a display unit for displaying graphical user interfaces. The input output device can provide input output operations for the applications running on device . An application program presents a document on a display for example an Adobe Flash document and enables users to input characters into the document by way of text fields. Techniques for presenting documents in the BREW system are provided in U.S. patent application Ser. No. 11 567 111 entitled EMBEDDED DOCUMENT WITHIN AN APPLICATION by Rupen Chanda filed on Dec. 5 2006 which is incorporated herein by reference in its entirety. Adobe Flash is an Integrated Development Environment IDE for developing Flash documents that support for instance rich content user interfaces and web applications. Adobe Flash Lite is a virtual machine used to render Flash documents on computing device displays. Flash and Flash Lite are available from Adobe Systems Incorporated of San Jose Calif. Flash documents are commonly used to create interactive content such as advertisements video and rich client side applications.

Implementations of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry or in computer software firmware or hardware including the structures disclosed in this specification and their structural equivalents or in combinations of one or more of them. Implementations of the subject matter described in this specification can be implemented as one or more computer program products i.e. one or more modules of computer program instructions encoded on a computer readable medium for execution by or to control the operation of data processing apparatus. The computer readable medium can be a machine readable storage device a machine readable storage substrate a memory device a composition of matter effecting a machine readable propagated signal or a combination of one or more of them. The term data processing apparatus encompasses all apparatus devices and machines for processing data including by way of example a programmable processor a computer or multiple processors or computers. The apparatus can include in addition to hardware code that creates an execution environment for the computer program in question e.g. code that constitutes processor firmware a protocol stack a database management system an operating system or a combination of one or more of them. A propagated signal is an artificially generated signal e.g. a machine generated electrical optical or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus.

A computer program also known as a program software software application script or code can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data e.g. one or more scripts stored in a markup language document in a single file dedicated to the program in question or in multiple coordinated files e.g. files that store one or more modules sub programs or portions of code . A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.

The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by and apparatus can also be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for performing instructions and one or more memory devices for storing instructions and data. Generally a computer will also include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. However a computer need not have such devices. Moreover a computer can be embedded in another device e.g. a mobile telephone a personal digital assistant PDA a mobile audio player a Global Positioning System GPS receiver to name just a few. Computer readable media suitable for storing computer program instructions and data include all forms of non volatile memory media and memory devices including by way of example semiconductor memory devices e.g. EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory can be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user implementations of the subject matter described in this specification can be implemented on a computer having a display device e.g. a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input.

Implementations of the subject matter described in this specification can be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described is this specification or any combination of one or more such back end middleware or front end components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN and a wide area network WAN e.g. the Internet.

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

While this specification contains many specifics these should not be construed as limitations on the scope of the invention or of what may be claimed but rather as descriptions of features specific to particular implementations of the invention. Certain features that are described in this specification in the context of separate implementations can also be implemented in combination in a single implementation. Conversely various features that are described in the context of a single implementation can also be implemented in multiple implementations separately or in any suitable subcombination. Moreover although features may be described above as acting in certain combinations and even initially claimed as such one or more features from a claimed combination can in some cases be excised from the combination and the claimed combination may be directed to a subcombination or variation of a subcombination.

Similarly while operations are depicted in the drawings in a particular order this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order or that all illustrated operations be performed to achieve desirable results. In certain circumstances multitasking and parallel processing may be advantageous. Moreover the separation of various system components in the implementations described above should not be understood as requiring such separation in all implementations and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.

Thus particular implementations of the invention have been described. Other implementations are within the scope of the following claims. For example the actions recited in the claims can be performed in a different order and still achieve desirable results.

