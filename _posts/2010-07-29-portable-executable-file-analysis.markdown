---

title: Portable executable file analysis
abstract: A portable executable file is analyzed by parsing a binary image of the portable executable file to generate a parsed field. An attribute of the parsed field is determined. The attribute of the parsed field is compared to a valid characteristic of a valid corresponding field based upon, at least in part, a portable executable file format specification. It is determined if the attribute of the parsed field matches the valid characteristic of the valid corresponding field.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09389947&OS=09389947&RS=09389947
owner: Reversinglabs Corporation
number: 09389947
owner_city: Cambridge
owner_country: US
publication_date: 20100729
---
This application claims the benefit of U.S. provisional patent application Ser. No. 61 229 497 filed on 29 Jul. 2009 the entire disclosure of which is incorporated herein by reference.

This application generally relates reverse engineering software and more particularly relates to unpacking software and validity analysis of software files.

Portable executable file format PE file format as defined by Microsoft Corporation in the Microsoft Portable Executable and Common Object File Format Specification is a file format for executables object code and DLL s dynamic link libraries . PE files are used in 32 bit and 64 bit versions of the Microsoft Windows operating systems. The PE file format is a highly versatile format that can be used in numerous operating system environments and supports various processor solutions.

Software developers may use various schemes to protect software including PE files. For example software packers may be utilized to compress binaries which may decrease bandwidth usage associated with transferring the binaries and storage volume. Similarly packers may be utilized to protect intellectual property embodied within the software and to prevent code theft. Packing may involve various schemes of compression and or encryption that may obfuscate the contents of the executable code. Running the packed executable file may unpack the original executable code e.g. which may include decompressing and or decrypting and then transferring control to the original executable code. As such the nature of the executable code may not be known until the software is actually executing. This can be problematic for example if the executable code is malware or other undesirable software as the nature of the software may not be known until it is too late.

According to a first implementation a computer implemented method includes parsing by a computing device a binary image of a portable executable file to generate a parsed field and determining by the computing device an attribute of the parsed field. The method also includes comparing by the computing device the attribute of the parsed field to a valid characteristic of a valid corresponding field based upon at least in part a portable executable file format specification. The method further includes determining by the computing device if the attribute of the parsed field matches the valid characteristic of the valid corresponding field.

One or more of the following features may also be included. The parsed field may include one or more of a portable executable format signature an ImageBase field a SizeOfImage field a FileAlignment field a SectionAlignment field an EntryPoint address an import table an import address table an export table a relocation table a resource table a thread local storage table a load configuration table a bound import table a COM table and a portable executable section table. The attribute of the parsed field may include one or more of a field identifier a field length and a field content.

Determining if the attribute of the parsed field matches the valid characteristic of the valid corresponding field may include determining by the computing device if the attribute of the parsed field is valid for a predetermined operating system. It may be determined if the parsed field does not match the valid characteristic of the valid corresponding field. If the parsed field does not match the valid characteristic of the valid corresponding field a likelihood of modifying the parsed field that does not match the valid characteristic of the valid corresponding field to generate a valid field may be determined.

The method may also include determining by the computing device if the binary image of the portable executable file includes a dynamic link library a kernel driver or an executable object.

According to another implementation a computer program product includes a computer readable medium having a plurality of instructions stored on it. When executed by a processor the instructions cause the processor to perform operations including parsing a binary image of a portable executable file to generate a parsed field and determining an attribute of the parsed field. The attribute of the parsed field is compared to a valid characteristic of a valid corresponding field based upon at least in part a portable executable file format specification. It is determined if the attribute of the parsed field matches the valid characteristic of the valid corresponding field.

One or more of the following features may be included. The parsed field may include one or more of a portable executable format signature an ImageBase field a SizeOfImage field a FileAlignment field a SectionAlignment field an EntryPoint address an import table an import address table an export table a relocation table a resource table a thread local storage table a load configuration table a bound import table a COM table and a portable executable section table. The attribute of the parsed field may include one or more of a field identifier a field length and a field content.

Determining if the attribute of the parsed field matches the valid characteristic of the valid corresponding field may include determining if the attribute of the parsed field is valid for a predetermined operating system. It may be identified if the parsed field does not match the valid characteristic of the valid corresponding field.

A likelihood of modifying the parsed field that does not match the valid characteristic of the valid corresponding field to generate a valid field may be determined. Further it may be determined if the binary image of the portable executable file includes a dynamic link library a kernel driver or an executable object.

According to yet another implementation a system includes a processor and a memory coupled with the processor. A first software module is executable by the processor and the memory. The first software module is configured to parse a binary image of a portable executable file to generate a parsed field. A second software module is executable the by processor and the memory. The second software module is configured to determine an attribute of the parsed field. A third software module is executable by the processor and the memory. The third software module is configured to compare the attribute of the parsed field to a valid characteristic of a valid corresponding field based upon at least in part a portable executable file format specification. A fourth software module is executable by the processor and the memory. The fourth software module is configured to determine if the attribute of the parsed field matches the valid characteristic of the valid corresponding field.

One or more of the following features may be included. The parsed field may include one or more of a portable executable format signature an ImageBase field a SizeOfImage field a FileAlignment field a SectionAlignment field an EntryPoint address an import table an import address table an export table a relocation table a resource table a thread local storage table a load configuration table a bound import table a COM table and a portable executable section table. The attribute of the parsed field may include one or more of a field identifier a field length and a field content.

The fourth software module which is configured to determine if the attribute of the parsed field matches the valid characteristic of the valid corresponding field may further be configured to determine if the attribute of the parsed field is valid for a predetermined operating system. A fifth software module may be executable by the processor and the memory. The fifth software module may be configured to identify if the parsed field does not match the valid characteristic of the valid corresponding field.

A sixth software module may be executable by the processor and the memory. The sixth software module may be configured to determine a likelihood of modifying the parsed field that does not match the valid characteristic of the valid corresponding field to generate a valid field. A seventh software module may be executable by the processor and the memory. The seventh software module may be configured to determine if the binary image of the portable executable file includes a dynamic link library a kernel driver or an executable object.

The details of one or more implementations are set forth in the accompanying drawings and the description below. Other features and advantages will become apparent from the description the drawings and the claims.

As will be appreciated by one skilled in the art the present invention may be embodied as a system method or computer program product. Accordingly the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore the present invention may take the form of a computer program product embodied in one or more computer readable i.e. computer usable medium s having computer usable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium include a computer readable storage medium which may be for example but is not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus a device or any suitable combination of the foregoing. Exemplary computer readable storage medium may include but is not limited to a portable computer diskette a hard disk a solid state disc drive a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

Computer program code for carrying out operations of the present invention may be written in an object oriented programming language such as Java Smalltalk C or the like. However the computer program code for carrying out operations of the present invention may also be written in conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on a single computing device e.g. as a stand alone software package and or may be at least partly executed on multiple computing devices that may be remote to one another. In the latter scenario remote computing devices may be connected to one another through a local area network LAN or a wide area network WAN or the connection may be made to one or more remote computing devices for example through the Internet using an Internet Service Provider .

The present invention is described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable memory that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable memory produce an article of manufacture including instruction means which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide steps for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

Referring to there is shown validity check process repair process and automated unpacking process that may each reside on and may be executed by computing device . While each of validity check process repair process and automated unpacking process are shown residing on computing device this is intended for illustrative purposes only as one or more of validity check process repair process and automated unpacking process may reside on a separate computing device.

Examples of computing device may include but are not limited to a personal computer a server computer a series of server computers a mini computer and a mainframe computer. Computing device may run an operating system for example Microsoft Windows XP or Red Hat Linux for example. Various additional alternative computing devices and operating systems may equally be utilized. For example computing device may be part of a distributed computing network with one or more of validity check process repair process and automated unpacking process being executed in whole or in part on another computing device coupled with computing device via a data network e.g. a LAN a WAN the Internet etc. .

As will be discussed below in greater detail validity check process may parse a binary image of a portable executable file to generate a parsed field. Validity check process may also determine an attribute of the parsed field. Further validity check process may compare the attribute of the parsed field to a valid characteristic of a valid corresponding field based upon at least in part a portable executable file format specification. Validity check process may also determine if the attribute of the parsed field matches the valid characteristic of the valid corresponding field.

Further and as will also be discussed below in greater detail repair process may identify an invalid field of a portable executable file. Repair process may also determine a likelihood of repairing the invalid field of the portable executable file. Repair process may generate a repair model for repairing the invalid field of the portable executable file. Repair process may repair the invalid field of the portable executable file is repaired based upon at least in part the repair model.

Similarly and as will also be discussed below in greater detail automated unpacking process may set a debugging breakpoint at an original entry point address of a packed portable executable file. Automated unpacking process may also execute a debugging process for the packed portable executable file to obtain a debugged portable executable file in memory. Automated unpacking process may also collect one or more of import address table data and relocation table data during execution of the debugging process for the packed portable executable file. Automated unpacking process may copy the debugged portable executable file in memory to a storage medium and may terminate the debugging process.

The instruction sets and subroutines of validity check process repair process and automated unpacking process which may include one or more software modules and which may be stored on storage device coupled to computing device may be executed by one or more processors not shown and one or more memory modules not shown incorporated into computing device . Storage device may include but is not limited to a hard disk drive a solid state drive a tape drive an optical drive a RAID array a random access memory RAM and a read only memory ROM .

Due to the fact that PE portable executable files contain executable code it may be desirable to perform file validation prior to execution of the binary object e.g. the binary image of the PE file . Validity check process may analyze a PE binary image prior to execution to determine if the PE file is a valid binary image. A valid binary image may refer to a file that can be used by a given operating system either as an image that contains executable code or other type of multimedia information.

As discussed above and referring also to validity check process may parse a binary image of a portable executable file e.g. PE binary image residing on storage device shown in to generate a parsed field. Validity check process may also determine an attribute of the parsed field. Further validity check process may compare the attribute of the parsed field to a valid characteristic of a valid corresponding field based upon at least in part a portable executable file format specification. Validity check process may determine if the attribute of the parsed field matches the valid characteristic of the valid corresponding field.

Validity check process may parse PE binary image to generate a parsed field. Validity check process may parse PE binary image to generate a plurality of fields consistent with PE file format . For example validity check process may generally parse PE binary image into a portable executable format signature an ImageBase field a SizeOfImage field a FileAlignment field a SectionAlignment field an EntryPoint address an import table an import address table an export table a relocation table a resource table a thread local storage table a load configuration table a bound import table a COM table and a portable executable section table.

While several fields have been indicated these are intended only for illustrative purposes only as validity check process may parse PE binary image into various additional alternative fields selected based upon design criteria and user need. Additionally parsing PE binary image to generate one or more parsed fields may include but is not limited to physically isolating each field e.g. copying each field into a separate file database field or the like individually reading each field associating an offset with the beginning and or ending of each field or the like. As such parsing PE binary image to generate one or more parsed fields may allow individual examination of each field.

As discussed above validity check process may also determine an attribute of the parsed field. The attribute determined by validity check process may include one or more of a field identifier a field length and a field content. For example validity check process may determine that PE binary image includes an ImageBase field having a value of 0x00400000 a SectionAlignment field having a value of 0x1000 and a FileAlignment field having a value of 0x200.

Validity check process may compare the one or more determined attributes of the parsed field to a valid characteristic of a valid corresponding field based upon at least in part a portable executable file format specification. A valid corresponding field may include a field that is required or allowed by the Microsoft Portable Executable and Common Object File Format Specification published by Microsoft Corporation PECOFF and which corresponds to a parsed field. For example a valid corresponding field for the parsed ImageBase field may be the ImageBase field allowed as an option Windows specific field by PECOFF. A valid characteristic of a valid corresponding field may include a characteristic that is allowable by PECOFF. For example PECOFF may specify acceptable field identifiers field lengths and field contents of an accepted PE binary image. For example PECOFF may define a default ImageBase value of 0x00400000 and may require that the value be a multiple of 64 K. Similarly PECOFF may specify that the SectionAlignment field have a value that is greater than or equal to the FileAlignment. Further PECOFF may specify that the FileAlignment have a value that is a power of 2 between 512 and 64 K with a default value of 512. Accordingly the foregoing may be example of valid characteristics for the identified fields.

Validity check process may determine if the attribute of the parsed field matches the valid characteristic of the valid corresponding field based upon at least in part the comparison between the attribute of the parsed field and a valid characteristic of a valid corresponding field. Continuing with the above stated example the determined attribute for the FileAlignment field of PE binary image was 512. As also discussed above PECOFF may specify that the FileAlignment field have a value that is a power of 2 between 512 and 64 K. Accordingly validity check process may determine that the attribute of parsed FileAlignment field e.g. having a value of 512 matches a valid characteristic of a valid FileAlignment field.

Determining if the attribute of the parsed field matches the valid characteristic of the valid corresponding field may include determining if the attribute of the parsed field is valid for a predetermined operating system. Again continuing with the above stated example validity check process may have determined a ImageBase field value of 0x00400000 for PE binary image . This determined value may be the default value for the operating systems Windows NT Windows 2000 Windows XP Windows 95 Windows 98 and Windows Me. However the ImageBase field default value for Windows CE is 0x00010000 per PECOFF. Accordingly validity check process may determine that the parsed ImageBase field for PE binary image is not valid for Windows CE.

Validity check process may determine if the parsed field does not match the valid characteristic of the valid corresponding field. Continuing with the above stated example PECOFF specifies that the SectionAlignment field have a value that is greater than or equal to the FileAlignment. Further validity check process may have determined a SectionAlignment field attribute of 256 and a FileAlignment field attribute of 512 for PE binary image . Accordingly as the determined SectionAlignment field attribute i.e. 256 is not greater than or equal to the determined FileAlignment field attribute i.e. 512 for PE binary image validity check process may determine that the parsed SectionAlignment field does not match a valid characteristic of a valid corresponding field i.e. the determined SectionAlignment field attribute is not greater than or equal to the determined FileAlignment field attribute . Accordingly validity check process may provide an indicator e.g. may provide an indicator in a graphical user interface not shown .

If the parsed field does not match the valid characteristic of the valid corresponding field validity check process may determine a likelihood of modifying the parsed field that does not match the valid characteristic of the valid corresponding field to generate a valid field. Validity check process may determine the likelihood of modifying the parsed field to generate a valid field based upon at least in part the number and nature of errors in a field that does not match the valid characteristic of a valid corresponding field. For example and continuing with the above discussed example the parsed SectionAlignment field of PE binary image does not match a valid characteristic of a valid SectionAlignment field because the value is less than the value of the FileAlignment field. Validity check process may determine a relatively strong likelihood of being able to modify the SectionAlignment filed of PE binary image to generate a valid characteristic as the parsed SectionAlignment field of PE binary image includes a single well defined error namely the value is less than the FileAlignment field . It may for example be possible to modify the SectionAlignment field to include a value that is greater than or equal to the FileAlignment field. Although some recursive testing may be necessary to modify the SectionAlignment field of PE binary image to achieve a valid field it may be reasonably likely that such a modification may be achieved.

The likelihood of modifying a field to generate a valid field may be determined based upon at least in part one or more empirically determined rules. The one or more empirically determined rules may be based upon at least in part various possible types of errors that may occur in various fields and the possible modifications that may be implemented to correct the errors. As such an error type in a given field for which there may be relatively few possible modifications that may generally result in a valid field validity check process may determine a relatively high likelihood of modifying the field to generate a valid field. Conversely for an error type having many possible modifications many of which may not result in a valid field validity check process may determine a relatively low likelihood of modifying the field to generate a valid field. Similarly if the number of detected errors between the parsed field and a valid corresponding field are relatively large validity check process also determine a relatively low likelihood of modifying the field to generate a valid field.

Validity check process may also determine if the binary image of the portable executable file includes a dynamic link library a kernel driver or an executable object. Validity check process may determine the nature of PE binary image based upon for example one or more of the included fields the content of the included fields or the like by evaluating the parsed fields relative to possible valid characteristics and possible valid fields. Various additional alternative characteristics of PE binary image may similarly be determined. For example validity check process may determine one or more of an environment in which the PE file may execute if the PE file is a console or other application with a graphical user interface if the PE file includes dependencies and whether the dependencies exist on the target system if the PE file includes depend functions and whether the dependent function exist in libraries available on the target system etc.

As briefly mentioned above validity check process may provide an output indicating the various parsed fields field attributes validity of the fields nature of the PE file etc. In an embodiment validity check process may provide a graphical user interface through which the various outputs may be rendered. Additionally alternatively validity check process may provide an output to a database file etc. which may be consumed by a user via an appropriate program such as a database application. Various other suitable outputs will be appreciated by those having skill in the art.

PE binary images may be come damaged through various mechanisms. For example PE files may become damaged when the files are transferred from one media to another. Similarly errors may be introduced by software packers e.g. UPX PECompact ASPack etc. . Error introduced by software packers may render some files valid only for certain versions of operating systems that support PE file formats. Accordingly repair process may be implemented to repair damaged PE files.

With reference also to repair process may identify an invalid field of a portable executable file e.g. PE binary image shown in . Further repair process may determine a likelihood of repairing the invalid field of the portable executable file. Repair process may generate a repair model for repairing the invalid field of the portable executable file. Repair process may repair the invalid field of the portable executable file based upon at least in part the repair model generated by repair process .

Repair process may identify an invalid field of PE binary image utilizing a variety of mechanisms. For example repair process may receive an indicator from validity check process described in detail above indicating the validity of PE binary image and or subset parts of PE binary image i.e. the validity of the various fields of PE binary image . Repair process may receive the indicator directly from validity check process . Additionally alternatively in an embodiment in which validity check process may generate a validity report e.g. in the form a file database entries or the like repair process may identify an invalid field and or a plurality of invalid fields by accessing the validity report and interpreting the contents thereof.

In further embodiments repair process may identify an invalid field of PE binary image by performing one or more validity checks on PE binary image . For example repair process may perform one or more validity checks on PE binary image in a manner similar to that discussed above with reference to validity check process . For example repair process may generally parse PE binary image into a plurality of fields and may compare attributes of the plurality of fields to valid characteristics of valid corresponding fields. As discussed above valid characteristics of valid corresponding fields may be specified by PECOFF. Accordingly the validity of a field and or of PE binary image as a whole may be determined based upon at least in part whether the various fields and attributes comply with PECOFF. Therefore repair process may identify an invalid field as a field having an attribute that does not comply with a valid characteristic of a valid corresponding fields as specified by PECOFF.

When identifying an invalid field repair process may examine all fields of PE binary image and or may give special attention to the most crucial fields of PE binary image . Examples of fields that may be particularly important e.g. which may have the greatest impact on the executability of PE binary image may include but are not limited to PE format signatures PE specific fields e.g. ImageBase SizeOfImage FileAlignment SectionAlignment and EntryPoint address and PE specific tables e.g. Import table Import address table Export table Relocation table Resource table Thread local storage table Load configuration table Bound import table COM table and PE section tables .

As discussed above repair process may determine a likelihood of repairing the invalid field or multiple invalid fields of PE binary image . Repair process may determine a likelihood or repairing the invalid field of PE binary image based upon at least in part determining the number and characteristics of attributes of the invalid field that do not match a valid characteristic of a valid corresponding field based upon at least in part a portable executable file format specification e.g. PECOFF . For example it will be appreciated that various errors may have a higher likelihood of being repairable than other errors. Similarly a PE file having relatively few errors may have a higher likelihood of being repairable than a PE file having a relatively large number of errors.

Repair process may determine the likelihood of repairing an invalid field including comparing the identified invalid field s including the attributes of the invalid fields that fail to comply with PECOFF against a library of possible errors and likelihood of repairing the error. The library e.g. library residing on storage device may include empirically derived data of various errors that have previously been encountered and whether it was possible to repair the error to obtain an executable file.

As mentioned above repair process may generate a repair model for repairing the identified invalid field s . The repair model generated by repair process may include one or more algorithms for repairing the one or more identified invalid field. Similar to determining a likelihood of repairing the invalid field repair process may generate the repair model based upon at least in part one or more empirically derived rules e.g. which may be included in library . For example repair process may generate a repair model for repairing an invalid SizeOfImage field having an abnormal value in which the rule may include recalculation of a correct SizeOfImage value. Similarly repair process may generate a repair model for repairing an invalid entry point section that does not include an executable attribute in which the rule may include correcting the section attributes. In a further example repair process may generate a repair model for repairing an invalid resource table data that cannot be physically located in which the rule may include temporarily removing the invalid resource table values in the PE header. Additionally library may include rules that are empirically derived based upon a comparison between different operating system versions and the way the different operating system versions process the PE file format.

Repair process may repair the invalid field of the portable executable file based upon at least in part the repair model generated by repair process . Some errors i.e. invalid fields may be repaired on disk by modifying PE binary image residing on storage device . Accordingly repair process may repair the invalid field may by statically repairing the invalid field. Statically repairing the invalid field may include modifying the image of the portable executable file e.g. PE binary image on storage device . Repair process may store the modified PE image on storage device .

For example and continuing with the above example in which the PE field SizeOfImage was identified as being invalid for having an abnormal value repair process may statically repair the SizeOfImage field of PE binary image . For example repair process may recalculate a correct SizeOfImage value. Repair process may modify PE binary image to include the correct SizeOfImage value. Repair process may store modified PE binary image on storage device .

In addition to errors that may be repaired on disk other errors may be repaired in memory. The determination as to what errors may be repaired on disk on what errors may be repaired in memory may be based upon at least in part the empirically derived rules e.g. which may reside in library . For errors that may be repaired in memory repair process may dynamically repair the invalid field. To dynamically repair an invalid field repair process may execute the portable executable file e.g. PE binary image . Repair process may further modify the portable executable file residing in memory e.g. in RAM during execution in which the portable executable file residing in memory during execution is based upon the portable executable file e.g. based upon PE binary image .

Further repair process may repair the invalid field by disabling the invalid field. For example repair process may temporarily disable an invalid field by removing the invalid field from an image of the portable executable file e.g. PE binary image stored on storage device prior to execution of the portable executable file.

In some embodiments repair process may repair an invalid field by disabling the invalid field and dynamically repairing the invalid field. For example and referring to the above example in which resource table data could not be physically located repair process may temporarily remove the invalid resource table values in the PE header. Repair process may then execute PE binary image e.g. repair process may execute an unpacker of PE binary image up to the original entry point of the portable executable file. The original entry point may include the first instruction of code of the portable executable file before the portable executable file was protected e.g. packed . Once execution of PE binary image reaches the original entry point the process memory may be dumped to storage device . That is the process memory associated with the execution of PE binary image residing in RAM may be saved to storage device . The resource table data acquired from memory during unpacking of PE binary image may be reverted to an original state and a new PE file based upon at least in part the dumped process memory may be stored. Accordingly a valid PE file i.e. a PE file in compliance with PECOFF may be achieved.

In an embodiment a PE binary image may include a packed portable executable file. A packed portable executable file may include portable executable file consistent with PECOFF discussed herein above that may include one or more software protections such as compression encryption combinations of compression and encryption etc. Automated unpacking process may generally execute a debugging process for the packed portable executable file and may utilize various breakpoints and callbacks to collect import address table filling data as well as various other data that may be used to build an unprotected valid portable executable file based upon packed e.g. protected PE binary image .

Referring also to in general automated unpacking process may set a debugging breakpoint at an original entry point address of a packed portable executable file e.g. packed PE binary image shown in . Automated unpacking process may also execute a debugging process for the packed portable executable file to obtain a debugged portable executable file in memory e.g. in RAM . Automated unpacking process may collect one or more of import address table data and relocation table data during the execution of the debugging process for the packed portable executable file. Automated unpacking process may copy the debugged portable executable file stored in memory to a storage medium e.g. storage device . Automated unpacking process may terminate the debugging process at the original entry point of the portable executable file.

As discussed automated unpacking process may set a debugging breakpoint at an original entry point address of packed PE binary image . The original entry point of packed PE binary image may be the first instruction of the executable code before the file was protected. Setting a debugging breakpoint at the original entry point address of packed PE binary image may allow the execution of packed PE binary image to be suspended prior to control being passed to the executable file embodied within packed PE binary image . As used herein execution of packed PE binary image and executing packed PE binary image may refer to the execution of the file embodied by the packed PE binary image and the executing PE file embodied by the packed PE binary image. Automated unpacking process may determine the ImageBase field data of the packed portable executable file and AddressOfEntryPoint data of the packed portable executable file. The ImageBase field data and the AddressOfEntryPoint data may be loaded from packed PE binary image . The original entry point address of packed PE binary image may be the sum of the ImageBase data and the AddressOfEntryPoint data. Determining the original entry point may additionally include other numeric calculations which may be based upon at least in part the software packer layout itself. Automated unpacking process may load various additional data from packed PE binary image such as but not limited to ImageBase data SizeOfImage data and PE section data.

Automated unpacking process may initialize the debugging process. Initializing the debugging process may include creating a debugging process based upon at least in part packed PE binary image . That is initializing the debugging process may establish a debugging environment in which packed PE binary image may be executed. In the initialized debugging process automated unpacking process may set a debugging breakpoint on the original entry point. The debugging breakpoint set on the original entry point will be called once the debugged process finishes loading before execution of the first instruction of the executable file embodied within packed PE binary image .

Automated unpacking process may execute the initialized debugging process. That is packed PE binary image may be executed within the established debugging environment. Automated unpacking process may collect one or more of import address table data and relocation table data. Collecting one or more of import address table data and relocation table data may include running the debugging process until it reaches the import address table filling code. In part automated unpacking process may collect one or more of import address table data and relocation table data by setting one or more debugging breakpoints associated with a LoadLibrary call a GetModuleHandle call and a GetProcAddress call. Additional breakpoints may also be associated with a part of the software packer that relocates the file in memory. Breakpoints associated with a LoadLibrary call a GetModuleHandle call and a GetProcAddress call may be set in some embodiments during initialization of the debugging process.

Packed PE binary image executing within the debugging process may utilize a LoadLibrary API call or a GetModuleHandle API call in order to load a dependent dynamic link library. Setting one or more breakpoints associated with a LoadLibrary call or a GetModuleHandle call may result in a callback to automated unpacking process when executing packed PE binary image loads a dynamic link library. In response to the breakpoint callback associated with a LoadLibrary call or a GetModuleHandle call automated unpacking process may collect the name of the dynamic link library being loaded by executing packed PE binary image .

Similarly packed PE binary image executing within the debugging process may utilize a GetProcAddress API call to find the locations of necessary API s application programming interfaces . Setting one or more breakpoints associated with a GetProcAddress API call may result in a callback to automated unpacking process when executing packed PE binary image loads the addresses of necessary API s. In response to the breakpoint callback associated with a GetProcAddress API call automated unpacking process may collect the API addresses being located by executing packed PE binary image . Executing packed PE binary image may call GetProcAddress API at two locations e.g. for string API locating and ordinal API locating. Automated unpacking process may set a breakpoint associated with each GetProcAddress API call. Automated unpacking process may add the locations of API s located by the GetProcAddress API calls to the last collected dynamic link library.

Automated unpacking process may copy a debugged PE file from memory e.g. RAM to a computer readable medium such as storage device . Once packed PE binary image executing within the debugging environment reaches the original entry point of the executable file embodied therein unpacking of the file may be substantially complete. That is the file may be decompressed and or decrypted or the like depending upon the nature of the protections associated with packed PE binary image . As such at this point an unpacked PE file may reside in memory associated with computing device e.g. PE in memory shown in . Automated unpacking process may copy unpacked PE in memory e.g. to a file residing on storage medium . As such automated unpacking process may create stored PE which may be at least a portion of an unpacked portable executable file based upon at least in part packed PE binary image .

Automated unpacking process may paste one or more of an import address table based upon at least in part the collected import address table data and a relocation table based upon at least in part the collected relocation table data into the debugged portable executable file e.g. stored PE . For example automated unpacking process may construct one or more of an import address table and a relocation table based upon at least in part the import address table data and the relocation table data collected by automated unpacking process during execution of the debugging process e.g. which may include executing packed PE binary image within a debugging environment .

Pasting one or more of an import address table based upon at least in part collected import address table data and a relocation table based upon at least in part collected relocation table data into the debugged portable executable file e.g. stored PE may include adding a new section to the debugged portable executable file. For example stored PE may not include a section for an import address table and or a section for a relocation table. Accordingly automated unpacking process may make space for an import address table and or a relocation table within stored PE e.g. by adding an appropriate section within stored PE for an import address table and or a relocation table . Automated unpacking process may then paste the import address table and or the relocation table into the appropriate locations of stored PE .

Once the import address table and or the relocation table have been pasted into stored PE automated unpacking process may realign the debugged PE file e.g. stored PE . Generally realigning the debugged PE file may include compacting the file and verifying that the file is a valid image e.g. which may include verifying that the physical sizes of the individual PE sections of the file are correct and as small as possible. Additionally automated unpacking process may make all section attributes of the debugged PE file e.g. stored PE read write and execute. As such automated unpacking process may create a valid PE file that may substantially resemble packed PE binary image prior to packing i.e. prior to modifying the file with software protections and or compression .

With the unpacking process complete automated unpacking process may terminate debugging of packed PE binary image at the original entry point.

While various discrete processes have been discussed herein above such separate discussion is intended for ease of explanation. The various discrete processes and or portions thereof may include modules of a larger application that may interoperate with one another. Additionally the various features and steps of the processes may be utilized in combination with features and steps of other processes described herein. Accordingly the present disclosure should not be construed as being limited to the discrete processes as described above.

A number of implementations have been described. Nevertheless it will be understood that various modifications may be made. Accordingly other implementations are within the scope of the following claims.

