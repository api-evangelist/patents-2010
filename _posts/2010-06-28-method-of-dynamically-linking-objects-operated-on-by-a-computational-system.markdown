---

title: Method of dynamically linking objects operated on by a computational system
abstract: In a method for presenting to a user information operated on by a computational software application, a relationship between states of a user interface mechanism located on a workspace associated with the computational software application and an underlying object operated on by the computational software application may be determined. The relationship may be defined at least in part by configuration data capable of being interpreted by the computational software application. A change in a value of the underlying object may be detected, and a current state of the user interface mechanism may be changed based on the detected change in the value of the underlying object and according to the relationship. Additionally, a change in the current state of the user interface mechanism caused by a user may be detected, and the current value of the underlying object may be changed based on the detected change in the current state of the user interface mechanism and according to the relationship.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08413116&OS=08413116&RS=08413116
owner: Wolfram Research, Inc.
number: 08413116
owner_city: Champaign
owner_country: US
publication_date: 20100628
---
This application is a continuation of and claims priority to U.S. patent application Ser. No. 11 234 550 entitled Method of Dynamically Linking Objects Operated On By Computational System filed on Sep. 23 2005 which is hereby incorporated by reference herein in its entirety for all purposes.

This disclosure generally relates to computational software applications and more particularly to techniques for dynamically linking abstract symbolic objects operated on by computational software applications.

This disclosure will refer to a particular implementation of these techniques in the MATHEMATICA software system available from Wolfram Research Inc. The methods themselves are more general and could be implemented in a variety of software environments. To understand the illustrations however requires some familiarity with the MATHEMATICA environment.

MATHEMATICA is a powerful computational tool that can evaluate general symbolic expressions as well as mathematical and numeric expressions. A unifying feature of MATHEMATICA is that everything is internally represented as a symbolic expression with all more specific data types treated as special cases symbols to which additional rules apply. MATHEMATICA is an interpreted language with a notion of evaluation of symbolic expressions. Evaluation consists in applying to any symbolic expression all transformation rules that fit that expression.

In the MATHEMATICA software system a user can create interactive electronic documents referred to as notebooks. Various expressions including numeric and symbolic expressions can be entered into a notebook via a keyboard for example and a user can cause the expression to be evaluated. As a simple example a user could set a variable x to the numeric value 5 by typing x 5 into the notebook and then pressing Enter while holding down the Shift key. This is shorthand for the expression Set x 5 calling the built in function Set .

In response the MATHEMATICA software system conceptually sets the abstract variable x to the value 5. The symbolic expression x can when evaluated be replaced by the symbol 5. This is one technique by which an interpreted symbolic language may implement variables and variable assignments.

Next the user could type in an expression xby typing x 2 into the notebook. To evaluate this expression the user could then press Enter while holding down the Shift key. In response the MATHEMATICA software system evaluates xbased on the current value of x set by the user to 5 and would then display 25 in the notebook. To have the notebook display the value of xfor a different value of x the user could first type into the notebook the new value of x. For example the user could type x 7 into the notebook and then pressing Shift and Enter . In response the MATHEMATICA software system resets the variable x to the value 7. Next the user could retype x 2 into the notebook and then press Shift and Enter . Alternatively instead of retyping x 2 into the notebook the user could place a cursor on or next to the previously entered expression x 2 and then press Shift and Enter . In response the MATHEMATICA software system evaluates xbased on the new value of x set by the user to 7 and would then display 49 in the notebook.

If no value has been assigned to a symbol evaluation will return the symbol itself unchanged. Thus if a user types x 2 holds shift and enter without any previous Set operation the MATHEMATICA software system will return x. The system knows various rules to apply to compound symbolic expressions through functions like Expand or Simplify for example whether their component sub expressions have Set values or not.

Spreadsheet software applications such as the EXCEL software application available from Microsoft Corporation permit a user to create spreadsheets comprising grids of cells. In a spreadsheet a value in one cell may be dependent upon a value in one or more other cells. For example a user may assign a formula to a first cell that uses a value from a second cell. Then the spreadsheet application will calculate an output of the formula using the value from the second cell and will display the calculated value in the first cell. When a user changes the value of the first cell the spreadsheet application will recalculate the value of the formula of the second cell. Such applications require inputs to the first cell in a numeric form need an explicit formula taking numeric input to relate the contents of the second cell to the numeric values in the first and output numeric output to the second cell.

One of the disclosed embodiments is directed to a method for presenting to a user information operated on by a computational software application. The method may comprise determining a relationship between states of a user interface mechanism located on a workspace associated with the computational software application and an underlying object operated on by the computational software application. The relationship may be defined at least in part by configuration data capable of being interpreted by the computational software application. The method may also comprise detecting a change in a value of the underlying object and changing a current state of the user interface mechanism based on the detected change in the value of the underlying object and according to the relationship. Additionally the method may comprise detecting a change in the current state of the user interface mechanism caused by a user and changing the current value of the underlying object based on the detected change in the current state of the user interface mechanism and according to the relationship.

Another of the disclosed embodiments is directed to a computer readable medium having stored thereon machine executable instructions. The machine executable instructions may be capable of causing the machine to determine a relationship between states of a user interface mechanism located on a workspace associated with the computational software application and an underlying object operated on by the computational software application the relationship defined at least in part by configuration data capable of being interpreted by the computational software application. Additionally the machine executable instructions may be capable of causing the machine to detect a change in a value of the underlying object and change a current state of the user interface mechanism based on the detected change in the value of the underlying object and according to the relationship. Further the machine executable instructions may be capable of causing the machine to detect a change in the current state of the user interface mechanism caused by a user and change the current value of the underlying object based on the detected change in the current state of the user interface mechanism and according to the relationship.

Yet another of the disclosed embodiments is directed to a method for presenting to a user information operated on by a computational software application. The method may include identifying a dynamic object in a file operated on by the computational software application a value of the dynamic object being dependent upon at least one underlying object. The method may also include determining if the value of the dynamic object is to be rendered and determining if a value of the underlying object has changed. Additionally the method may include recalculating the value of the dynamic object based on if the dynamic object is to be rendered and if the value of the underlying object has changed and causing an indication of the value of the dynamic object to be rendered to the user.

Still another of the disclosed embodiments is directed to a computer readable medium having stored thereon machine executable instructions. The machine executable instructions may be capable of causing the machine to identify a dynamic object in a file operated on by the computational software application a value of the dynamic object being dependent upon at least one underlying object. The machine executable instructions may also be capable of causing the machine to determine if the value of the dynamic object is to be rendered and determine if a value of the underlying object has changed. Additionally the machine executable instructions may be capable of causing the machine to recalculate the value of the dynamic object based on if the dynamic object is to be rendered and if the value of the underlying object has changed and cause an indication of the value of the dynamic object to be rendered to the user.

Yet another disclosed embodiment is directed to a method for presenting information to a user. The method may comprise identifying a dynamic object a value of the dynamic object being dependent upon at least one underlying object the value of the dynamic object comprising at least one of a symbolic expression a graphic expression or an animation and determining if a value of the underlying object changed. The method may also comprise recalculating the value of the dynamic object if the value of the underlying object has changed and causing an indication of the value of the dynamic object to be rendered to the user.

Still another disclosed embodiment is directed to a computer readable medium having stored thereon machine executable instructions. The machine executable instructions may be capable of causing the machine to identify a dynamic object a value of the dynamic object being dependent upon at least one underlying object the value of the dynamic object comprising at least one of a symbolic expression a graphic expression or an animation and determine if a value of the underlying object changed. Additionally the machine executable instructions may be capable of causing the machine to recalculate the value of the dynamic object if the value of the underlying object has changed and cause an indication of the value of the dynamic object to be rendered to the user.

The kernel and the front end may be implemented on a same computing system or on different computing systems that are communicatively coupled to one another. Thus the kernel and the front end may communicate via a communication link that comprises one or more of procedure calls messages a proprietary application programming interface API e.g. the API provided by MATHLINK software available from Wolfram Research Inc. etc. Additionally if the kernel and the front end are implemented on different computing systems the kernel and the front end may communicate via one or more of a local area network LAN a wide area network WAN the Internet a point to point communication link a wired communication link a wireless communication link etc.

The front end may include an interactive document referred to as a notebook similar to those often used with MATHEMATICA software systems. A notebook may include input to be sent to the kernel and output received from the kernel as well as text graphics palettes etc. A notebook may include menus and graphical tools for creating and reading notebook documents and for sending information to and receiving information from the kernel .

A user can cause information in a cell to be sent to the kernel as input by pressing Enter or Return while holding down the Shift key after a cursor has been placed in the cell. The kernel then evaluates the input to generate an output. The kernel may then send the generated output back to the front end . In response the front end may create one or more new cells in the notebook to display this output. Referring to a line corresponds to an input sent to the kernel and a line corresponds to an output generated by the kernel and sent back to the front end .

In notebooks used with MATHEMATICA software systems the front end labels each line of input with In n and labels each line of output with Out n where n indicates the nth input to the kernel or the output generated by the kernel in response to the nth input.

Alternatively the front end may comprise a text based interface in which text typed on a keyboard of a computing system is sent directly to the kernel . With a text based interface a user may interact with the kernel by typing successive lines of input and getting back from the kernel successive lines of output displayed on a display screen of the computing system. For example a prompt of the form In n may be displayed on the display screen to indicate to a user that the kernel is ready to receive input. After the input is typed in and sent to the kernel the kernel may process the input generate an output and send that output for display on the display screen with a label of the form Out n .

In some implementations the front end may be omitted. For example a software program that does not interface with a user may communicate with the kernel in a manner similar to communications between the kernel and the front end discussed above. This may comprise interaction via an API e.g. the API provided by MATHLINK software via files via an extensible markup language XML etc.

The kernel may be capable of evaluating different kinds of computations such as numeric computations symbolic computations e.g. algebraic computations integrations derivatives etc. graphic computations etc. Referring again to the expression is a symbolic expression. The kernel evaluated the expression and generated an output expression that is also symbolic. The kernel may represent different types of computations to be evaluated in a common format which may be referred to as an expression. 

An example of an expression is f x y . The expression f x y could be used to represent a mathematical function for example. A name of the function may be f and the function includes two arguments x and y. An expression need not be in the form f x y . . . . For example x y may also be an expression. When x y is typed in via the front end for example the front end and or the kernel may convert it to a standard form such as Plus x y . When displaying the expression Plus x y to a user via the front end for example it could be displayed in the form x y . The same symbolic expression may have different possible displayed forms Plus x y x y. In one implementation everything sent to the kernel may be formatted as an expression.

Using a standard format of expressions as described above may help maintain a structure which can then be acted on by other expressions. A list expression such as a b c does not specify an operation but it does maintain a list structure. Other expressions can operate on this structure. The expression a b c typed by a user may be converted to a standard format such as List a b c for example.

An expression can be thought of as a container of data tagged with or otherwise associated with additional information about the expression. Even though all expressions may have the same basic structure different types of expressions can be differentiated by the additional information with which the expression data is tagged. Then the kernel may include rules routine and or programs that treat different types of expressions in different ways.

As an example an expression may be a list having three elements. In a memory of a computing system implementing the kernel the expression may comprise three pointers indicating the addresses in the memory at which actual expressions that form the elements of the list are to be found. These expressions may in turn include pointers to their subexpressions. The chain of pointers may end when one reaches an object such as a number or a string which is stored directly as a pattern of bits in the memory. It may also end if an object does not reference any other objects. For example an object may be the symbol x where x has not been assigned a value.

A symbol such as x may be represented in memory by a pointer to an entry in a table of defined symbols. This table may be a repository of information about each symbol. For example it may include a pointer to a string giving the symbol s name as well as pointers to expressions which give rules for evaluating the symbol.

The kernel may include an evaluator configured to evaluate functions that appear in an expression. The kernel may include a library of functions each function configured to perform operations corresponding to the function and to build a new expression representing the result. If enough functions are included in the library a user may be able build a large number of other functions using the combinations of the library functions.

The kernel may be configured to perform symbolic calculations such as symbolic integration. Such symbolic calculations may be implemented by performing systematic procedures that may not correspond to how a person might perform a symbolic procedure by hand . Such systematic procedures may include case specific procedures as well as general procedures.

In a single kernel and a single front end are shown. One of ordinary skill in the art will recognize that multiple kernels and or multiple front ends may be utilized. For example a single front end may communicate with a plurality of kernels . For instance one front end may interact with a first kernel until a time T cease interaction with the first kernel and then begin interacting with a second kernel after the time T. Also one front end may communicate with a plurality of kernels during a single time period. Similarly one kernel may interact with multiple front ends . One of ordinary skill in the art will recognize many other variations.

Although the system was described above as optionally being capable of evaluating non numeric expressions such as symbolic expressions it is to be understood that in some implementations the system may not be capable of evaluating one or more of symbolic expressions algebraic expressions graphic expressions etc.

Further the system is only one example of a system that may be utilized to implement methods and techniques described below. Other example systems include a spreadsheet application a simulation application a control system application an instrument application a game application etc.

Examples of a type of object which will be referred to as a dynamic object that can be used with various types of computing software applications will now be described. A dynamic object may comprise an object whose value depends on some other underlying object. Additionally a computing software application configured to implement dynamic objects will identify the dynamic object as being dynamic and re render the dynamic object as a value of the underlying object changes without any further action from the user. In contrast comparing to previous versions of the MATHEMATICA software system for example a user would need to request explicitly by pressing Shift and Enter for example that the software system re evaluate an expression after the user determined that some underlying object of the expression had changed.

In general a dynamic object may comprise various types of objects such as a symbolic expression a number a table a list a graph a picture an animation etc. Similarly an evaluated value of a dynamic object may comprise a symbolic value a numeric value a plurality of values in a table a particular graph a particular graph a particular animation etc. In one embodiment the dynamic object may be an object capable of representing a plurality of types of data e.g. a symbolic expression a number a plot etc. . For example in the MATHEMATICA software system many different types of data e.g. numbers plots lists tables equations formulas etc. are represented using a common structure an expression. Thus a dynamic object may comprise such an expression. In other embodiments the dynamic object may be capable of representing only one or two types of data for example.

As an example a user may add a dynamic object to a notebook for use in a MATHEMATICA software system configured to implement dynamic objects by using a keyword such as Dynamic. is an illustration of a portion of a notebook . A user has typed in Dynamic x 2 and thus the software system will recognize the expression as a dynamic object. Using a keyword is just one example of a technique for adding a dynamic object to a file. For example a user could highlight using a keyboard mouse trackball etc. an expression previously entered into the notebook and then mark the highlighted expression as a dynamic object via a menu a button etc. One of ordinary skill in the art will recognize many other ways in which a user can designate an object in a file as a dynamic object.

The dynamic object depends on the value of an underlying object namely the object x. The MATHEMATICA software system is capable of evaluating symbolic expressions. Thus in the software system has evaluated the object as x2 and displayed an indication of the value of the object.

Referring now to a user has set the object x to a numeric value 5 by typing x 5 and pressing Shift and Enter . Because the value of the underlying object x has changed the software system recalculates the dynamic object and displays an indication of the updated value of the dynamic object . The indication is no longer displayed because it no longer corresponds to the value of the dynamic object . In contrast comparing to previous versions of the MATHEMATICA software system if the user wished for an updated value of the expression x 2 to be rendered after the value of x had been changed the user would have needed to request explicitly by pressing Shift and Enter for example that the software system re evaluate the expression x 2 .

Referring now to a user has set the object x to a numeric value 7 by typing x 7 and pressing Shift and Enter . Because the value of the underlying object x has changed the software system recalculates the dynamic object and displays an indication of the updated value of the dynamic object . The indication is no longer displayed because it no longer corresponds to the value of the dynamic object .

If the software system that implements dynamic objects is capable of evaluating symbolic expressions then the software system may be capable of implementing dynamic objects that may take on symbolic values. Referring now to a user has set the object x to a symbolic equation . Because the value of the underlying object x has changed to a symbolic value the software system recalculates the dynamic object and displays an indication of the updated value a symbolic value of the dynamic object . The indication is no longer displayed because it no longer corresponds to the value of the dynamic object .

If the software system that implements dynamic objects is capable of evaluating plot expressions then the software system may be capable of implementing dynamic objects that may take on plot values. Referring now to a user has set the object x to a plot of sin x by typing in the text . Because the value of the underlying object x has changed the software system recalculates the dynamic object and displays an indication of the updated value of the dynamic object . The indication is no longer displayed because it no longer corresponds to the value of the dynamic object .

In the notebook a user has typed in Table Dynamic x i 10 and thus the software system will recognize the expression as a dynamic object. The software system evaluated the object as a table having ten elements each element having the value x . An indication of the table is displayed. A similar result could be obtained by typing in Dynamic Table x i 10 .

Referring now to a user has set the object x to a numeric value 5 by typing x 5 and pressing Shift and Enter . Because the value of the underlying object x has changed the software system recalculates the dynamic object and displays an indication of the updated value of the dynamic object . Namely a table having elements 5 is displayed. The indication is no longer displayed because it no longer corresponds to the value of the dynamic object .

Referring now to a user has set the object x to symbolic value z by typing x z and pressing Shift and Enter . Because the value of the underlying object x has changed the software system recalculates the dynamic object and displays an indication of the updated value of the dynamic object . Namely a table having elements z is displayed. The indication is no longer displayed because it no longer corresponds to the value of the dynamic object .

At a block a dynamic object in a file may be identified. In the example system the front end may identify dynamic objects. In general the dynamic object may be identified in a variety of ways that may depend on how the system indicates objects as dynamic. For example if a keyword such as Dynamic is used a computing application may identify dynamic objects by identifying the keyword in the file. More generally the computing application may look for dynamic object indicators associated with objects to identify dynamic objects.

As illustrated in a dynamic object can have a numeric or some other type of value such as a symbolic value. Optionally the type of values that the dynamic object has may change. For example in the value of the dynamic object changed from a symbolic value to a numeric value. The file in which the dynamic object resides may comprise a variety of types of files. For example the file could comprise a file formatted for use with a computing application e.g. a notebook file used with MATHEMATICA software systems a text file a file formatted for use with a word processing application a file formatted for use with a spreadsheet application etc.

Referring again to at a block one or more underlying objects on which the dynamic object depends may be determined. In the example system the kernel may determine the underlying objects. Determining the underlying objects may comprise determining what objects are used to evaluate the dynamic object and determining what objects are used to evaluate the dynamic object may comprise analyzing the object itself and or information associated with the dynamic object. In B and C the dynamic object depends on the object x. This may be determined by analyzing the dynamic object itself which includes x 2 for example.

Referring again to at a block indications of the underlying objects determined at the block may be stored. In the example system the kernel may store the indications of the underlying objects. The stored indications may be associated with the underlying objects and or with the dynamic object. In the example of B and C and indication that the dynamic object x 2 depends on the object x may be associated with the object x and or with the dynamic object x 2 .

At a block if a value of an underlying object has changed and if the dynamic object needs to be rendered the value of the dynamic object may be recalculated. In the example system the kernel may determine if an underlying object has changed. Determining if an underlying object has changed may comprise analyzing information associated with a recently changed object to see if any dynamic objects depend on the object. In the example system when the kernel changes the value of an object the kernel may analyze information associated with the object to determine if there are any indicators such as indications stored at the block indicating that one or more dynamic objects depend on the object.

Determining if an underlying object has changed may additionally or alternatively comprise analyzing information associated with a dynamic object that is to be redrawn on the screen to determine on which underlying objects it depends. In the example system when a screen having a dynamic object is to be redrawn the front end may analyze information associated with the dynamic object to determine if there are any indicators such as indications stored at the block indicating that it depends on one or more underlying objects. Then the front end could poll the kernel to determine if values of any of the one or more objects had changed.

In the example system the front end may determine if the dynamic object needs to be rendered. Determining if the dynamic object needs to be rendered may comprise for example determining if a display screen on which the dynamic object is located should be refreshed.

In the example system the kernel may recalculate the value of the dynamic object and then provide the value to the front end . Then at a block an indication of the recalculated value of the dynamic object is rendered to a user. In the example system the front end may cause an indication of the recalculated value to be rendered. For example an indication of the value of the object could be displayed on a display screen.

One of ordinary skill in the art will recognize that the method may be modified. For instance one or more blocks could be modified one or more blocks could be omitted blocks could be combined and or reordered additional blocks could be added etc. As just one example the block could be modified so that the value of the dynamic object is recalculated even if the dynamic object does not need to be rendered.

The method can be implemented by a computing system such as the computing system of and will be described with reference to for explanatory purposes. The method may be implemented each time it is detected that an underlying object has changed where the underlying object is depended upon by a dynamic object. For example the kernel may have stored an indication associated with the underlying object that a dynamic object depends upon it and may have detected that the underlying object changed.

At a block the kernel notifies the front end that the underlying object changed and that the dynamic object depends on the underlying object. At a block the front end stores an indication that the dynamic object is to be updated. Additionally the front end may store an indication that the dynamic object depends on the underlying object. After notifying the front end at the block the kernel may then delete its stored indication of the dependency of the dynamic object upon the underlying object at a block . Thus the kernel need no longer spend computational resources regarding notifying the front end of changes to the underlying object. Additionally by deleting the indication of dependency the kernel avoids having to maintain a potentially very large list of dependencies of all the dynamic objects.

Because of the indication stored at the block by the front end the front end is aware that the dynamic object should be updated if and when it is to be rendered next. Thus at a block if and when the dynamic object is to be rendered the front end causes the value of the dynamic object to be updated. The front end could request the kernel to update the dynamic object.

At a block the kernel may re evaluate the value of the dynamic object. Additionally in the process of re evaluate the value of the dynamic object the kernel may re determine the underlying objects on which the dynamic object depends. Then the kernel may store an indication that the underlying object is depended upon by the dynamic object at a block . At a block the kernel may provide the front end with the updated value of the dynamic object.

One of ordinary skill in the art will recognize that the method may be modified. For instance one or more blocks could be modified one or more blocks could be omitted blocks could be combined and or reordered additional blocks could be added etc. Additionally an entirely different method may be utilized to implement the example method of . For example if the method is implemented by a system that does not include a kernel and a front end structure a different method may be utilized.

Dynamic objects may also be used with graphical user interface GUI controls or mechanisms such as sliders wheels buttons etc. For example a dynamic object may be linked to a GUI control such that a change in the value of the dynamic object causes some change to the GUI control. Additionally the dynamic object and the GUI control may be linked such that a manipulation of the GUI control by a user may cause the value of the dynamic object to change. is an illustration of a portion of a notebook that utilizes a slider control. The slider may be created in a variety of ways. In the example notebook a slider control is created using a command Slider . A first argument of the Slider command is a position of a knob on the slider. In the notebook the position of the knob is specified as corresponding to a dynamic object namely Dynamic x . In this configuration the dynamic object is linked to the position of the slider such that a change to the value of Dynamic x affects the position of the slider and vice versa.

A second argument of the Slider command is a range of values to which the slider corresponds. In the notebook the range is specified as 1 10 . With such a specified range the leftmost position of the knob may correspond to 1 and the rightmost position of the knob may correspond to 10 for example.

In the notebook a variable x has been set to 2. Additionally a line specifies a list that is to be evaluated. The list includes the slider as a first element and the dynamic object Dynamic x as the second component. The software system evaluated the line and generated a list . The list includes a slider and an indication of the value of the dynamic object Dynamic x . The slider includes a knob which is in a position corresponding to 2 because the knob position is set to the value of the dynamic object Dynamic x and x has been set to 2.

A GUI mechanism also can be linked to non numeric dynamic objects such as symbolic objects plots graphics animations etc. is an illustration of a portion of a notebook that utilizes a slider control in conjunction with a plot. In the notebook a variable x has been set to 1. Additionally a line specifies the slider to be created. A position of a knob of the slider is to be a dynamic object Dynamic x . The software system evaluated the line and generated a slider having a knob . The knob is in a position corresponding to 1 because the knob position is set to the value of the dynamic object Dynamic x which has been set to 1.

A line specifies another dynamic object to be created a plot. The plot is of the function Sin y x for values of y between 0 and 2 . Because the plot specified by the line is to be a dynamic object the software system may update it upon changes in any underlying objects. In this case the variable x may be changed via the slider for example. The software system evaluated the line and generated a plot which corresponds to a plot of Sin x y where x 1.

A state of a GUI mechanism e.g. a position of a slider also can be linked to a function of an underlying object. As just one example a value of an underlying object may be determined based on some function of a knob position of the slider and not merely on the knob position itself. is an illustration of a portion of a notebook in which a knob position of a slider is dynamically dependent upon a function of an underlying object. In the notebook a line specifies the slider to be created. A position of a knob of the slider is to be the dynamic object Dynamic 1 x x 1 . The first argument of the Dynamic command indicates a first function specifying how to determine a value of the dynamic object based on the underlying object x. Namely the value of the dynamic object is to be determined as 1 x. The second argument of the Dynamic command indicates a second function specifying how to determine the value of the underlying object x based on the dynamic object. Namely the value of the object x is to be determined as one minus the value of the dynamic object. The symbol is used in MATHEMATICA software systems to indicate that preceding text is a function and that an argument to the function is indicated by the symbol . Thus the Slider command in line indicates that when a valued of the underlying object x changes the position of a knob of the slider is to be determined as 1 x. Additionally the Slider command in line indicates that when a user changes the position of the knob the value of the underlying object x is to be changed according to the equation x one minus the knob position. Thus the Slider command in the line specifies a bidirectional relationship between the underlying object x and the knob position.

The software system evaluated the line and generated a slider having a knob as well as an indicator of the value of the underlying object x. The left most position of the knob corresponds to a knob position of zero and the right most position of the knob corresponds to a knob position of one. The knob is in a position corresponding to one because the knob position is set to the value of the dynamic object Dynamic 1 x . . . and x has been set to 0.

At a block a relationship between states of a user interface mechanism located on a workspace e.g. a notebook used with MATHEMATICA software systems a spreadsheet a simulation display a control system interface a software instrument a game etc. and an underlying object is determined. The user interface mechanism may comprise for example GUI mechanisms such as a slider a wheel buttons input fields etc. or mechanical user interface mechanisms such as a mechanical slider a joystick a wheel etc. with force feedback. States of the GUI mechanism may comprise a position of a knob a position of the wheel which buttons are depressed value of an input field etc. In the example system the kernel and or the front end may determine the relationship by for example evaluating commands in a file such as a notebook a text file etc. Referring to the kernel and or the front end may determine the relationship between the position of the knob of the slider and the underlying object x by analyzing the line . In particular the position of the knob is dynamically dependent upon the value of x. Referring to the front end may determine the relationship between the position of the knob of the slider and the underlying object x by analyzing the line . In particular when the value of x changes the position of the knob is to be determined as 1 x and when the position of the knob is changed by a user the value of x is to be determined as one minus the knob position.

Referring again to at a block it may be determined if a state of the user interface mechanism changed. In the example system the front end may determine if a state of the user interface mechanism changed. Referring to B and C the front end may determine if a user has adjusted the position of the knob using a variety of techniques well known to those of ordinary skill in the art.

Referring again to if a state of the user interface mechanism changed then at a block the value of the underlying object may be changed according to the relationship determined at the block . In the example system the kernel may change the value of the underlying object. For example the front end could provide the kernel with an indication of the relationship as well as an indication of the new state of the user interface mechanism. In response the kernel could update the value of the underlying object. Optionally the front end may update the value of the underlying object. For example front end could update the value of the underlying object if the relationship between the state of the user interface mechanism and the underlying object is relatively straightforward. But if the relationship is complex the front end could provide the kernel with an indication of the relationship as well as an indication of the new state of the user interface mechanism and let the kernel determine the updated value of the underlying object.

At a block it may be determined if the value of the underlying object changed. In the example system the kernel may notify the front end if the value of the underlying object changed and may provide the front end with the new value. Alternatively if the front end updated the underlying object itself it would then know when the underlying object changed. If the value of the underlying object changed then at a block the state of the user interface mechanism may be changed according to the relationship determined at the block . In the example system the front end may change the state of the user interface mechanism. In for example the front end could redraw the knob at a new position when the kernel notifies the front end that the value of the object x changed and provides the new value of the object x. Optionally the state of the user interface mechanism may only be changed if it is determined that the user interface mechanism is to be rendered. For example the value of the underlying object may change many times in between screen refreshes. Thus in order to conserve computational capacity the state of a GUI mechanism may only be updated when the screen needs to be refreshed.

The flow related to blocks and may be repeated to monitor changes in the underlying object and or states of the user interface mechanism.

One of ordinary skill in the art will recognize that the method may be modified. For instance one or more blocks could be modified one or more blocks could be omitted blocks could be combined and or reordered additional blocks could be added etc.

As discussed above dynamic objects may also be used with in conjunction with graphics. For example dynamic objects may be utilized to specify graphics primitive information e.g. particular graphics primitives to be rendered coordinates of graphics primitives attributes of graphics primitives etc. or other information on which a rendering of the graphic object depends.

The software system evaluated the text and generated a slider having a knob . The left most position of the knob corresponds to a knob position of zero and the right most position of the knob corresponds to a knob position of one. The knob is in a position corresponding to 0.5 because the knob position is set to the value of the dynamic object Dynamic n and n has been set to 0.5.

The software system also generated the graphic having lines . A number of the lines based on n where n 0.5.

A manipulation of a graphic also can be linked to an underlying object. is an illustration of a portion of a notebook in which knob positions of two sliders determine the position of a point in a graphic. Conversely a user can directly move the position of the point and new positions of the moved point determine new knob positions of the two sliders. For example a user can select the point in the graphic and then drag the point to a new position. In response as the point is moved the software system will move the slider knobs corresponding to the new positions of the point.

In the notebook the text specifies two sliders to be created. A position of a knob of a first slider is to be the dynamic object Dynamic x . A position of a knob of a second slider is to be the dynamic object Dynamic y . Additionally left most positions of the sliders are to correspond to 1 and right most positions are to correspond to 1. Further the text specifies a graphic to be created in which a position of a point is dynamically dependent upon positions of the sliders and vice versa.

The software system evaluated the text and generated a slider having a knob and a slider having a knob . Further the software system generated a graphic depicting a single point . The knob is in a position corresponding to 0 because the knob position is set to the value of the dynamic object Dynamic x and x has been set to 0. The knob is in a position corresponding to 0 because the knob position is set to the value of the dynamic object Dynamic y and y has been set to 0. The point is at a position corresponding to the coordinates 0 0 because the coordinates of the point were set to Dynamic x y and x and y have both been set to zero.

As another example a user could have directly moved the point to the position illustrated in . For example the user could have selected the point using a mouse a trackball a touch pad a touch screen etc. and then dragged the point to the new position. In response the software system would modify the values x and y to correspond to the new position of the point . Additionally because x and y have been modified and because x and y are dynamically linked to the positions of the knobs and the software system would modify the positions of the knobs and . The computer system may redraw the notebook or a portion of the notebook many times as the knob and the knob are being moved by the user and the graphic may rapidly change to indicate the changing values of x and or y.

In the notebook the text specifies a graphic to be created. The graphic comprises a plurality of lines that each has one end at the coordinate 0 0 . The other ends of the lines have x coordinates evenly spaced from 1 to 1. Additionally the y coordinates of the other ends of the line are the dynamic object Dynamic y .

The software system evaluated the text and generated a graphic having a plurality of lines including a line . One set of endpoints of the lines in a position corresponding to y 0.5 because these endpoints are set to the value of the dynamic object Dynamic y and y has been set to 0.5.

As can be seen in the above description complex dependency linking can be accomplished using very few commands. For example a GUI interface may be created and linked to an underlying object using only one command line. Further simplification may also be achieved by providing commands that combine GUI interfaces with dynamic objects. One example is a Manipulate command having a syntax Manipulate expr u u u where the expr may be an expression such as a numeric expression a symbolic expression a plot a graphic etc. that depends on an underlying object u that may be manipulated between u and u. When the software system evaluates the Manipulate command it generates in a notebook a depiction of the value of the expression expr as well as a GUI mechanism such as a slider for manipulation of the object u . Then when a user changes the object u via the slider changed values of the expression expr are depicted in the notebook. Another syntax for the Manipulate command is Manipulate expr u . . . v . . . . . . where the expr may be an expression that depends on one or more underlying objects u v . . . . When the software system evaluates the Manipulate command it generates in a notebook a depiction of the value of the expression expr as well as one or more GUI mechanisms such as sliders for manipulation of the objects u v . . . . Then when a user changes an underlying object via the GUIs changed values of the expression expr are depicted in the notebook. One of ordinary skill in the art will recognize that the syntaxes described are merely examples and that many different syntaxes may be used additionally or alternatively.

The evaluated expression is a plot of a function named func and the name func can take on one of six possible values Sin Cos Tan Sec Csc Cot. Additionally the function func is also dependent upon underlying objects Freq and Phase . Further the plot is dependent upon the underlying object Amplitude because it is a plot of the function func multiplied by Amplitude .

The display includes a GUI mechanism for selecting the value of the name func . Also the plot includes a slider for changing the Amplitude object a slider for changing the Freq object and a slider for changing the Phase object. Further the evaluated Plot object is depicted in the plot . In the object func has been selected as Sin . As a result the computing system has evaluated the plot as a plot of a Sine function multiplied by Amplitude . illustrates the display in which a pull down menu that may allow a user to select a value of func is depicted. illustrates the display after the value of func has been selected as Tan . In response the computing system has evaluated the plot as a plot of a Tangent function multiplied by Amplitude .

Thus as can be seen in B and C the name of a function to be evaluated can be made dynamic as well. In some implementations any symbol in a command line can be easily designated by the user to be made a dynamic object. For example the function a name of the function an argument of the function etc. can be designated by the user as a dynamic object via a keyword a pull down menu a shortcut key etc.

Dynamic objects may be utilized in modifying many other types of objects and or attributes of objects. For example dynamic objects may be linked to animation text documents attributes of objects e.g. font type font size font color background colors of plots graphics or documents etc. . Additionally the underlying object on which a dynamic object depends could be an object controlled outside of the software system such as a time value set by a computing system a variable received from a separate computing system such as a measurement device an electronic musical instrument etc.

Although graphical user interface mechanisms were described above mechanical user interfaces may be utilized as well such as game controllers joysticks knobs dials etc. Similarly although rendering of indications of values on a display device was described above other types of rendering may be implemented such as sending a value to a file or to another software application generating audio controlling light emitting diodes controlling a stepper motor etc. Thus determining if it is time to render a dynamic object may depend on the type of rendering that is to be employed.

Referring again to in another implementation the kernel may comprise a server application such as web server and the front end may comprise a client user interface application such as a web browser. In such an implementation data can be represented by a formatted expression such as an extensible markup language XML data structure. Thus a dynamic object could be an XML data structure. In this implementation when a dynamic object was to be updated the web server could recalculate the value of the dynamic XML object and then cause the web browser to display an indication of the updated dynamic XML object. For example the web server could send a refreshed page to the web browser or cause a portion of the page being displayed to the user to be updated. Extensible Style Language Transformation XSLT techniques could be utilized to update the dynamic XML object.

Any of the techniques described above including the blocks described with reference to A and may be implemented using software comprising computer program instructions. Such computer program instructions may control the operation of a computing device such as a desktop computer a laptop computer a tablet computer a workstation a server a mainframe a cellular phone a telephone a set top box a PDA a pager a processing system of an electronic toy a processing system of an electronic game a processing system of a consumer electronics device etc. The computing device may have a memory in which the computer program instructions may be stored. The computer program instructions may be written in any high level language such as the programming language used with MATHEMATICA software systems C C C Java or the like or any low level assembly or machine language. By storing computer program instructions in a memory of the computing device the computing device is physically and or structurally configured in accordance with the computer program instructions.

While many methods and systems have been described herein as being implementable in software they may be implemented in hardware firmware etc. and may be implemented by a variety of computing systems and devices. Thus the method blocks and system blocks described herein may be implemented in a standard multi purpose central processing unit CPU a special purpose CPU or on specifically designed hardware or firmware such as an application specific integrated circuit ASIC or other hard wired device as desired. When implemented in software the software routine may be stored in any computer readable memory such as on a magnetic disk a laser disk such as a compact disk CD a digital versatile disk DVD a flash memory a memory card a memory stick etc. or other storage medium in a RAM or ROM of a computer or processor in any database etc. Likewise this software may be delivered via any known or desired delivery method including for example on a computer readable memory or other transportable computer storage mechanism or over a communication channel such as a telephone line the internet etc. which are viewed as being the same as or interchangeable with providing such software via a transportable storage medium .

The present disclosure has been described with reference to specific examples which are intended to be illustrative only and not to be limiting. It will be apparent to those of ordinary skill in the art that changes additions or deletions may be made to the disclosed examples without departing from the spirit and scope of the disclosure.

