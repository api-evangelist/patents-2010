---

title: Minimizing latency in network program through transfer of authority over program assets
abstract: Authority over an artificial intelligence (AI) asset can be controlled among two or more processing devices running a common program over a network using a technique in which authority can be transferred. A first processing device can exercise authority over the AI asset by executing code that controls one or more actions of the AI asset according to a decision tree. The decision tree can determine whether to engage the program asset based on criteria other than a distance between the AI asset and the program asset. The first processing device can broadcast a state of the AI asset to one or more other devices running the program. If the decision tree determines that the AI asset should engage a program asset over which another processing device has authority the first processing device can relinquish authority over the AI asset and transfer authority to the other device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08805773&OS=08805773&RS=08805773
owner: Sony Computer Entertainment America, LLC
number: 08805773
owner_city: San Mateo
owner_country: US
publication_date: 20100903
---
Embodiments of the invention are related to programs implemented on multiple devices connected by a network and more specifically to techniques for minimizing perceived latency when two or more users interact with non user controlled assets.

Online game technology provides a mechanism by which players located at remote sites can play interactive games with each other over a computer network such as the Internet. The interactive games may range from simple text based games involving only a single player or a few players to games incorporating complex graphics and virtual worlds populated by many players simultaneously. Many online games have associated online communities making such online games a form of social activity allowing players from all over the globe to participate in games and otherwise interact with each other.

Online games often include two types of assets referred to herein as user assets and artificial intelligence AI assets. User assets are assets that are directly controlled by a user. By way of example in an online game a user s actions are often represented by a character referred to as an avatar. The user has exclusive control over certain actions of the avatar. Such control is typically exercised through an interface e.g. a game controller joystick keyboard or other input device that the user manipulates. The user s commands affect the state e.g. position velocity and movements e.g. fighting moves of the avatar through a computer device e.g. a game console personal computer or mobile device that is connected to other user devices and perhaps a server via a network. The avatar s state may be broadcast over a network to other devices which can interpret the state information and present a display of the avatar so that users of those devices can perceive the avatar.

Many online games often include assets in the form of objects that player characters can possess. An example of such an object is the ball in a sports game. In many such games the player character possessing the object determines the movements and actions of that object. Often these decisions are made by the machine of the player that possesses the object. Possession of the object is often determined by distance between the object and the nearest player character. AI assets on the other hand are controlled by the game program and not by any particular user. Like a user asset an AI asset may have a state that defines the AI asset s position velocity and movements. The state may change according to a decision tree that can be implemented as software code. In conventional online games AI assets are controlled by a server. The server executes the software code that runs the decision tree that determines the state of the AI asset and then broadcasts the state of the AI asset to user devices referred as client devices that are connected to the server via a network. It is impractical to assign control over AI assets to player characters since AI assets tend to behave independently unlike game objects.

A problem can arise during interaction between a user asset and an AI asset due to network latency. It is desirable for actions in a networked game to look and feel like a single player combat game. In a single player combat game designers often slow time down so that the player can feel more powerful. This is relatively easy to do if the code controlling the AI asset and the user asset are executed by the same device. However this is difficult if not impossible to implement over a network when the user asset code is run on a client device and the AI asset code is run on a remote server.

Traditional latency hiding techniques such as client side prediction as used in FPS games are designed for games where players interact indirectly with other players and AI assets using ranged weapons. It is difficult to apply the FPS latency compensation techniques to hide latency in a combat based game where players interact directly with AI assets via melee attack moves grabs and throws.

By way of example in an online combat game based on a standard client server networking model e.g. as depicted in AI assets run on a server . Players can interact with the AI assets via client devices . If this technique were used to network a combat intensive game the client players would feel latency in their interaction with the AI characters. For example the client player would notice that the AI assets have some additional delay before they attack and some delay before playing hit reactions to the player s attacks. This negatively impacts the feel of the combat.

Consider a prior art client server networking model with three players running on similar devices that can communicate with each other over a network . In this example two of the players devices act as clients and one player s device acts as the server. In such a case the device that acts as the server is called an integrated server because the client and server code are running on that machine. This is in contrast to a dedicated server hosted in a data center that each player s device connects to.

Now consider a combat based game which is to be networked using this client server networking model. In the pure client server model depicted in networking operates as follows 

On the client side each client acts as a dumb terminal with each player sending their input to the server and interpolating between state updates received from the server to provide the illusion of smooth movement of networked entities.

On the server side each time through the loop input packets are processed from clients if no input packet is received input is assumed to have not changed. The current state of all relevant players and characters are broadcast to clients. After which then the game update occurs in which players and AI characters are updated according to the game rules.

In this pure client server model the game code runs only on the server . All clients except the player who is the integrated server perceive latency in their own actions as well as the actions of the AI assets. Such actions may include movement attack animations block animations and reactions to getting hit.

In such a prior art implementation it is possible to hide the latency of a client player s own actions by using a technique called client side prediction however this technique is difficult to implement in a combat based game due to the complexity of player character and animation code. In client side prediction a client locally reacts to user input before the server has acknowledged the input and updated the game state. Rather than sending control input to the server and waiting for an updated game state in return the client also in parallel with this predicts the game state locally and gives the user feedback without awaiting an updated game state from the server. Unfortunately client side prediction only hides the latency of a player s own actions it does not hide the latency of the actions performed by AI characters with which that player interacts.

Disadvantages associated with the prior art are over come by embodiments of the invention including a computer implemented method for controlling authority over an artificial intelligence AI asset among two or more processing devices running a common program over a network and a related device and non transitory computer readable medium.

According to the method a first processing device can exercise authority over the AI asset by executing code on the first processing device. The code controls one or more actions of the AI asset according to a decision tree. The decision tree determines whether to engage the program asset based on one or more criteria other than a distance between the AI asset and the program asset. The first processing device can broadcast a state of the AI asset to one or more other devices running the common program over the network. If the decision tree determines that the AI asset should engage a program asset over which another processing device has authority the first processing device can relinquish authority over the AI asset by stopping execution of the code and transferring authority over the AI asset to one of the other devices running the common program over the network.

In some implementations after transferring authority the first processing device may receive the state of the AI asset from other device to which the authority over the AI asset was transferred.

In some implementations the common program can be a game program and the AI asset can be a non player character in the game program. In such an implementation the first processing device can control the actions of a player character and broadcast a state of that player character to one or more other devices running the common program over the network.

In certain implementations the first processing device can receive the state of another AI asset over which the first processing device has not authority from another device running the common program over the network.

In certain implementations the first processing device can be a default processing device for the AI asset.

In certain implementations authority over the AI asset could be transferred to the first processing device from another processing device on the network.

In certain implementations the first processing device can execute code that controls one or more actions of more than one AI asset.

In certain implementations the first processing device can exercise exclusive authority over a user asset of the common program that is uniquely associated with a user of the first processing device by executing code that controls one or more actions of the user asset. In such implementations the common program can be a game program wherein the AI is a non player character and the user asset is a player character.

According to an alternative embodiment the computer processing device referred to above may include a processor a memory and one or more processor executable instructions embodied in the memory and configured for execution on the processor. The instructions are configured to implement the above described method for controlling authority over an artificial intelligence AI asset among two or more processing devices running a common program over a network.

In some implementations the processing device can have default authority over the AI asset and one or more other AI assets. In such implementations the processing device may have exclusive authority over an asset of the common program that is uniquely associated with a user of the processing device.

A non transitory computer readable medium may have embodied therein one or more processor executable instructions configured to implement the above described method for controlling authority over an artificial intelligence AI asset among two or more processing devices running a common program over a network.

Embodiments of the present invention solve this problem of latency in interacting with AI assets in a networked computer program by employing a hybrid P2P networking model in which AI assets migrate from one machine to another such that the code for the AI assets run on the machine of the user asset that they are currently engaging.

This optimizes the player s experience in the common case making it appear as if each player is interacting with AI assets with zero latency. This preserves the same feel of single user interaction with AI assets while enabling multiple players to join together engaging AI assets in an online program that involves intensive interactions between users and AI assets. Embodiments of the present invention utilize an alternative latency hiding technique suitable for networking player vs. AI combat interactions in cooperative COOP or competitive combat based games.

In some P2P networks one node may be selected to act as a host to control certain centralized functions. Such functions may include coordinating communication amongst the other nodes coordinating entry of new nodes into the network or control over certain program assets. The host is similar to a server in that it is the only node that provides these centralized functions. However a host is different from a server in that all of the nodes not just the host run the common program. Consequently any node may act as the host should the need arise.

In the example depicted in there are three nodes with node acting as the host. It is noted that although only three nodes are depicted in those of skill in the art will recognize that any number of nodes greater than two may be used in embodiments of the present invention. Furthermore although depicts only a single node acting as a server host those skilled in the art will recognize that some of the host s duties may be split amongst two or more nodes.

A P2P network relies primarily on the computing power and bandwidth of the nodes in the network rather than concentrating it in a relatively low number of servers. P2P networks are typically used for connecting nodes via largely ad hoc connections. Such networks are useful for many purposes. P2P networks may be used e.g. for sharing content files containing audio video data or anything in digital format is very common and real time data such as telephony traffic may also be transmitted using P2P technology.

Applications implemented via P2P networks may be subject to latency. The latency is largely a result of the time required to transmit data over the P2P network. Many online applications such as video games attempt to hide the effect of such latency to that it is less perceptible to users of the application.

By way of example in the case of a first person shooter FPS type game the game simulation does not need to run in deterministic lockstep as is the case with real time strategy RTS games. Instead the game simulation runs asynchronously. Synchronization can be performed by defining a direction of flow for state and events for particular game asset based on which machine has authority over that asset. In embodiments of the present invention program code can be modified so that each device participating in the network has an authority side and a non authority side . Data including network state and event information flows from authority to non authority. In general program assets may include user assets that are uniquely associated with a particular user and artificial intelligence AI assets that are not. The state and events of a user asset may be controlled at least in part by code the runs exclusively on that user s machine. In embodiments of the present invention the authority over the state and events for AI assets can be transferred among the server host and clients .

The decision tree can determine whether the AI asset will engage in interaction with a user controlled program asset such as a player character. The AI asset may engage the user controlled program asset e.g. by simulated combat simulated conversation or other simulated interaction with the user controlled program asset.

As seen in in addition to the common program each node has a first set of program assets over which it has authority and a second set of program assets over which it has no authority. It is noted that these two sets are in general different for each node in the network environment . By way of non limiting example the common program may be an online video game. As noted above each user referred to as players may play the game via a node. Each node may control a player character which may be represented by an avatar. The game may also include AI assets in the form of non player characters that are represented by corresponding avatars. The program may control physics simulations that determine the interactions between player characters and a simulated environment the non player characters or each other. Such interactions may result in corresponding changes of state for the player characters non player characters or the simulated environment itself. These changes in state may be used to drive animation engines on each node that allow the environment the player characters and the non player characters to be displayed on video displays associated with each node.

In this example each player s node always has authority over local character for that player. Therefore state such as position orientation velocity and actions e.g. attack block play hit reaction for player character on node are broadcast from node to nodes and such that they are applied to drive the game simulation forward in the remote view of each remote player character. Similarly information relating to the player character simulated on node is broadcast from nodes and and so on.

Authority for AI assets is more complex than for player characters. By default each AI asset can have a default authority. As used herein default authority means that the AI asset runs on a node with default authority e.g. the server host which broadcast the state of the AI asset to the other nodes e.g. nodes .

This model differs from the prior art in that AI assets are able to migrate such that they run on any player s machine. Running in this context means that the AI asset s brain or decision tree are made on that player s machine instead of being made on the server. As noted above the AI asset s brain or decision tree determines all decision making aspects of what the AI does which animations it plays whether it decides to attack or retreat whether it is hit or blocks Effectively when the AI asset s decision tree transfers authority to a player s machine it is like that player s machine is now the server for that AI asset.

By way of example and not by way of limitation in the context of a close combat game program the AI asset may operate as follows 

An AI asset may be in one of three modes wandering patrolling or attacking. In the wandering mode the AI asset may randomly walk around a level without direction. In the patrolling mode may follow a set of waypoints around a level e.g. like a guard patrol path where the guard walks around a wall or other predetermined perimeter. It is noted that the wandering and patrolling modes are meant as examples of things that an AI asset may do while not targeting a player character e.g. a default authority behavior that could run on the server host. An AI asset may optionally have a target. This target may be one of the player characters for nodes or . If the AI is in the wandering or patrolling state the target must be NULL. If the AI asset is in the attacking state its target must be set. By way of example an AI asset may enter the attacking state if a player character attacks the AI asset or if the AI asset comes within some pre defined attacking distance of a player character in the simulated environment. The decision tree for the AI asset decides what it should do next. For example the decision tree makes decisions such as selecting a target choosing a direction of movement and deciding whether to attack or retreat.

By way of example an embodiment of the invention may work as illustrated in and . In this example as shown in an AI asset AI in a simulated environment may be in a default initial state e.g. in which the AI asset AI is in a wandering or patrolling mode in which the AI asset AI has default authority in which case the AI asset may operate in a traditional mode as in the prior art. Specifically the decision tree for the AI asset AI may run on the server host by default as indicated at in . The server host broadcasts updates for the state e.g. current position orientation velocity of the AI asset AI etc. as well as events such as attack block play hit reaction to client devices for players as indicated at . The clients devices e.g. Client 1 and Client 2 receive these state updates as indicated at and respectively. It is noted that the server host may have authority over its own player character not shown . However this has been omitted for the sake of clarity.

As may be seen in initially Client 1 has exclusive authority over a first player character and non authority over a second player character and the AI asset AI. Client 2 initially has exclusive authority over the second player character and non authority over the first player character and the AI asset AI.

At a later time the decision tree for the AI asset AI may target one of the player characters e.g. the first player character . In such a case authority over the AI asset AI is transferred such that it has authority equal to an identifier ID of the player character the AI asset AI is targeting the first player character . This is decided by the decision tree for the AI asset AI running on the server host as indicated at and is communicated to players by broadcasting an authority transfer to all players in the game as indicated at .

Post transfer the AI decision tree or brain runs on the machine of the player which it is targeting which is not the server host . In the present example the decision tree for the AI asset AI would run on Client 1 as indicated at . The flow of AI state position velocity orientation etc. . . . as well as AI events attack block play hit reaction are now broadcast from the authority machine the targeted player s machine Client device 1 to other players devices in the game the non authority side of that character as indicated at . In the example depicted in the state and events are received by Client device 2 204 and the server host as indicated at and respectively. This is in marked contrast to the prior art where AI data always flows from server to client.

As seen in Client 1 now has authority over the first player character and the AI asset AI and non authority over the second player character and the AI asset AI. Client 2 has authority over the second player character and non authority over the first player character and the AI asset AI. The server host has authority over no assets and non authority over the first player character the second player character and the AI asset AI. The decision tree for the AI asset AI determines whether to engage a particular player based on one or more criteria other than a distance between the AI asset and the nearest player. By this it is meant that the decision tree may take distance to the nearest player into account but not exclusively. The decision tree for the AI asset AI may decide to randomly target a player or may target a player based on the game state. For example the decision tree for the AI asset AI may decide to target a player character if the player character possesses a specific game object or is engaged in specific activities or has previously engaged in specific activities that are unrelated to the distance between the player character and the AI asset AI.

Authority control based on an AI decision tree criteria other than distance has several advantages over prior art AI asset authority control based on distance to the nearest player. For example consider a game situation where two players are fighting a large number e.g. 10 AI assets in close quarters in a small room. If authority over each AI asset is driven by nearest player alone as AI assets and players moved around there would be a lot of oscillation in authority from one machine to another. Driving authority by a target determined by an AI decision tree by contrast allows AI assets to hold their authority based on the player they are targeting. This allows the AI assets to make decisions to move closer towards the target player or players to attack them without having their authority being distracted by other players that move near to a given AI asset while that AI is executing its current goal. Of course the decision tree can also take distance into account using some weighting system but it is not forced to assign authority based on distance alone as with nearest player authority systems.

Assigning authority over AI assets based on an AI decision tree is also advantageous if an AI asset is attacking a player with ranged attacks. For example it is desirable for AI assets attacking a player via bow and arrow to run on the machine of the player which they are attacking so that an AI asset can aim at a targeted player character running in the same time stream as the AI. Otherwise the AI asset s ranged attacks will be inaccurate proportional to the amount of latency between the player s machine and the machine running the AI asset. Target based authority works better in this situation than distance to nearest player based authority.

Assigning authority over AI assets based on an AI decision tree is also advantageous if an AI asset is attacking a first player character in close quarters with a weapon such as a pike such that there is some distance between the AI asset and the player it is attacking. Then consider that a second player is able to sneak up behind the AI asset without the AI asset becoming aware of this. In this case it is obviously preferable for the AI asset to continue to run on the machine of the first player which it is still attacking instead of transferring authority to run on the machine of the second player character who sneaked up behind the AI asset and who is now closer. Of course if the second player were to accidentally make a sound or the AI asset were otherwise made aware that the second player attacked it from behind the AI asset s decision tree could decide to target the second player and authority over the AI asset could be transferred to the second player s machine at that point.

If the decision tree for AI asset AI running on Client 1 decides to target another player or clears its target back to null perhaps it has decided to return to wandering or patrolling modes as indicated at the client player sends a release authority event back to the server as indicated at . This event may optionally contain a hint of which player id the authority machine has decided should be the next target if any for the AI asset. In this way the player s machines are able to release authority over an AI asset which is no longer targeting their local player characters. Once authority has been transferred back to the server host the decision tree for the AI asset AI runs on the server host as indicated at . The server host broadcasts the state and events for the AI asset AI as indicated at . Client 1 and Client 2 receive the state and events as indicated at and respectively.

It is important to note that in embodiments of the present invention the server host always arbitrates authority. Clients do not transfer authority directly between one another. The reason for this is so that each client sees the same sequence of authority events in the same order because they all come from the server host as opposed to being broadcast P2P from each player as they release them. It is noted that there is no guarantee of relative event order across different nodes in the P2P node mesh. In effect an ordering can be created by deciding that the ordering of events is the order that the server receives them. Once the server broadcasts events to the clients all server events come from the same source and are therefore guaranteed to be in the same order across all clients.

For example if the decision tree for an AI running on Client 1 decides to attack the second player character then Client 1 does not directly transfer authority to Client 2 instead Client 1 releases the authority it has over the AI asset AI back to the server host . As seen in the server host once again has authority over the AI asset AI and non authority over the first player character and the second player character . Client 1 now has authority over the first player character and non authority over the second player character and the AI asset AI. Client 2 now has authority over the second player character and non authority over the first player character and the AI asset AI.

When releasing authority over the AI asset AI Client 1 may send a hint that authority over the AI asset AI should probably transfer to Client 2 . Provided that the server host agrees with this as indicated at the server host can broadcast an authority transfer event to Client 1 and Client 2 as indicated at transferring the AI asset to run on Client 2 as indicated at . As seen in the server host once again has no authority and non authority over the AI asset AI first player character and the second player character . Client 1 now has authority over the first player character and non authority over the second player character and the AI asset AI. Client 2 now has authority over the second player character and the AI asset AI and non authority over the first player character .

As may be seen from the foregoing discussion in embodiments of the present invention AI assets can be run on the machine of the player that they are targeting. In an ideal case the AI assets with which a player is interacting e.g. engaging in combat is the set of AI assets that have already targeted him. In this best case each player feels no latency when engaging these AI assets because they are running locally on that player s machine. An example of this is depicted in .

Specifically as shown in AI assets AI AI AI AIin a simulated environment may each be in a default initial state in which the server host has authority over all of the AI assets and Client 1 and Client 2 only have authority over the first player character and second player character respectively. In this example the decision tree for a first AI asset AIdecides to target the first player character and the decision tree for a second AI asset AIdoes not target any player character. For example the second player asset AImay be in a wandering or patrolling mode. The decision trees for a third AI asset AIand a fourth AI asset AImay decide to target the second player character .

The server host may broadcast a transfer of authority over the first AI asset AIto Client 1 . The server host may similarly broadcast a transfer of authority over the third and fourth AI assets AI AIto Client 2 . All devices receive these broadcasts and act accordingly. As seen in the decision tree for the first AI asset AIruns on Client 1 which broadcasts events and state updates for the first AI asset AI. In addition the decision tree for the third and fourth AI assets AI AIrun on Client 2 which broadcasts events and state updates for these AI assets. Furthermore the decision tree for the second AI asset AIruns on the server host which broadcasts the events and state updates for this AI asset.

Embodiments of the present invention allow for a case in which a player character engages an AI asset which is not currently running on that player character s machine. This may occur because the AI asset is wandering or patrolling with default authority or because the AI asset is currently targeting another player. In this case the decision tree for the AI asset running on the current authority machine may notice the player character has attacked them and may decide to change its target to the attacking player initiating an authority transfer. In the common case this means that the attacking player may experience one lagged reaction perhaps it plays the hit reaction a bit later than normal but subsequent combat interactions with that AI become lag free once the AI transfers to their machine.

A less than optimal case may occur when two players deliberately engage the same AI simultaneously. In this case there is no way around the fact that one of the players will end up engaging an AI asset that is not running on that player s machine. As a result that player will experience some latency in reactions to the AI asset. In this case an authority arbitration rule may be used to avoid the AI oscillating authority rapidly between multiple attackers. For example that the player character with the lowest numeric player ID could be chosen as the preferred target for the AI asset.

Embodiments of the present invention can also allow program designers to control time for the AI assets over which a given player s machine has control. Typically each machine has its own independent time stream. Normally a client device would operate in its time stream and the AI would react in the server s time stream which is different from the client s time stream. As a result the time streams for the client and server are out of phase.

If instead an AI asset and a user asset are run on the same machine according to the same time stream actions for both the user asset and the AI asset take place and are broadcast according a common time stream. Consequently there is no latency problem on either the user side or spectator side.

Also by moving the AI authority to the machine of the player who is fighting the AI the designer can time scale the AI that runs on the player s machine. An example of this is illustrated in . In this example a user asset e.g. first player character and AI asset run on the same device e.g. Client device 1 . User actions may occur as indicated at and at a user time interval t. State and event updates may be broadcast for the user asset in between user actions as indicated at and . AI asset actions may occur as indicated at and at an AI asset time interval t. State and event updates may be broadcast for the AI asset in between AI actions as indicated at and . The user and AI asset time steams may be adjusted relative to each other by using different time intervals t t. Specifically the time stream for the user asset may be run faster if the user time interval tis smaller than the AI time interval t. The faster time stream for the player character gives the user a feeling of power of the circle of AI assets that are engaging that user.

It is noted that because each machine has its own independent time stream if an AI is running on a player s machine both the player and the AI react to each other in the same time stream. It follows that linked animations such as grabs throws hit reactions and attacks between player and AI assets are in phase both from the point of view of the machine running the player who is being targeted by that AI and from the point of view of a spectator. observing the player fighting the AI assets.

In some embodiments a networking update code can run at the beginning of a game frame update. The update code can select some number n most important objects to send over the network. These n objects can be selected from a set of potential objects to send which is the set of objects that machine currently has authority over. The update code can use a priority accumulator to determine the n most important objects to send. The priority accumulator can increment priority per object per node to send to unique packets can be constructed to send to each other node P2P . The priority accumulator can increase the priority of each object per node by some priority increment P for each time increment t. When an object is included in a packet and sent its priority can be set to zero. Eventually the priority for that object will bubble up to a sufficiently high value that the networking code will select it to be sent again later. The priority increment P can be scaled per object giving some objects faster priority accumulation than others. By way of example and not by way of limitation local players may have the highest priority for sends. Therefore object state updates can be distributed across the set of candidate objects to send even when there are potentially more objects to send than can fit in a single packet. Objects can be anything player character assets AI assets other objects in the world and the like. The code can be made generic such that all that is relevant to the code is the potential set of objects to send. As such the code need not distinguish between AI assets and players.

As noted above embodiments of the invention may be implemented using a P2P network. illustrates a set of information processing devices suitable for implementing a P2P network suitable for broadcasting messages according to an embodiment of the invention. The nodes of P2P network may include laptop or portable computers server computers desktop computers and workstations mobile computing devices such as mobile phones personal digital assistants portable digital media players and portable or handheld game consoles and home entertainment devices such as video game consoles digital media players set top boxes media center computers and storage devices. The network can include any number of each type of device independent of the number of devices of other types. Each device may implement the functionality of one or more nodes of the network . For each device the functionality of one or more nodes may be implemented in hardware software firmware or any combination thereof. Node functionality in software may be a part of an application a library an application programming interface and or an operating system. Furthermore each node of the network may be connected with other nodes via any type of wired or wireless network connection incorporating any type of electrical optical radio or other communications means. The network may encompass both local area networks and wide area networks such as the Internet.

In a further embodiment some devices of the network may have restricted capabilities. For example only a limited subset of nodes of the network may be allowed to initiate broadcast messages. The remaining nodes may only be permitted to forward and or process broadcast message. In still a further embodiment all or a subset of the nodes of the overlay network are capable of authenticating broadcast messages. Such a configuration may be implemented to prevent the spread of unauthorized broadcast messages. Upon receiving a broadcast message a node can first determine whether the broadcast message is authentic for example by checking a cryptographic signature. If the broadcast message is authentic it is processed and potentially forwarded to other nodes as described above. Otherwise the broadcast message may be ignored.

The network typically includes a plurality of processors and . In further embodiments network may include thousands or millions of processors. Each processor may be a microprocessor microcontroller system on a chip processor digital signal processor application specific integrated circuit ASIC programmable logic device and or any other type of information processing device. Each processor may further include one or more processing units capable of independently executing sequences of information processing instructions or processing information according to a fixed algorithm. Each processor may include local data storage as well as access to common or shared data storage.

A memory may be coupled to the CPU . The memory may store applications and data for use by the CPU . The memory may be in the form of an integrated circuit e.g. RAM DRAM ROM and the like . A computer program may be stored in the memory in the form of instructions that can be executed on the processor . The memory may store broadcast messages that have either been initiated by the program or received from other nodes. Such messages may include information relating a state or events for AI assets or user assets. The memory may also contain an authority table . The authority table contains information identifying program assets for which the processing device has authority. Such program assets can include user assets over which the processing device has exclusive authority and AI assets with transferable authority. The memory may also include one or more decision trees that determine changes in state and or events for one or more corresponding AI assets.

The program can include instructions configured for execution by the CPU . The instructions may be configured to implement a method for controlling authority over AI assets among two or more processing devices running a common program over a network . According to the method the processing device may exercise authority over the AI by executing code that controls one or more actions of the AI asset. The code may include one of the decision trees . The state of the AI asset may be broadcast from the processing device to one or more other devices running the common program over the network . When it is determined according to the decision tree that the AI asset should engage a program asset over which another processing device running the common program has authority the processing device can relinquish authority over the AI asset with the by stopping execution of the code and transferring authority over the AI asset from the first processing device to one or more other processing devices.

The program can be a program where a user e.g. a player controls some avatar object and there are other objects that are non player controlled which engage and interact directly with that player players avatar in some direct way that requires the time being in phase between the player and non player objects. By way of example and not by way of limitation the program may be part of a video game program that allows users of different peer processing devices to participate in a game online over a network. Alternatively the program may be part of a program that implements a virtual world that allows uses of different processing devices to interact with each other and with a computer simulated environment over a network of such processing devices.

The processing device may also include well known support functions such as input output I O elements power supplies P S a clock CLK and cache . The processing device may further include a storage device that provides non volatile storage for applications and data. By way of example the storage device may be a fixed disk drive removable disk drive flash memory device tape drive CD ROM DVD ROM Blu ray HD DVD UMD or other optical storage devices.

One or more user input devices may be used to communicate user inputs from one or more users to the processing device . By way of example one or more of the user input devices may be coupled to the processing device via the I O elements . Examples of suitable input device include keyboards mice joysticks touch pads touch screens light pens still or video cameras and or microphones. A network interface allows the processing device to communicate with other computer systems via an electronic communications network . The network interface may include wired or wireless communication over local area networks and wide area networks such as the Internet. The processing device may send and receive data e.g. broadcast messages in the form of one or more message packets over the network .

The processing device may further comprise a graphics subsystem which may include a graphics processing unit GPU and graphics memory . The graphics memory may include a display memory e.g. a frame buffer used for storing pixel data for each pixel of an output image. The graphics memory may be integrated in the same device as the GPU connected as a separate device with GPU and or implemented within the memory . Pixel data may be provided to the graphics memory directly from the CPU . Alternatively the CPU may provide the GPU with data and or instructions defining the desired output images from which the GPU may generate the pixel data of one or more output images. The data and or instructions defining the desired output images may be stored in memory and or graphics memory . In an embodiment the GPU may be configured e.g. by suitable programming or hardware configuration with 3D rendering capabilities for generating pixel data for output images from instructions and data defining the geometry lighting shading texturing motion and or camera parameters for a scene. The GPU may further include one or more programmable execution units capable of executing shader programs.

The program may interact with the graphics subsystem as follows. Execution of the program instructions may define and regularly update state values for user program assets AI assets and other assets. These state values may determine position orientation motion and actions for these assets. The program may convert these state values may be converted into values representing image components. These GPU may convert the image component values to pixel data for an image. The pixel data may be temporarily stored in the graphics memory .

The graphics subsystem may periodically output pixel data for an image from graphics memory to be displayed on a display device . The display device may be any device capable of displaying visual information in response to a signal from the processing device including CRT LCD plasma and OLED displays. The computer system may provide the display device with an analog or digital signal. By way of example the display may include a cathode ray tube CRT or flat panel screen that displays text numerals graphical symbols or images. In addition the display may include one or more audio speakers that produce audible or otherwise detectable sounds. To facilitate generation of such sounds the system may further include an audio processor adapted to generate analog or digital audio output from instructions and or data provided by the CPU memory and or storage .

The components of the processing device including the CPU memory support functions data storage user input devices network interface graphics subsystem and audio processor may be operably connected to each other via one or more data buses . These components may be implemented in hardware software or firmware or some combination of two or more of these.

According to another embodiment instructions for carrying out broadcasting in a peer to peer network may be stored in a computer readable storage medium. By way of example and not by way of limitation illustrates an example of a non transitory computer readable storage medium in accordance with an embodiment of the present invention. The storage medium contains computer readable instructions stored in a format that can be retrieved and interpreted by a computer processing device. By way of example and not by way of limitation the computer readable storage medium may be a computer readable memory such as random access memory RAM or read only memory ROM a computer readable storage disk for a fixed disk drive e.g. a hard disk drive or a removable disk drive. In addition the computer readable storage medium may be a flash memory device a computer readable tape a CD ROM a DVD ROM a Blu Ray HD DVD UMD or other optical storage medium.

The storage medium contains authority control instructions configured to control authority over an artificial intelligence AI asset among two or more processing devices running a common program over a network. The authority control instructions may be configured to implement broadcasting in accordance with the methods as described above with respect to through . In addition the authority control instructions may include authority exercise instructions that exercise authority over the AI asset with a first processing device when executed on a processing device. The authority exercise instructions may include decision tree instructions . The Authority control instructions may further include AI state broadcast instructions that broadcast a state of the AI asset from the first device to one or more other devices running the common program over the network when executed by the processing device.

The decision tree instructions may be configured to determine according that the AI asset should engage a program asset over which another processing device running the common program has authority when executed. This may trigger execution of one or more Instructions for Relinquishing Authority that stop execution of the authority exercise instructions and or AI state broadcast instructions and or decision tree instructions and transfer authority over the AI asset from the processing device to the other processing device.

The authority control instructions may optionally include instructions for receiving an AI state or instructions for control of a non AI user Asset. In addition the authority control instructions may also optionally include instructions for adjustment of a time stream of an AI asset e.g. as illustrated with respect to .

Although the present invention has been described in considerable detail with reference to certain preferred versions thereof other versions are possible. For example although certain embodiments are described in which the overlay is described as a Chord overlay embodiments of the invention may include implementations in which the overlay is implemented according to some other protocol. Therefore the spirit and scope of the appended claims should not be limited to the description of the preferred versions contained herein. Instead the scope of the invention should be determined with reference to the appended claims along with their full scope of equivalents.

All the features disclosed in this specification including any accompanying claims abstract and drawings may be replaced by alternative features serving the same equivalent or similar purpose unless expressly stated otherwise. Thus unless expressly stated otherwise each feature disclosed is one example only of a generic series of equivalent or similar features. Any feature whether preferred or not may be combined with any other feature whether preferred or not. In the claims that follow the indefinite article A or An refers to a quantity of one or more of the item following the article except where expressly stated otherwise. Any element in a claim that does not explicitly state means for performing a specified function is not to be interpreted as a means or step clause as specified in 35 USC 112 6. In particular the use of step of in the claims herein is not intended to invoke the provisions of 35 USC 112 6.

The reader s attention is directed to all papers and documents which are filed concurrently with this specification and which are open to public inspection with this specification and the contents of all such papers and documents incorporated herein by reference.

