---

title: Predicting or recommending a users future location based on crowd data
abstract: A system and method for predicting a future location of a user are provided. In general, a prediction basis including crowd data describing crowds in which a user was included during a number of reoccurring time windows is generated. Each reoccurring time window may be, for example, a day of the week (i.e., Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, or Sunday), a portion of a day of the week (e.g., Monday Morning, Monday Afternoon, Monday Evening, Tuesday Evening, etc.), a day of the month (e.g., 1st day of the month), a day of the year (e.g., March 25th), or the like. The prediction basis of the user is then used to predict one or more future locations of the user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08589330&OS=08589330&RS=08589330
owner: Waldeck Technology, LLC
number: 08589330
owner_city: Portsmouth
owner_country: US
publication_date: 20100303
---
This application claims the benefit of provisional patent application Ser. No. 61 163 091 filed Mar. 25 2009 the disclosure of which is hereby incorporated herein by reference in its entirety.

Various methods exist for predicting the future location of a user by using personal and private information about the user such as a location history of the user. The problem with these methods is that they all have the potential to reveal or misuse the private information of the user. As such there is a need for a system and method for predicting the future location of a user in a manner that maintains user privacy.

A system and method for predicting a future location of a user are provided. In general a prediction basis including crowd data describing crowds in which a user was included during a number of reoccurring time windows is generated. Each reoccurring time window may be for example a day of the week i.e. Monday Tuesday Wednesday Thursday Friday Saturday or Sunday a portion of a day of the week e.g. Monday Morning Monday Afternoon Monday Evening Tuesday Evening etc. a day of the month e.g. 1st day of the month a day of the year e.g. March 25th or the like. The prediction basis of the user is then used to predict one or more future locations of the user.

In one embodiment in order to predict a future location of the user current crowd data is obtained for the user where the current crowd data describes a crowd in which the user is currently included. The current crowd data of the user is then compared to at least a subset of relevant crowd data from the prediction basis in order to determine whether the user is likely to move. Specifically in one embodiment a determination is made that the user is likely to move if the current crowd data is different than the at least a subset of the relevant crowd data from the prediction basis by more than a predefined threshold degree. If a determination is made that the user is likely to move expected crowd criteria describing a type of crowd in which the user is expected to be included is generated based on the at least a subset of the relevant crowd data from the prediction basis of the user. Then one or more locations that match the expected crowd criteria are identified as the one or more future locations of the user. The one or more locations that match the expected crowd criteria may include one or more Points of Interest POIs at which crowds that match the expected crowd criteria are currently located one or more POIs at which crowds that match the expected crowd criteria are expected to be located at a future time locations of one or more crowds that currently match the expected crowd criteria or one or more crowds that are expected to match the expected crowd criteria at a future time.

Those skilled in the art will appreciate the scope of the present invention and realize additional aspects thereof after reading the following detailed description of the preferred embodiments in association with the accompanying drawing figures.

The embodiments set forth below represent the necessary information to enable those skilled in the art to practice the invention and illustrate the best mode of practicing the invention. Upon reading the following description in light of the accompanying drawing figures those skilled in the art will understand the concepts of the invention and will recognize applications of these concepts not particularly addressed herein. It should be understood that these concepts and applications fall within the scope of the disclosure and the accompanying claims.

A system and method for predicting a future location of a user are provided. In general a prediction basis including crowd data describing crowds in which a user was included during a number of reoccurring time windows is generated. Each reoccurring time window may be for example a day of the week i.e. Monday Tuesday Wednesday Thursday Friday Saturday or Sunday a portion of a day of the week e.g. Monday Morning Monday Afternoon Monday Evening Tuesday Evening etc. a day of the month e.g. 1st day of the month a day of the year e.g. March 25th or the like. The prediction basis of the user is then used to predict one or more future locations of the user.

As discussed below in detail the MAP server operates to obtain current locations including location updates and user profiles of the users through N of the mobile devices through N. The current locations of the users through N can be expressed as positional geographic coordinates such as latitude longitude pairs and a height vector if applicable or any other similar information capable of identifying a given physical point in space in a two dimensional or three dimensional coordinate system. Using the current locations and user profiles of the users through N the MAP server is enabled to provide a number of features such as but not limited to maintaining a historical record of anonymized user profile data by location generating aggregate profile data over time for a Point of Interest POI or Area of Interest AOI using the historical record of anonymized user profile data identifying crowds of users using current locations and or user profiles of the users through N generating aggregate profiles for crowds of users at a POI or in an AOI using the current user profiles of users in the crowds and crowd tracking. While not essential for additional information regarding the MAP server the interested reader is directed to U.S. patent application Ser. No. 12 645 535 entitled MAINTAINING A HISTORICAL RECORD OF ANONYMIZED USER PROFILE DATA BY LOCATION FOR USERS IN A MOBILE ENVIRONMENT U.S. patent application Ser. No. 12 645 532 entitled FORMING CROWDS AND PROVIDING ACCESS TO CROWD DATA IN A MOBILE ENVIRONMENT U.S. patent application Ser. No. 12 645 539 entitled ANONYMOUS CROWD TRACKING U.S. patent application Ser. No. 12 645 544 entitled MODIFYING A USER S CONTRIBUTION TO AN AGGREGATE PROFILE BASED ON TIME BETWEEN LOCATION UPDATES AND EXTERNAL EVENTS U.S. patent application Ser. No. 12 645 546 entitled CROWD FORMATION FOR MOBILE DEVICE USERS U.S. patent application Ser. No. 12 645 556 entitled SERVING A REQUEST FOR DATA FROM A HISTORICAL RECORD OF ANONYMIZED USER PROFILE DATA IN A MOBILE ENVIRONMENT and U.S. patent application Ser. No. 12 645 560 entitled HANDLING CROWD REQUESTS FOR LARGE GEOGRAPHIC AREAS all of which were filed on Dec. 23 2009 and are hereby incorporated herein by reference in their entireties. Note that while the MAP server is illustrated as a single server for simplicity and ease of discussion it should be appreciated that the MAP server may be implemented as a single physical server or multiple physical servers operating in a collaborative manner for purposes of redundancy and or load sharing.

In general the one or more profile servers operate to store user profiles for a number of persons including the users through N of the mobile devices through N. For example the one or more profile servers may be servers providing social network services such as the Facebook social networking service the MySpace social networking service the LinkedIN social networking service and or the like. As discussed below using the one or more profile servers the MAP server is enabled to directly or indirectly obtain the user profiles of the users through N of the mobile devices through N. The location server generally operates to receive location updates from the mobile devices through N and make the location updates available to entities such as for instance the MAP server . In one exemplary embodiment the location server is a server operating to provide Yahoo s FireEagle service. Before proceeding it should be noted that while the system of illustrates an embodiment where the one or more profile servers and the location server are separate from the MAP server the present disclosure is not limited thereto. In an alternative embodiment the functionality of the one or more profile servers and or the location server may be implemented within the MAP server .

The mobile devices through N may be mobile smart phones portable media player devices mobile gaming devices or the like. Some exemplary mobile devices that may be programmed or otherwise configured to operate as the mobile devices through N are the Apple iPhone the Palm Pre the Samsung Rogue the Blackberry Storm and the Apple iPod Touch device. However this list of exemplary mobile devices is not exhaustive and is not intended to limit the scope of the present disclosure. The mobile devices through N include MAP clients through N MAP applications through N third party applications through N and location functions through N respectively. Using the mobile device as an example the MAP client is preferably implemented in software. In general in the preferred embodiment the MAP client is a middleware layer operating to interface an application layer i.e. the MAP application and the third party applications to the MAP server . More specifically the MAP client enables the MAP application and the third party applications to request and receive data from the MAP server . It should be noted that the functionality of the MAP client may alternatively be implemented within the MAP application and the third party applications .

The MAP application is also preferably implemented in software. The MAP application generally provides a user interface component between the user and the MAP server . More specifically among other things the MAP application enables the user to initiate crowd requests for crowd data e.g. aggregate profile data and or crowd characteristics data from the MAP server for a POI or AOI and to view the corresponding crowd data received from the MAP server . The MAP application also enables the user to configure various settings. For example the MAP application may enable the user to select a desired social networking service e.g. Facebook MySpace LinkedIN etc. from which to obtain the user profile of the user and provide any necessary credentials e.g. username and password needed to access the user profile from the social networking service.

The third party applications are preferably implemented in software. The third party applications operate to access the MAP server via the MAP client . The third party applications may utilize data obtained from the MAP server in any desired manner. As an example one of the third party applications may be a gaming application that utilizes historical aggregate profile data to notify the user of POIs or AOIs where persons having an interest in the game have historically congregated. The location function may be implemented in hardware software or a combination thereof. In general the location function operates to determine or otherwise obtain the location of the mobile device . For example the location function may be or include a Global Positioning System GPS receiver.

The subscriber device is a physical device such as a personal computer a mobile computer e.g. a notebook computer a netbook computer a tablet computer etc. a mobile smart phone or the like. The subscriber associated with the subscriber device is a person or entity. In general the subscriber device enables the subscriber to access the MAP server via a web browser to obtain various types of data preferably for a fee. For example the subscriber may pay a fee to have access to historical aggregate profile data for one or more POIs and or one or more AOIs pay a fee to have access to crowd data such as aggregate profiles for crowds located at one or more POIs and or located in one or more AOIs pay a fee to track crowds or the like. Note that the web browser is exemplary. In another embodiment the subscriber device is enabled to access the MAP server via a custom application.

The prediction server is preferably a physical server that operates to predict future locations of one or more of the users through N. Preferably the prediction server hosts one or more software applications that control the prediction server to perform the functions described herein. In an alternative embodiment the functionality of the prediction server may be implemented within the MAP server . In general the prediction server monitors crowd data for the users through N during a number of reoccurring time windows to generate a prediction basis for each of the users through N. Each reoccurring time window is a time window of a defined duration that reoccurs periodically. For instance each reoccurring time window may repeat daily weekly bi weekly monthly yearly or the like. For example each reoccurring time window may be a day of the week e.g. Monday Tuesday Wednesday Thursday Friday Saturday or Sunday a portion of a day of the week e.g. Monday Morning Monday Afternoon Monday Evening Tuesday Morning Tuesday Afternoon Tuesday evening etc. a day of the month e.g. 1st day of the month a day of the year e.g. March 25th or the like. Note that the preceding examples are not intended to limit the scope of the present disclosure. The reoccurring time windows may be of any desired duration and reoccur at any desired period.

Using the user as an example the prediction server obtains crowd data for the user from the MAP server in order to generate a prediction basis for the user that includes crowd data for a number of instances of each of the reoccurring time windows. For example if one of the reoccurring time windows is Monday then the prediction basis for the user is generated to include crowd data for a crowd in which the user is or was included for each of a number of Mondays i.e. crowd data for each of a number of instances of the reoccurring Monday time window . Thereafter the prediction server predicts future locations of the user using the prediction basis of the user and additional crowd data from the MAP server as is described below in detail.

Lastly the prediction consuming application is a software application that may be implemented on a third party server not shown . Alternatively the prediction consuming application may be implemented as one of the third party applications through N or as an application hosted by the subscriber device . In general the prediction consuming application operates to request predicted location for one or more of the users through N from the prediction server . Using the user as an example in response to a request for future locations of the user the prediction server generates one or more predicted locations for the user based on the prediction basis of the user and returns the predicted locations to the prediction consuming application . The prediction consuming application may then utilize the predicted locations. The manner in which the prediction consuming application utilizes the predicted locations may vary depending on the particular implementation. For example the prediction consuming application may utilize the predicted locations to generate targeted advertisements for the user .

The focus of the present disclosure is the prediction server and manner in which the prediction server predicts future locations of one or more of the users through N. However before describing the prediction server and the operation thereof in detail a discussion of some of the functions provided by the MAP server are beneficial. As such describe some functions of the MAP server that may be utilized when predicting future locations.

The business logic layer includes a profile manager a location manager a history manager a crowd analyzer and an aggregation engine each of which is preferably implemented in software. The profile manager generally operates to obtain the user profiles of the users through N directly or indirectly from the one or more profile servers and store the user profiles in the persistence layer . The location manager operates to obtain the current locations of the users through N including location updates. As discussed below the current locations of the users through N may be obtained directly from the mobile devices through N and or obtained from the location server . The history manager generally operates to maintain a historical record of anonymized user profile data by location.

The crowd analyzer operates to form crowds of users. In one embodiment the crowd analyzer utilizes a spatial crowd formation algorithm. However the present disclosure is not limited thereto. In addition the crowd analyzer further characterize crowds to reflect for example degree of fragmentation best case and worst case degree of separation DOS and or degree of bi directionality as discussed below in more detail. Still further the crowd analyzer may also operate to track crowds. The aggregation engine generally operates to provide aggregate profile data in response to requests from the mobile devices through N and the subscriber device . The aggregate profile data may be historical aggregate profile data for one or more POIs or one or more AOIs or aggregate profile data for crowd s currently at one or more POIs or within one or more AOIs.

The persistence layer includes an object mapping layer and a datastore . The object mapping layer is preferably implemented in software. The datastore is preferably a relational database which is implemented in a combination of hardware i.e. physical data storage hardware and software i.e. relational database software . In this embodiment the business logic layer is implemented in an object oriented programming language such as for example Java. As such the object mapping layer operates to map objects used in the business logic layer to relational database entities stored in the datastore . Note that in one embodiment data is stored in the datastore in a Resource Description Framework RDF compatible format.

In an alternative embodiment rather than being a relational database the datastore may be implemented as an RDF datastore. More specifically the RDF datastore may be compatible with RDF technology adopted by Semantic Web activities. Namely the RDF datastore may use the Friend Of A Friend FOAF vocabulary for describing people their social networks and their interests. In this embodiment the MAP server may be designed to accept raw FOAF files describing persons their friends and their interests. These FOAF files are currently output by some social networking services such as Livejournal and Facebook. The MAP server may then persist RDF descriptions of the users through N as a proprietary extension of the FOAF vocabulary that includes additional properties desired for the system .

At some point after authentication is complete a user profile process is performed such that a user profile of the user is obtained from the profile server and delivered to the MAP server step . In this embodiment the MAP client of the mobile device sends a profile request to the profile server step A . In response the profile server returns the user profile of the user to the mobile device step B . The MAP client of the mobile device then sends the user profile of the user to the MAP server step C . Note that while in this embodiment the MAP client sends the complete user profile of the user to the MAP server in an alternative embodiment the MAP client may filter the user profile of the user according to criteria specified by the user . For example the user profile of the user may include demographic information general interests music interests and movie interests and the user may specify that the demographic information or some subset thereof is to be filtered or removed before sending the user profile to the MAP server .

Upon receiving the user profile of the user from the MAP client of the mobile device the profile manager of the MAP server processes the user profile step D . More specifically in the preferred embodiment the profile manager includes social network handlers for the social network services supported by the MAP server . Thus for example if the MAP server supports user profiles from Facebook MySpace and LinkedIN the profile manager may include a Facebook handler a MySpace handler and a LinkedIN handler. The social network handlers process user profiles to generate user profiles for the MAP server that include lists of keywords for each of a number of profile categories. The profile categories may be the same for each of the social network handlers or different for each of the social network handlers. Thus for this example assume that the user profile of the user is from Facebook. The profile manager uses a Facebook handler to process the user profile of the user to map the user profile of the user from Facebook to a user profile for the MAP server including lists of keywords for a number of predefined profile categories. For example for the Facebook handler the profile categories may be a demographic profile category a social interaction profile category a general interests profile category a music interests profile category and a movie interests profile category. As such the user profile of the user from Facebook may be processed by the Facebook handler of the profile manager to create a list of keywords such as for example liberal High School Graduate 35 44 College Graduate etc. for the demographic profile category a list of keywords such as Seeking Friendship for the social interaction profile category a list of keywords such as politics technology photography books etc. for the general interests profile category a list of keywords including music genres artist names album names or the like for the music interests profile category and a list of keywords including movie titles actor or actress names director names move genres or the like for the movie interests profile category. In one embodiment the profile manager may use natural language processing or semantic analysis. For example if the Facebook user profile of the user states that the user is 20 years old semantic analysis may result in the keyword of 18 24 years old being stored in the user profile of the user for the MAP server .

After processing the user profile of the user the profile manager of the MAP server stores the resulting user profile for the user step E . More specifically in one embodiment the MAP server stores user records for the users through N in the datastore . The user profile of the user is stored in the user record of the user . The user record of the user includes a unique identifier of the user the user profile of the user and as discussed below a current location of the user . Note that the user profile of the user may be updated as desired. For example in one embodiment the user profile of the user is updated by repeating step each time the user activates the MAP application .

Note that while the discussion herein focuses on an embodiment where the user profiles of the users through N are obtained from the one or more profile servers the user profiles of the users through N may be obtained in any desired manner. For example in one alternative embodiment the user may identify one or more favorite websites. The profile manager of the MAP server may then crawl the one or more favorite websites of the user to obtain keywords appearing in the one or more favorite websites of the user . These keywords may then be stored as the user profile of the user .

At some point a process is performed such that a current location of the mobile device and thus a current location of the user is obtained by the MAP server step . In this embodiment the MAP application of the mobile device obtains the current location of the mobile device from the location function of the mobile device . The MAP application then provides the current location of the mobile device to the MAP client and the MAP client then provides the current location of the mobile device to the MAP server step A . Note that step A may be repeated periodically or in response to a change in the current location of the mobile device in order for the MAP application to provide location updates for the user to the MAP server .

In response to receiving the current location of the mobile device the location manager of the MAP server stores the current location of the mobile device as the current location of the user step B . More specifically in one embodiment the current location of the user is stored in the user record of the user maintained in the datastore of the MAP server . In the preferred embodiment only the current location of the user is stored in the user record of the user . In this manner the MAP server maintains privacy for the user since the MAP server does not maintain a historical record of the location of the user . In this manner privacy of the users through N is maintained.

In addition to storing the current location of the user the location manager sends the current location of the user to the location server step C . In this embodiment by providing location updates to the location server the MAP server in return receives location updates for the user from the location server . This is particularly beneficial when the mobile device does not permit background processes which is the case for the Apple iPhone. As such if the mobile device is an Apple iPhone or similar device that does not permit background processes the MAP application will not be able to provide location updates for the user to the MAP server unless the MAP application is active.

Therefore when the MAP application is not active other applications running on the mobile device or some other device of the user may directly or indirectly provide location updates to the location server for the user . This is illustrated in step where the location server receives a location update for the user directly or indirectly from another application running on the mobile device or an application running on another device of the user step A . The location server then provides the location update for the user to the MAP server step B . In response the location manager updates and stores the current location of the user in the user record of the user step C . In this manner the MAP server is enabled to obtain location updates for the user even when the MAP application is not active at the mobile device .

At some point after authentication is complete a user profile process is performed such that a user profile of the user is obtained from the profile server and delivered to the MAP server step . In this embodiment the profile manager of the MAP server sends a profile request to the profile server step A . In response the profile server returns the user profile of the user to the profile manager of the MAP server step B . Note that while in this embodiment the profile server returns the complete user profile of the user to the MAP server in an alternative embodiment the profile server may return a filtered version of the user profile of the user to the MAP server . The profile server may filter the user profile of the user according to criteria specified by the user . For example the user profile of the user may include demographic information general interests music interests and movie interests and the user may specify that the demographic information or some subset thereof is to be filtered or removed before sending the user profile to the MAP server .

Upon receiving the user profile of the user the profile manager of the MAP server processes to the user profile step C . More specifically as discussed above in the preferred embodiment the profile manager includes social network handlers for the social network services supported by the MAP server . The social network handlers process user profiles to generate user profiles for the MAP server that include lists of keywords for each of a number of profile categories. The profile categories may be the same for each of the social network handlers or different for each of the social network handlers.

After processing the user profile of the user the profile manager of the MAP server stores the resulting user profile for the user step D . More specifically in one embodiment the MAP server stores user records for the users through N in the datastore . The user profile of the user is stored in the user record of the user . The user record of the user includes a unique identifier of the user the user profile of the user and as discussed below a current location of the user . Note that the user profile of the user may be updated as desired. For example in one embodiment the user profile of the user is updated by repeating step each time the user activates the MAP application .

Note that the while the discussion herein focuses on an embodiment where the user profiles of the users through N are obtained from the one or more profile servers the user profiles of the users through N may be obtained in any desired manner. For example in one alternative embodiment the user may identify one or more favorite websites. The profile manager of the MAP server may then crawl the one or more favorite websites of the user to obtain keywords appearing in the one or more favorite websites of the user . These keywords may then be stored as the user profile of the user .

At some point a process is performed such that a current location of the mobile device and thus a current location of the user is obtained by the MAP server step . In this embodiment the MAP application of the mobile device obtains the current location of the mobile device from the location function of the mobile device . The MAP application then provides the current location of the user of the mobile device to the location server step A . Note that step A may be repeated periodically or in response to changes in the location of the mobile device in order to provide location updates for the user to the MAP server . The location server then provides the current location of the user to the MAP server step B . The location server may provide the current location of the user to the MAP server automatically in response to receiving the current location of the user from the mobile device or in response to a request from the MAP server .

In response to receiving the current location of the mobile device the location manager of the MAP server stores the current location of the mobile device as the current location of the user step C . More specifically in one embodiment the current location of the user is stored in the user record of the user maintained in the datastore of the MAP server . Note that only the current location of the user is stored in the user record of the user . In this manner the MAP server maintains privacy for the user since the MAP server does not maintain a historical record of the location of the user . As discussed below in detail historical data maintained by the MAP server is anonymized in order to maintain the privacy of the users through N.

As discussed above the use of the location server is particularly beneficial when the mobile device does not permit background processes which is the case for the Apple iPhone. As such if the mobile device is an Apple iPhone or similar device that does not permit background processes the MAP application will not provide location updates for the user to the location server unless the MAP application is active. However other applications running on the mobile device or some other device of the user may provide location updates to the location server for the user when the MAP application is not active. This is illustrated in step where the location server receives a location update for the user from another application running on the mobile device or an application running on another device of the user step A . The location server then provides the location update for the user to the MAP server step B . In response the location manager updates and stores the current location of the user in the user record of the user step C . In this manner the MAP server is enabled to obtain location updates for the user even when the MAP application is not active at the mobile device .

Using the current locations of the users through N and the user profiles of the users through N the MAP server can provide a number of features. begins a discussion of the operation of the crowd analyzer to form crowds of users according to one embodiment of the present disclosure. Specifically is a flow chart for a spatial crowd formation process according to one embodiment of the present disclosure. Note that in one embodiment this process is performed in response to a request for crowd data i.e. reactively . In another embodiment this process may be performed proactively by the crowd analyzer as for example a background process.

First the crowd analyzer establishes a bounding box for the crowd formation process step . Note that while a bounding box is used in this example other geographic shapes may be used to define a bounding region for the crowd formation process e.g. a bounding circle . In one embodiment if crowd formation is performed in response to a specific request the bounding box is established based on the request. For example the request may identify a Point of Interest POI in which case a bounding box of a predefined size that is centered at the POI is established. As another example the request may identify an Area of Interest AOI in which case a bounding box corresponding to the AOI is established. As yet another example the request may identify a particular location in which case a bounding box of a predefined size that is centered at that location is established. Alternatively if the crowd formation process is performed proactively the bounding box is a bounding box of a predefined size.

The crowd analyzer then creates a crowd for each individual user in the bounding box step . More specifically the crowd analyzer queries the datastore of the MAP server to identify users currently located within the bounding box. Then a crowd of one user is created for each user currently located within the bounding box. Next the crowd analyzer determines the two closest crowds in the bounding box step and determines a distance between the two crowds step . The distance between the two crowds is a distance between crowd centers of the two crowds. Note that the crowd center of a crowd of one is the current location of the user in the crowd. The crowd analyzer then determines whether the distance between the two crowds is less than an optimal inclusion distance step . In this embodiment the optimal inclusion distance is a predefined static distance. If the distance between the two crowds is less than the optimal inclusion distance the crowd analyzer combines the two crowds step and computes a new crowd center for the resulting crowd step . The crowd center may be computed based on the current locations of the users in the crowd using a center of mass algorithm. At this point the process returns to step and is repeated until the distance between the two closest crowds is not less than the optimal inclusion distance. At that point the crowd analyzer discards any crowds with less than three users step . Note that throughout this disclosure crowds are only maintained if the crowds include three or more users. However while three users is the preferred minimum number of users in a crowd the present disclosure is not limited thereto. The minimum number of users in a crowd may be defined as any number greater than or equal to two users.

Next the crowd analyzer determines whether the new and old bounding boxes overlap step . If so the crowd analyzer creates a bounding box encompassing the new and old bounding boxes step . For example if the new and old bounding boxes are 40 40 meter regions and a 1 1 meter square at the northeast corner of the new bounding box overlaps a 1 1 meter square at the southwest corner of the old bounding box the crowd analyzer may create a 79 79 meter square bounding box encompassing both the new and old bounding boxes.

The crowd analyzer then determines the individual users and crowds relevant to the bounding box created in step step . The crowds relevant to the bounding box are crowds that are within or overlap the bounding box e.g. have at least one user located within the bounding box . The individual users relevant to the bounding box are users that are currently located within the bounding box and not already part of a crowd. Next the crowd analyzer computes an optimal inclusion distance for individual users based on user density within the bounding box step . More specifically in one embodiment the optimal inclusion distance for individuals which is also referred to herein as an initial optimal inclusion distance is set according to the following equation 

The crowd analyzer then creates a crowd for each individual user within the bounding box that is not already included in a crowd and sets the optimal inclusion distance for the crowds to the initial optimal inclusion distance step . At this point the process proceeds to where the crowd analyzer analyzes the crowds relevant to the bounding box to determine whether any of the crowd members i.e. users in the crowds violate the optimal inclusion distance of their crowds step . Any crowd member that violates the optimal inclusion distance of his or her crowd is then removed from that crowd step . The crowd analyzer then creates a crowd of one user for each of the users removed from their crowds in step and sets the optimal inclusion distance for the newly created crowds to the initial optimal inclusion distance step .

Next the crowd analyzer determines the two closest crowds for the bounding box step and a distance between the two closest crowds step . The distance between the two closest crowds is the distance between the crowd centers of the two closest crowds. The crowd analyzer then determines whether the distance between the two closest crowds is less than the optimal inclusion distance of a larger of the two closest crowds step . If the two closest crowds are of the same size i.e. have the same number of users then the optimal inclusion distance of either of the two closest crowds may be used. Alternatively if the two closest crowds are of the same size the optimal inclusion distances of both of the two closest crowds may be used such that the crowd analyzer determines whether the distance between the two closest crowds is less than the optimal inclusion distances of both of the two closest crowds. As another alternative if the two closest crowds are of the same size the crowd analyzer may compare the distance between the two closest crowds to an average of the optimal inclusion distances of the two closest crowds.

If the distance between the two closest crowds is less than the optimal inclusion distance the two closest crowds are combined or merged step and a new crowd center for the resulting crowd is computed step . Again a center of mass algorithm may be used to compute the crowd center of a crowd. In addition a new optimal inclusion distance for the resulting crowd is computed step . In one embodiment the new optimal inclusion distance for the resulting crowd is computed as 

At this point the crowd analyzer determines whether a maximum number of iterations have been performed step . The maximum number of iterations is a predefined number that ensures that the crowd formation process does not indefinitely loop over steps through or loop over steps through more than a desired maximum number of times. If the maximum number of iterations has not been reached the process returns to step and is repeated until either the distance between the two closest crowds is not less than the optimal inclusion distance of the larger crowd or the maximum number of iterations has been reached. At that point the crowd analyzer discards crowds with less than three users or members step and the process ends.

Returning to step in if the new and old bounding boxes do not overlap the process proceeds to and the bounding box to be processed is set to the old bounding box step . In general the crowd analyzer then processes the old bounding box in much the same manner as described above with respect to steps through . More specifically the crowd analyzer determines the individual users and crowds relevant to the bounding box step . The crowds relevant to the bounding box are crowds that are within or overlap the bounding box e.g. have at least one user located within the bounding box . The individual users relevant to the bounding box are users that are currently located within the bounding box and not already part of a crowd. Next the crowd analyzer computes an optimal inclusion distance for individual users based on user density within the bounding box step . More specifically in one embodiment the optimal inclusion distance for individuals which is also referred to herein as an initial optimal inclusion distance is set according to the following equation 

The crowd analyzer then creates a crowd of one user for each individual user within the bounding box that is not already included in a crowd and sets the optimal inclusion distance for the crowds to the initial optimal inclusion distance step . At this point the crowd analyzer analyzes the crowds for the bounding box to determine whether any crowd members i.e. users in the crowds violate the optimal inclusion distance of their crowds step . Any crowd member that violates the optimal inclusion distance of his or her crowd is then removed from that crowd step . The crowd analyzer then creates a crowd of one user for each of the users removed from their crowds in step and sets the optimal inclusion distance for the newly created crowds to the initial optimal inclusion distance step .

Next the crowd analyzer determines the two closest crowds in the bounding box step and a distance between the two closest crowds step . The distance between the two closest crowds is the distance between the crowd centers of the two closest crowds. The crowd analyzer then determines whether the distance between the two closest crowds is less than the optimal inclusion distance of a larger of the two closest crowds step . If the two closest crowds are of the same size i.e. have the same number of users then the optimal inclusion distance of either of the two closest crowds may be used. Alternatively if the two closest crowds are of the same size the optimal inclusion distances of both of the two closest crowds may be used such that the crowd analyzer determines whether the distance between the two closest crowds is less than the optimal inclusion distances of both of the two closest crowds. As another alternative if the two closest crowds are of the same size the crowd analyzer may compare the distance between the two closest crowds to an average of the optimal inclusion distances of the two closest crowds.

If the distance between the two closest crowds is less than the optimal inclusion distance the two closest crowds are combined or merged step and a new crowd center for the resulting crowd is computed step . Again a center of mass algorithm may be used to compute the crowd center of a crowd. In addition a new optimal inclusion distance for the resulting crowd is computed step . As discussed above in one embodiment the new optimal inclusion distance for the resulting crowd is computed as 

At this point the crowd analyzer determines whether a maximum number of iterations have been performed step . If the maximum number of iterations has not been reached the process returns to step and is repeated until either the distance between the two closest crowds is not less than the optimal inclusion distance of the larger crowd or the maximum number of iterations has been reached. At that point the crowd analyzer discards crowds with less than three users or members step . The crowd analyzer then determines whether the crowd formation process for the new and old bounding boxes is done step . In other words the crowd analyzer determines whether both the new and old bounding boxes have been processed. If not the bounding box is set to the new bounding box step and the process returns to step and is repeated for the new bounding box. Once both the new and old bounding box have been processed the crowd formation process ends.

The crowd analyzer then identifies the two closest crowds and in the bounding box and determines a distance between the two closest crowds and . In this example the distance between the two closest crowds and is less than the optimal inclusion distance. As such the two closest crowds and are merged and a new crowd center and new optimal inclusion distance are computed as illustrated in . The crowd analyzer then repeats the process such that the two closest crowds and in the bounding box are again merged as illustrated in . At this point the distance between the two closest crowds and is greater than the appropriate optimal inclusion distance. As such the crowd formation process is complete.

Since the old bounding box and the new bounding box overlap the crowd analyzer creates a bounding box that encompasses both the old bounding box and the new bounding box as illustrated in . In addition the crowd analyzer creates crowds through for individual users currently located within the bounding box . The optimal inclusion distances of the crowds through are set to the initial optimal inclusion distance computed by the crowd analyzer based on the density of users in the bounding box .

Next the crowd analyzer analyzes the crowds and through to determine whether any members of the crowds and through violate the optimal inclusion distances of the crowds and through . In this example as a result of the user leaving the crowd and moving to his new location both of the remaining members of the crowd violate the optimal inclusion distance of the crowd . As such the crowd analyzer removes the remaining users from the crowd and creates crowds and of one user each for those users as illustrated in .

The crowd analyzer then identifies the two closest crowds in the bounding box which in this example are the crowds and . Next the crowd analyzer computes a distance between the two crowds and . In this example the distance between the two crowds and is less than the initial optimal inclusion distance and as such the two crowds and are combined. In this example crowds are combined by merging the smaller crowd into the larger crowd. Since the two crowds and are of the same size the crowd analyzer merges the crowd into the crowd as illustrated in . A new crowd center and new optimal inclusion distance are then computed for the crowd .

At this point the crowd analyzer repeats the process and determines that the crowds and are now the two closest crowds. In this example the distance between the two crowds and is less than the optimal inclusion distance of the larger of the two crowds and which is the crowd . As such the crowd is merged into the crowd and a new crowd center and optimal inclusion distance are computed for the crowd as illustrated in . At this point there are no two crowds closer than the optimal inclusion distance of the larger of the two crowds. As such the crowd analyzer discards any crowds having less than three members as illustrated in . In this example the crowds and have less than three members and are therefore removed. The crowd has three or more members and as such is not removed. At this point the crowd formation process is complete.

More specifically as illustrated in as a result of the movement of the user from the old location to the new location the remaining users in the crowd no longer satisfy the optimal inclusion distance for the crowd . As such the remaining users in the crowd are removed from the crowd and crowds and of one user each are created for the removed users as shown in . In this example no two crowds in the old bounding box are close enough to be combined. As such processing of the old bounding box is complete and the crowd analyzer proceeds to process the new bounding box .

As illustrated in processing of the new bounding box begins by the crowd analyzer creating a crowd of one user for the user. The crowd analyzer then identifies the crowds and as the two closest crowds in the new bounding box and determines a distance between the two crowds and . In this example the distance between the two crowds and is less than the optimal inclusion distance of the larger crowd which is the crowd . As such the crowd analyzer combines the crowds and by merging the crowd into the crowd as illustrated in . A new crowd center and new optimal inclusion distance are then computed for the crowd . At this point the crowd formation process is complete.

Before proceeding a variation of the spatial formation process discussed above with respect to A through D A through F and A through E will be described. In this alternative embodiment a location accuracy of the location update from the user received in step is considered. More specifically in step the location update received by the MAP server includes the updated location of the user as well as a location accuracy for the location of the user which may be expressed as for example a radius in meters from the location of the user . In the embodiment where the location of the user is obtained from a GPS receiver of the mobile device the location accuracy of the location of the user may be provided by the GPS receiver or derived from data from the GPS receiver as well be appreciated by one having ordinary skill in the art.

Then in steps and sizes of the new and old bounding boxes centered at the new and old locations of the user are set as a function of the location accuracy of the new and old locations of the user . If the new location of the user is inaccurate then the new bounding box will be large. If the new location of the user is accurate then the new bounding box will be small. For example the length and width of the new bounding box may be set to M times the location accuracy of the new location of the user where the location accuracy is expressed as a radius in meters from the new location of the user . The number M may be any desired number. For example the number M may be 5. In a similar manner the location accuracy of the old location of the user may be used to set the length and width of the old bounding box.

In addition the location accuracy may be considered when computing the initial optimal inclusion distances used for crowds of one user in steps and . As discussed above the initial optimal inclusion distance is computed based on the following equation 

Likewise when new optimal inclusion distances for crowds are recomputed in steps and location accuracy may also be considered. As discussed above the new optimal inclusion distance may first be computed based on the following equation 

First the MAP application sends a crowd request to the MAP client step . The crowd request is a request for crowd data for crowds currently formed near a specified POI or within a specified AOI. The crowd request may be initiated by the user of the mobile device via the MAP application or may be initiated automatically by the MAP application in response to an event such as for example start up of the MAP application movement of the user or the like. In one embodiment the crowd request is for a POI where the POI is a POI corresponding to the current location of the user a POI selected from a list of POIs defined by the user a POI selected from a list of POIs defined by the MAP application or the MAP server a POI selected by the user from a map a POI implicitly defined via a separate application e.g. POI is implicitly defined as the location of the nearest Starbucks coffee house in response to the user performing a Google search for Starbucks or the like. If the POI is selected from a list of POIs the list of POIs may include static POIs which may be defined by street addresses or latitude and longitude coordinates dynamic POIs which may be defined as the current locations of one or more friends of the user or both. Note that in some embodiments the user may be enabled to define a POI by selecting a crowd center of a crowd as a POI where the POI would thereafter remain static at that point and would not follow the crowd.

In another embodiment the crowd request is for an AOI where the AOI may be an AOI of a predefined shape and size centered at the current location of the user an AOI selected from a list of AOIs defined by the user an AOI selected from a list of AOIs defined by the MAP application or the MAP server an AOI selected by the user from a map an AOI implicitly defined via a separate application e.g. AOI is implicitly defined as an area of a predefined shape and size centered at the location of the nearest Starbucks coffee house in response to the user performing a Google search for Starbucks or the like. If the AOI is selected from a list of AOIs the list of AOIs may include static AOIs dynamic AOIs which may be defined as areas of a predefined shape and size centered at the current locations of one or more friends of the user or both. Note that in some embodiments the user may be enabled to define an AOI by selecting a crowd such that an AOI is created of a predefined shape and size centered at the crowd center of the selected crowd. The AOI would thereafter remain static and would not follow the crowd. The POI or the AOI of the crowd request may be selected by the user via the MAP application . In yet another embodiment the MAP application automatically uses the current location of the user as the POI or as a center point for an AOI of a predefined shape and size.

Upon receiving the crowd request the MAP client forwards the crowd request to the MAP server step . Note that in some embodiments the MAP client may process the crowd request before forwarding the crowd request to the MAP server . For example in some embodiments the crowd request may include more than one POI or more than one AOI. As such the MAP client may generate a separate crowd request for each POI or each AOI.

In response to receiving the crowd request from the MAP client the MAP server identifies one or more crowds relevant to the crowd request step . More specifically in one embodiment the crowd analyzer performs a crowd formation process such as that described above in to form one or more crowds relevant to the POI or the AOI of the crowd request. In another embodiment the crowd analyzer proactively forms crowds using a process such as that described above in and stores corresponding crowd records in the datastore of the MAP server . Then rather than forming the relevant crowds in response to the crowd request the crowd analyzer queries the datastore to identify the crowds that are relevant to the crowd request. The crowds relevant to the crowd request may be those crowds within or intersecting a bounding region such as a bounding box for the crowd request. If the crowd request is for a POI the bounding region is a geographic region of a predefined shape and size centered at the POI. If the crowd request is for an AOI the bounding region is the AOI.

Once the crowd analyzer has identified the crowds relevant to the crowd request the MAP server generates crowd data for the identified crowds step . The crowd data for the identified crowds may include aggregate profiles for the crowds information characterizing the crowds or both. In addition the crowd data may include spatial information defining the locations of the crowds the number of users in the crowds the amount of time the crowds have been located at or near the POI or within the AOI of the crowd request or the like. The MAP server then returns the crowd data to the MAP client step .

Upon receiving the crowd data the MAP client forwards the crowd data to the MAP application step . Note that in some embodiments the MAP client may process the crowd data before sending the crowd data to the MAP application . The MAP application then presents the crowd data to the user step . The manner in which the crowd data is presented depends on the particular implementation of the MAP application . In one embodiment the crowd data is overlaid upon a map. For example the crowds may be represented by corresponding indicators overlaid on a map. The user may then select a crowd in order to view additional crowd data regarding that crowd such as for example the aggregate profile of that crowd characteristics of that crowd or the like.

Note that in one embodiment the MAP application may operate to roll up the aggregate profiles for multiple crowds into a rolled up aggregate profile for those crowds. The rolled up aggregate profile may be the average of the aggregate profiles of the crowds. For example the MAP application may roll up the aggregate profiles for multiple crowds at a POI and present the rolled up aggregate profile for the multiple crowds at the POI to the user . In a similar manner the MAP application may provide a rolled up aggregate profile for an AOI. In another embodiment the MAP server may roll up crowds for a POI or an AOI and provide the rolled up aggregate profile in addition to or as an alternative to the aggregate profiles for the individual crowds.

Each of the user records includes an ID field a location field a profile field a crowd field and a previous crowd field. The ID field stores a unique ID for one of the users through N for which the user record is stored. The location field stores the current location of the user which may be defined by latitude and longitude coordinates and optionally an altitude. The profile field stores the user profile of the user which may be defined as a list of keywords for one or more profile categories. The crowd field is used to store a reference to a crowd record of a crowd of which the user is currently a member. The previous crowd field may be used to store a reference to a crowd record of a crowd of which the user was previously a member.

Each of the crowd snapshot records includes an anonymous users field a NE corner field a SW corner field a center field a sample time field a vertices field a crowd size field and one or more crowd characteristics fields. The anonymous users field stores a set or list of anonymous user records which are anonymized versions of the user records for the users that are in the crowd at a time the crowd snapshot was created. The NE corner field stores a location corresponding to a NE corner of a bounding box for the crowd at the time the crowd snapshot was created. The NE corner may be defined by latitude and longitude coordinates and optionally an altitude. Similarly the SW corner field stores a location of a SW corner of the bounding box for the crowd at the time the crowd snapshot was created. Like the NE corner the SW corner may be defined by latitude and longitude coordinates and optionally an altitude. The center field stores a location corresponding to a center of the crowd at the time the crowd snapshot was created. The center of the crowd may be defined by latitude and longitude coordinates and optionally an altitude. Together the NE corner the SW corner and the center of the crowd form spatial information defining the location of the crowd at the time the crowd snapshot was created. Note however that the spatial information defining the location of the crowd at the time the crowd snapshot was created may include additional or alternative information depending on the particular implementation. The sample time field stores a timestamp indicating a time at which the crowd snapshot was created. The timestamp preferably includes a date and a time of day at which the crowd snapshot was created. The vertices field stores locations of users in the crowd at the time the crowd snapshot was created that define an actual outer boundary of the crowd e.g. as a polygon at the time the crowd snapshot was created. Note that the actual outer boundary of a crowd may be used to show the location of the crowd when displayed to a user. The crowd size field store a size of the crowd i.e. the number of users in the crowd at the time the crowd snapshot was created. The one or more crowd characteristics fields may store one or more characteristics of the crowd at the time the crowd snapshot was created such as for example best case and or worst case average Degree of Separation DOS for the crowd a degree of fragmentation of the crowd a degree of bi directionality of relationship for the crowd or the like.

Each of the anonymous user records includes an anonymous ID field and a profile field. The anonymous ID field stores an anonymous user ID which is preferably a unique user ID that is not tied or linked back to any of the users through N and particularly not tied back to the user or the user record for which the anonymous user record has been created. In one embodiment the anonymous user records for a crowd snapshot record are anonymized versions of the user records of the users in the crowd at the time the crowd snapshot was created. The profile field stores the anonymized user profile of the anonymous user which may be defined as a list of keywords for one or more profile categories. The manner in which the user records are anonymized to create the anonymous user records is described below in detail.

Next the crowd analyzer determines whether the new and old bounding boxes overlap step . If so the crowd analyzer creates a bounding box encompassing the new and old bounding boxes step . The crowd analyzer then determines the individual users and crowds relevant to the bounding box created in step step . Next the crowd analyzer computes an optimal inclusion distance for individual users based on user density within the bounding box step . The optimal inclusion distance may be computed as described above with respect to step of .

The crowd analyzer then creates a crowd of one user for each individual user within the bounding box established in step that is not already included in a crowd and sets the optimal inclusion distance for those crowds to the initial optimal inclusion distance step . The crowds created for the individual users are temporary crowds created for purposes of performing the crowd formation process. At this point the process proceeds to where the crowd analyzer analyzes the crowds in the bounding box established in step to determine whether any of the crowd members i.e. users in the crowds violate the optimal inclusion distance of their crowds step . Any crowd member that violates the optimal inclusion distance of his or her crowd is then removed from that crowd and the previous crowd fields in the corresponding user records are set step . More specifically in this embodiment a member is removed from a crowd by removing the user record of the member from the set or list of user records in the crowd record of the crowd and setting the previous crowd stored in the user record of the user to the crowd from which the member has been removed. The crowd analyzer then creates a crowd of one user for each of the users removed from their crowds in step and sets the optimal inclusion distance for the newly created crowds to the initial optimal inclusion distance step .

Next the crowd analyzer determines the two closest crowds in the bounding box step and a distance between the two closest crowds step . The crowd analyzer then determines whether the distance between the two closest crowds is less than the optimal inclusion distance of a larger of the two closest crowds step . If the two closest crowds are of the same size i.e. have the same number of users then the optimal inclusion distance of either of the two closest crowds may be used. Alternatively if the two closest crowds are of the same size the optimal inclusion distances of both of the two closest crowds may be used such that the crowd analyzer determines whether the distance between the two closest crowds is less than the optimal inclusion distances of both of the crowds. As another alternative if the two closest crowds are of the same size the crowd analyzer may compare the distance between the two closest crowds to an average of the optimal inclusion distances of the two crowds.

If the distance between the two closest crowds is greater than the optimal inclusion distance the process proceeds to step . However if the distance between the two closest crowds is less than the optimal inclusion distance the two crowds are merged step . The manner in which the two crowds are merged differs depending on whether the two crowds are pre existing crowds or temporary crowds created for the spatial crowd formation process. If both crowds are pre existing crowds one of the two crowds is selected as a non surviving crowd and the other is selected as a surviving crowd. If one crowd is larger than the other the smaller crowd is selected as the non surviving crowd and the larger crowd is selected as a surviving crowd. If the two crowds are of the same size one of the crowds is selected as the surviving crowd and the other crowd is selected as the non surviving crowd using any desired technique. The non surviving crowd is then merged into the surviving crowd by adding the set or list of user records for the non surviving crowd to the set or list of user records for the surviving crowd and setting the merged into field of the non surviving crowd to a reference to the crowd record of the surviving crowd. In addition the crowd analyzer sets the previous crowd fields of the user records in the set or list of user records from the non surviving crowd to a reference to the crowd record of the non surviving crowd.

If one of the crowds is a temporary crowd and the other crowd is a pre existing crowd the temporary crowd is selected as the non surviving crowd and the pre existing crowd is selected as the surviving crowd. The non surviving crowd is then merged into the surviving crowd by adding the set or list of user records from the crowd record of the non surviving crowd to the set or list of user records in the crowd record of the surviving crowd. However since the non surviving crowd is a temporary crowd the previous crowd field s of the user record s of the user s in the non surviving crowd are not set to a reference to the crowd record of the non surviving crowd. Similarly the crowd record of the temporary record may not have a merged into field but if it does the merged into field is not set to a reference to the surviving crowd.

If both the crowds are temporary crowds one of the two crowds is selected as a non surviving crowd and the other is selected as a surviving crowd. If one crowd is larger than the other the smaller crowd is selected as the non surviving crowd and the larger crowd is selected as a surviving crowd. If the two crowds are of the same size one of the crowds is selected as the surviving crowd and the other crowd is selected as the non surviving crowd using any desired technique. The non surviving crowd is then merged into the surviving crowd by adding the set or list of user records for the non surviving crowd to the set or list of user records for the surviving crowd. However since the non surviving crowd is a temporary crowd the previous crowd field s of the user record s of the user s in the non surviving crowd are not set to a reference to the crowd record of the non surviving crowd. Similarly the crowd record of the temporary record may not have a merged into field but if it does the merged into field is not set to a reference to the surviving crowd.

Next the crowd analyzer removes the non surviving crowd step . In this embodiment the manner in which the non surviving crowd is removed depends on whether the non surviving crowd is a pre existing crowd or a temporary crowd. If the non surviving crowd is a pre existing crowd the removal process is performed by removing or nulling the users field the NE corner field the SW corner field and the center field of the crowd record of the non surviving crowd. In this manner the spatial information for the non surviving crowd is removed from the corresponding crowd record such that the non surviving or removed crowd will no longer be found in response to spatial based queries on the datastore . However the crowd snapshots for the non surviving crowd are still available via the crowd record for the non surviving crowd. In contrast if the non surviving crowd is a temporary crowd the crowd analyzer may remove the crowd by deleting the corresponding crowd record.

The crowd analyzer also computes a new crowd center for the surviving crowd step . Again a center of mass algorithm may be used to compute the crowd center of a crowd. In addition a new optimal inclusion distance for the surviving crowd is computed step . In one embodiment the new optimal inclusion distance for the surviving crowd is computed in the manner described above with respect to step of .

At this point the crowd analyzer determines whether a maximum number of iterations have been performed step . If the maximum number of iterations has not been reached the process returns to step and is repeated until either the distance between the two closest crowds is not less than the optimal inclusion distance of the larger crowd or the maximum number of iterations has been reached. At that point the crowd analyzer removes crowds with less than three users or members step and the process ends. As discussed above in this embodiment the manner in which a crowd is removed depends on whether the crowd is a pre existing crowd or a temporary crowd. If the crowd is a pre existing crowd a removal process is performed by removing or nulling the users field the NE corner field the SW corner field and the center field of the crowd record of the crowd. In this manner the spatial information for the crowd is removed from the corresponding crowd record such that the crowd will no longer be found in response to spatial based queries on the datastore . However the crowd snapshots for the crowd are still available via the crowd record for the crowd. In contrast if the crowd is a temporary crowd the crowd analyzer may remove the crowd by deleting the corresponding crowd record. In this manner crowds having less than three members are removed in order to maintain privacy of individuals as well as groups of two users e.g. a couple .

Returning to step in if the new and old bounding boxes do not overlap the process proceeds to and the bounding box to be processed is set to the old bounding box step . In general the crowd analyzer then processes the old bounding box in much that same manner as described above with respect to steps through . More specifically the crowd analyzer determines the individual users and crowds relevant to the bounding box step . Again note that the crowds relevant to the bounding box are pre existing crowds resulting from previous iterations of the spatial crowd formation process. Next the crowd analyzer computes an optimal inclusion distance for individual users based on user density within the bounding box step . The optimal inclusion distance may be computed as described above with respect to step of .

The crowd analyzer then creates a crowd of one user for each individual user within the bounding box that is not already included in a crowd and sets the optimal inclusion distance for the crowds to the initial optimal inclusion distance step . The crowds created for the individual users are temporary crowds created for purposes of performing the crowd formation process. At this point the crowd analyzer analyzes the crowds in the bounding box to determine whether any crowd members i.e. users in the crowds violate the optimal inclusion distance of their crowds step . Any crowd member that violates the optimal inclusion distance of his or her crowd is then removed from that crowd and the previous crowd fields in the corresponding user records are set step . More specifically in this embodiment a member is removed from a crowd by removing the user record of the member from the set or list of user records in the crowd record of the crowd and setting the previous crowd stored in the user record of the user to the crowd from which the member has been removed. The crowd analyzer then creates a crowd for each of the users removed from their crowds in step and sets the optimal inclusion distance for the newly created crowds to the initial optimal inclusion distance step .

Next the crowd analyzer determines the two closest crowds in the bounding box step and a distance between the two closest crowds step . The distance between the two closest crowds is the distance between the crowd centers of the two closest crowds. The crowd analyzer then determines whether the distance between the two closest crowds is less than the optimal inclusion distance of a larger of the two closest crowds step . If the two closest crowds are of the same size i.e. have the same number of users then the optimal inclusion distance of either of the two closest crowds may be used. Alternatively if the two closest crowds are of the same size the optimal inclusion distances of both of the two closest crowds may be used such that the crowd analyzer determines whether the distance between the two closest crowds is less than the optimal inclusion distances of both of the two closest crowds. As another alternative if the two closest crowds are of the same size the crowd analyzer may compare the distance between the two closest crowds to an average of the optimal inclusion distances of the two closest crowds.

If the distance between the two closest crowds is greater than the optimal inclusion distance the process proceeds to step . However if the distance between the two closest crowds is less than the optimal inclusion distance the two crowds are merged step . The manner in which the two crowds are merged differs depending on whether the two crowds are pre existing crowds or temporary crowds created for the spatial crowd formation process. If both crowds are pre existing crowds one of the two crowds is selected as a non surviving crowd and the other is selected as a surviving crowd. If one crowd is larger than the other the smaller crowd is selected as the non surviving crowd and the larger crowd is selected as a surviving crowd. If the two crowds are of the same size one of the crowds is selected as the surviving crowd and the other crowd is selected as the non surviving crowd using any desired technique. The non surviving crowd is then merged into the surviving crowd by adding the set or list of user records for the non surviving crowd to the set or list of user records for the surviving crowd and setting the merged into field of the non surviving crowd to a reference to the crowd record of the surviving crowd. In addition the crowd analyzer sets the previous crowd fields of the set or list of user records from the non surviving crowd to a reference to the crowd record of the non surviving crowd.

If one of the crowds is a temporary crowd and the other crowd is a pre existing crowd the temporary crowd is selected as the non surviving crowd and the pre existing crowd is selected as the surviving crowd. The non surviving crowd is then merged into the surviving crowd by adding the user records from the set or list of user records from the crowd record of the non surviving crowd to the set or list of user records in the crowd record of the surviving crowd. However since the non surviving crowd is a temporary crowd the previous crowd field s of the user record s of the user s in the non surviving crowd are not set to a reference to the crowd record of the non surviving crowd. Similarly the crowd record of the temporary record may not have a merged into field but if it does the merged into field is not set to a reference to the surviving crowd.

If both the crowds are temporary crowds one of the two crowds is selected as a non surviving crowd and the other is selected as a surviving crowd. If one crowd is larger than the other the smaller crowd is selected as the non surviving crowd and the larger crowd is selected as a surviving crowd. If the two crowds are of the same size one of the crowds is selected as the surviving crowd and the other crowd is selected as the non surviving crowd using any desired technique. The non surviving crowd is then merged into the surviving crowd by adding the set or list of user records for the non surviving crowd to the set or list of user records for the surviving crowd. However since the non surviving crowd is a temporary crowd the previous crowd field s of the user record s of the user s in the non surviving crowd are not set to a reference to the crowd record of the non surviving crowd. Similarly the crowd record of the temporary record may not have a merged into field but if it does the merged into field is not set to a reference to the surviving crowd.

Next the crowd analyzer removes the non surviving crowd step . In this embodiment the manner in which the non surviving crowd is removed depends on whether the non surviving crowd is a pre existing crowd or a temporary crowd. If the non surviving crowd is a pre existing crowd the removal process is performed by removing or nulling the users field the NE corner field the SW corner field and the center field of the crowd record of the non surviving crowd. In this manner the spatial information for the non surviving crowd is removed from the corresponding crowd record such that the non surviving or removed crowd will no longer be found in response to spatial based queries on the datastore . However the crowd snapshots for the non surviving crowd are still available via the crowd record for the non surviving crowd. In contrast if the non surviving crowd is a temporary crowd the crowd analyzer may remove the crowd by deleting the corresponding crowd record.

The crowd analyzer also computes a new crowd center for the surviving crowd step . Again a center of mass algorithm may be used to compute the crowd center of a crowd. In addition a new optimal inclusion distance for the surviving crowd is computed step . In one embodiment the new optimal inclusion distance for the surviving crowd is computed in the manner described above with respect to step of .

At this point the crowd analyzer determines whether a maximum number of iterations have been performed step . If the maximum number of iterations has not been reached the process returns to step and is repeated until either the distance between the two closest crowds is not less than the optimal inclusion distance of the larger crowd or the maximum number of iterations has been reached. At that point the crowd analyzer removes crowds with less than three users or members step . As discussed above in this embodiment the manner in which a crowd is removed depends on whether the crowd is a pre existing crowd or a temporary crowd. If the crowd is a pre existing crowd a removal process is performed by removing or nulling the users field the NE corner field the SW corner field and the center field of the crowd record of the crowd. In this manner the spatial information for the crowd is removed from the corresponding crowd record such that the crowd will no longer be found in response to spatial based queries on the datastore . However the crowd snapshots for the crowd are still available via the crowd record for the crowd. In contrast if the crowd is a temporary crowd the crowd analyzer may remove the crowd by deleting the corresponding crowd record. In this manner crowds having less than three members are removed in order to maintain privacy of individuals as well as groups of two users e.g. a couple .

The crowd analyzer then determines whether the crowd formation process for the new and old bounding boxes is done step . In other words the crowd analyzer determines whether both the new and old bounding boxes have been processed. If not the bounding box is set to the new bounding box step and the process returns to step and is repeated for the new bounding box. Once both the new and old bounding boxes have been processed the crowd formation process ends.

Next the crowd analyzer determines whether there are any crowd change events step . If not the process ends. Otherwise the crowd analyzer gets the next crowd change event step and generates a crowd snapshot for a corresponding crowd step . More specifically the crowd change event identifies a crowd record stored for a crowd for which the crowd change event was detected. A crowd snapshot is then created for that crowd by creating a new crowd snapshot record for the crowd and adding the new crowd snapshot to the list of crowd snapshots stored in the crowd record for the crowd.

In order to create the crowd snapshot for the crowd the crowd analyzer anonymizes the user records for the users in the crowd at the current time i.e. the time of creating the crowd snapshot to provide a set or list of anonymized user records that is to be stored in the crowd snapshot. Anonymization maintains the privacy of the users in the crowd. graphically illustrates one embodiment of the anonymization process. In this embodiment anonymization is performed by creating anonymous user records for the users in the list of users from the crowd record of the crowd. The anonymous user records are not connected back to the users through N. More specifically as illustrated in each user in the list of users for the crowd has a corresponding user record . The user record includes a unique user identifier ID for the user the current location of the user and the user profile of the user. The user record may include additional fields such as for example a current crowd field and a previous crowd field as discussed above with respect to . The user profile includes keywords for each of a number of profile categories which are stored in corresponding profile category records through M. Each of the profile category records through M includes a user ID for the corresponding user which may be the same user ID used in the user record a category ID and a list of keywords for the profile category.

For anonymization an anonymous user record is created from the user record . In the anonymous user record the user ID is replaced with a new user ID that is not connected back to the user which is also referred to herein as an anonymous user ID. This new user ID is preferably different than any other user ID used for anonymous user records created from the user record of the user for any previous or subsequent crowd snapshots. In this manner anonymous user records for a single user created over time cannot be linked to one another.

In addition anonymous profile category records through M are created for the profile category records through M. In the anonymous profile category records through M the user ID is replaced with a new user ID which may be the same new user ID included in the anonymous user record . The anonymous profile category records through M include the same category IDs and lists of keywords as the corresponding profile category records through M. Note that the location of the user is not stored in the anonymous user record . With respect to location it is sufficient that the anonymous user record is associated with a crowd snapshot which includes spatial information.

In another embodiment anonymization is performed in a manner similar to that described above with respect to . However in this embodiment the profile category records for the group of users in the crowd at the time of creating the crowd snapshot may be selectively randomized among the anonymous user records of those users. In other words each anonymous user record would have a user profile including a selectively randomized set of profile category records including keywords from a cumulative list of profile category records for all of the users in the crowd.

In yet another embodiment rather than creating anonymous user records for the users in the lists maintained for the location buckets anonymization of the user records of the users in the crowd may be performed by storing an aggregate user profile for the crowd. The aggregate user profile may include a list of all keywords and potentially the number of occurrences of each keyword in the user profiles of the corresponding group of users. In this manner the data stored in the crowd snapshot is not connected back to the users through N.

Returning to in addition to the anonymized user records the crowd snapshot record for the crowd snapshot includes the NE corner the SW corner and the center of the crowd at the current time as well as a timestamp defining the current time as the sample time at which the crowd snapshot record was created. Locations of users in the crowd that define the outer boundary of the crowd at the current time are stored in the crowd snapshot record as the vertices of the crowd. Still further one or more crowd characteristics of the crowd at the current time are determined and stored in the crowd snapshot. The crowd characteristics may include for example best case and or worst case average Degree of Separation DOS for the crowd a degree of fragmentation of the crowd a degree of bi directionality of relationship for the crowd or the like. The manner in which these crowd characteristics are determined is described below in detail. After creating the crowd snapshot the crowd analyzer determines whether there are any more crowd change events step . If so the process returns to step and is repeated for the next crowd change event. Once all of the crowd change events are processed the process ends.

Accordingly in this embodiment the spatial crowd formation process of is performed in response to a location update for a user. The crowd analyzer then gets a next relevant crowd step . The relevant crowds are pre existing and new crowds that are within the bounding region s processed during the spatial crowd formation process in response to the location update for the user. Note that for the first iteration the next relevant crowd is the first relevant crowd. The crowd analyzer then determines a maximum number of users in the crowd from a common previous crowd step . More specifically the crowd analyzer examines the previous crowd fields of the user records of all of the users in the crowd to identify users from a common previous crowd. For each previous crowd found in the user records of the users in the crowd the crowd analyzer counts the number of users in the crowd that are from that previous crowd. The crowd analyzer then selects the previous crowd having the highest number of users and determines that the number of users counted for the selected previous crowd is the maximum number of users in the crowd from a common previous crowd.

The crowd analyzer then determines whether the maximum number of users in the crowd from a common previous crowd is greater than a predefined threshold number of users step . In an alternative embodiment rather than determining the maximum number of users from a common previous crowd and comparing that number to a predefined threshold number of users a maximum percentage of users in the crowd from a common previous crowd may be determined and compared to a predefined threshold percentage. If the maximum number of users in the crowd from a common previous crowd is not greater than the predefined threshold number of users the process proceeds to step . Otherwise the crowd analyzer determines whether the common previous crowd has been removed step . If so then the crowd is re established as the common previous crowd step . More specifically in this embodiment the crowd is re established as the common previous crowd by storing the set or list of user records the NE corner the SW corner and the center from the crowd record of the crowd in the crowd record of the common previous crowd. The crowd record for the crowd may then be deleted. In addition the previous crowd fields of the users from the common previous crowd may be set to null or otherwise cleared. Once the common previous crowd is re established the crowd analyzer determines whether there are more relevant crowds to process step . If so the process returns to step and is repeated until all relevant crowds are processed.

Returning to step if the common previous crowd has not been removed the crowd analyzer identifies the crowd as being split from the common previous crowd step . More specifically in this embodiment the crowd analyzer stores a reference to the crowd record of the common previous crowd in the split from field of the crowd record of the crowd. At this point the crowd analyzer then determines whether there are more relevant crowds to process step . If so the process returns to step and is repeated until all relevant crowds are processed at which time the process ends.

In response to receiving the crowd tracking data request the MAP server and more specifically the crowd analyzer obtains relevant crowd snapshots for the crowd step . In one embodiment the crowd tracking data request is a general crowd tracking data request for the crowd. As such the relevant crowd snapshots are all crowd snapshots for the crowd. In another embodiment the crowd tracking data request may include one or more criteria to be used to identify the relevant crowd snapshots. The one or more criteria may include time based criteria such that only those crowd snapshots for the crowd that satisfy the time based criteria are identified as the relevant crowd snapshots. For example the time based criteria may define a range of dates such as Oct. 1 2009 through Oct. 8 2009 or define a range of times within a particular day such as 5 pm through 9 pm on Oct. 1 2009. The one or more criteria may additionally or alternatively include user based criteria such that only those crowd snapshots including anonymous users satisfying the user based criteria are identified as the relevant crowd snapshots. For example the user based criteria may include one or more interests and a minimum number or percentage of users such that only those crowd snapshots including at least the minimum number or percentage of anonymous users having the one or more interests are identified as the relevant crowd snapshots. Note that by using user based criteria the subscriber is enabled to track sub crowds within a crowd.

Next the crowd analyzer of the MAP server generates crowd tracking data for the crowd based on the relevant crowd snapshots step . The crowd tracking data includes data indicative of the location of the crowd over time which can be determined based on the spatial information and sample times from the relevant crowd snapshots. In addition the crowd tracking data may include an aggregate profile for the crowd for each of the relevant crowd snapshots or at least some of the relevant crowd snapshots an average aggregate profile for all of the relevant crowd snapshots an average aggregate profile for a subset of the relevant crowd snapshots or average aggregate profiles for a number of subsets of the relevant crowd snapshots. For example the relevant crowd snapshots may be divided into a number of time bands such that at least some of the time bands include multiple relevant crowd snapshots. An average crowd snapshot may then be created for each of the time bands. The crowd analyzer may utilize the aggregation engine to obtain an aggregate profile for a crowd snapshot based on the interests of the anonymous users in the crowd snapshot. More specifically an aggregate profile for a crowd snapshot may be computed by comparing the interests of the anonymous users to one another or by comparing the interests of the anonymous users to a target profile. The crowd tracking data may also contain other information derived from the relevant crowd snapshots such as for example the number of users in the relevant crowd snapshots crowd characteristics for the crowd for the relevant crowd snapshots or the like.

The crowd analyzer returns the crowd tracking data for the crowd to the subscriber device step . Note that in the embodiment where the subscriber device interacts with the MAP server via the web browser the MAP server returns the crowd tracking data to the subscriber device in a format suitable for use by the web browser . For example the crowd tracking data may be returned via a web page including a map wherein indicators of the location of the crowd over time as defined by the relevant crowd snapshots may be overlaid upon the map. The subscriber may then be enabled to select one of those indicators to view additional information regarding the crowd at that time such as for example an aggregate profile of a corresponding crowd snapshot of the crowd. Once the crowd tracking data is received at the subscriber device the crowd tracking data is presented to the subscriber step .

At some point in time the prediction consuming application sends a prediction request to the prediction server step . The prediction request preferably identifies a subject user for which one or more predicted future locations are desired. The subject user is one of the users through N. In response to the prediction request the prediction server generates one or more predictions based on the prediction basis for the subject user step . More specifically as discussed below in detail the prediction server compares at least a subset of relevant crowd data from the prediction basis of the subject user along with current crowd data for the subject user to first determine whether the subject user is likely to move. If so the prediction server obtains a list of POIs and or crowds that match or are expected to match one or more crowd based criteria derived from the at least a subset of the relevant crowd data from the prediction basis of the subject user. The matching POIs and or locations of the matching crowds are then provided as predicted future locations for the subject user. The prediction server then returns the one or more predicted future locations for the subject user to the prediction consuming application step . The one or more predicted future locations are then utilized by the prediction consuming application to provide a desired service such as for example targeted advertising.

Once it is time to get crowd data for one of the reoccurring time windows the prediction server gets current crowd data for the user step . More specifically in this embodiment the prediction server sends a request to the MAP server for the current crowd data for the user. In response the MAP server identifies the crowd in which the user is current included if any. The MAP server then obtains crowd data for the identified crowd. In this embodiment the crowd data obtained for the crowd includes a size of the crowd a degree of correlation between the user profile of the user and the user profiles of the other users in the crowd one or more crowd characteristics of the crowd or any combination thereof. Again the one or more crowd characteristics may include a best base average DOS for the crowd a worst case average DOS for the crowd a degree of fragmentation of the crowd a degree of bidirectionality of relationships for the crowd or the like. The prediction server then stores the crowd data for the crowd in the prediction basis for the user as crowd data for an instance of the corresponding reoccurring time window step . For example if the reoccurring time window is Monday then the crowd data is stored as crowd data for one instance i.e. one particular Monday for the reoccurring Monday time window. At this point the process returns to step and is repeated.

As illustrated the crowd data points for the reoccurring time window for Thursdays are in a cluster. Specifically in this example the crowd data points for the reoccurring Thursday time window are clustered around a crowd data point representing a crowd size of 10 a degree of correction of approximately 0.9 which is a high degree of correlation and a DOS of 1. The DOS in may be either the best case average DOS or the worst case average DOS for the crowd. As a resulting of the clustering of the crowd data points for the reoccurring Thursday time window the prediction server can predict that the user will likely be in a crowd having similar crowd data on future Thursdays.

Similarly in this example the crowd data points for the Saturday reoccurring time window i.e. Saturdays are clustered around a crowd data point representing a crowd size of 1 and a maximum DOS and minimum correlation which indicates that the user is typically alone on Saturdays. Particularly when the user is not in a crowd the corresponding crowd data in the user s prediction basis may indicate a crowd size of 1 a maximum DOS and a minimum correlation. This data may be used by the prediction server to predict that the user is likely to be alone on future Saturdays.

The crowd data points for the other days i.e. the other reoccurring time windows are not clustered in this example. However even in this situation the prediction server may analyze the crowd data points for each of the days to detect patterns. For example the crowd data points for Sundays may indicate that the user is in a particular type of crowd e.g. large crowd with moderate to high DOS and high correlation every other Sunday. This may occur if for example the user regularly attends a church service every other Sunday. This pattern may be used by the prediction server when predicting future locations of the user on Sundays.

In another embodiment the MAP server proactively forms crowds using the crowd formation process of or . As such in this embodiment the MAP server queries the datastore to identify the crowd in which the subject user is currently included if any. If the subject user is not currently in a crowd the MAP server returns crowd data indicating that the subject user is not in a crowd to the prediction server . If the subject user is currently in a crowd the MAP server obtains crowd data for that crowd. Some or all of the crowd data for the crowd may be proactively generated by the MAP server and stored in the datastore . For example the crowd size of the crowd a degree of correlation between the user profiles of the users in the crowd i.e. the degree of correlation of the user profiles of the users in the crowd to one another and or one or more crowd characteristics of the crowd may be generated at the time of forming the crowd or creating the most recent crowd snapshot of the crowd and stored in the datastore . Alternatively all or a portion of the crowd data for the crowd may be generated reactively in response to the prediction request. For example the MAP server may reactively generate one or more characteristics of the crowd and or a correlation between the user profile of the subject user and the user profiles of the other users in the crowd. The MAP server then returns the crowd data to the prediction server as the current crowd data of the subject user.

In addition to obtaining the current crowd data for the subject user the prediction server obtains relevant crowd data from the prediction basis of the subject user step . The relevant crowd data from the prediction basis is preferably the crowd data from the prediction basis for the current reoccurring time window i.e. the reoccurring time window in which the current time is included . For example if it is currently Monday and one of the reoccurring time windows is Monday then the relevant crowd data from the prediction basis is preferably crowd data from the predication basis for the reoccurring Monday time window i.e. crowd data from the prediction basis for Mondays . Alternatively the relevant crowd data from the prediction basis may be the crowd data from the prediction basis for the immediately following reoccurring time window. This may be particularly beneficial if the current time is at or near the end of the current reoccurring time window.

Next the prediction server determines whether the subject user is likely to move to a new location based on a comparison of the current crowd data of the subject user and all or at least a subset of the relevant crowd data from the prediction basis of the subject user step . More specifically in one embodiment the prediction server represents the current crowd data as a crowd data point in n dimensional space where each component of the current crowd data e.g. crowd size correlation of user interests DOS etc. corresponds to one dimension in the n dimensional space in a manner similar to that illustrated above in . Likewise the relevant crowd data from the prediction basis is represented as a number of crowd data points in the same n dimensional space in a manner similar to that illustrated above in . In one embodiment if all of the crowd data points representing the relevant crowd data from the prediction basis are in a cluster then all of the crowd data points are used to determine whether the subject user is likely to move. Crowd data points are in a cluster if for example they are within a predefined threshold distance from one another in the n dimensional space. The prediction server then computes or otherwise determines a vector magnitude indicative of a difference between the crowd data point for the current crowd data and the crowd data points for the relevant crowd data from the prediction basis. In one embodiment the crowd data points for the relevant crowd data from the prediction basis are averaged or otherwise combined e.g. combined via a center of mass calculation to provide a combined crowd data point. The prediction server then computes the vector magnitude of a vector from the crowd data point for the current crowd data to the combined crowd data point for the relevant crowd data from the prediction basis. The vector magnitude is compared to a predefined threshold such that a determination is made that the subject user is likely to move if the vector magnitude is larger than the predefined threshold. Otherwise a determination is made that the subject user is not likely to move.

In contrast if the crowd data points representing the relevant crowd data from the prediction basis are not in a cluster the prediction server may identify a subset of the crowd data points to be used to determine whether the subject user is likely to move. For example the prediction server may process the crowd data points representing the relevant crowd data from the prediction basis to identify one or more patterns e.g. large crowds with high DOS and high correlation of user interests every 4instance of the corresponding reoccurring time window . Then the prediction server may identify one of the patterns that is currently applicable and select a subset of the crowd data points corresponding to the applicable pattern to be used to determine whether the subject user is likely to move. The prediction server then computes or otherwise determines a vector magnitude indicative of a difference between the crowd data point for the current crowd data and the select subset of the crowd data points for the relevant crowd data from the prediction basis. In one embodiment the select subset of the crowd data points for the relevant crowd data from the prediction basis are averaged or otherwise combined e.g. combined via a center of mass calculation to provide a combined crowd data point. The prediction server then computes the vector magnitude of a vector from the crowd data point for the current crowd data to the combined crowd data point for the relevant crowd data from the prediction basis. The vector magnitude is compared to a predefined threshold such that a determination is made that the subject user is likely to move if the vector magnitude is larger than the predefined threshold. Otherwise a determination is made that the subject user is not likely to move.

If a determination is made that the subject user is not likely to move the process ends. If a determination is made that the subject user is likely to move the prediction server determines one or more crowd criteria descriptive of a type of crowd in which the subject user is expected to be included based on the relevant crowd data from the prediction basis of the subject user step . The one or more crowd criteria are referred to herein as expected crowd criteria. More specifically if the crowd data points representing the relevant crowd data from the prediction basis are in a cluster in n dimensional space the prediction server generates expected crowd criteria that either defines a point in the n dimensional space about which the crowd data points are clustered or expected crowd criteria that defines a n dimensional volume in the n dimensional space that encompasses or at least substantially encompasses the crowd data points. The point in the n dimensional space about which the crowd data points are clustered may be computed by averaging the crowd data points calculating a center of mass of the crowd data points in the n dimensional space or the like. The volume encompassing the crowd data points in the n dimensional space may be computed by for each component of the crowd data determining a range of values defined by a lowest value for that component of the crowd data found in the crowd data points and a highest value for that component of the crowd data found in the crowd data points.

If the crowd data points representing the relevant crowd data from the prediction basis are not in a cluster in the n dimensional space the prediction server identifies one or more patterns in the crowd data points. The prediction server then identifies an applicable pattern and then generates the expected crowd criteria based on a subset of the crowd data points that are in the applicable pattern. The subset of the crowd data points that are in the applicable pattern form a cluster. Again the expected crowd criteria may define a point in the n dimensional space about which the subset of the crowd data points are clustered or a volume in the n dimensional space that encompasses or at least substantially encompasses the subset of the crowd data points.

Next the prediction server obtains a list of matching POIs and or matching crowd locations that satisfy or are expected to satisfy the one or more expected crowd criteria step . More specifically the prediction server sends a request to the MAP server including the expected crowd criteria from step . In one embodiment the MAP server identifies POIs at which crowds that match the expected crowd criteria are currently located. In order to identify these matching POIs the MAP server first identifies POIs within a predefined geographic area around the current location of the subject user. For example the MAP server may first identify POIs within a predefined distance from the current location of the subject user. For each identified POI the MAP server identifies crowds currently at the identified POI and obtains crowd data for the identified crowds. In one embodiment the MAP server reactively generates the crowds at the identified POIs at this time using for example the process of . In another embodiment the MAP server proactively generates crowds using for example the process of or . In this case the MAP server identifies the crowds at the identified POIs by querying the datastore . The MAP server also obtains crowd data for the identified crowds. The crowd data for the identified crowds may be generated proactively reactively or a combination thereof. For each of the identified crowds the MAP server then compares the crowd data for the crowd to the expected crowd criteria. If the crowd data for the crowd matches the expected crowd criteria to at least a predefined threshold degree then the corresponding POI is identified as a matching POI and is returned to the prediction server .

In addition or alternatively the MAP server may identify POIs that are expected to have crowds that match the expected crowd criteria as matching POIs at some future time. More specifically the MAP server may first identify POIs within a predefined geographic area around the current location of the subject user. For example the MAP server may first identify POIs within a predefined distance from the current location of the subject user. For each identified POI the MAP server then identifies crowds that are expected to be at the identified POI within a predefined amount of time e.g. on the current day within the next hour or the like . More specifically in this embodiment the MAP server may query the datastore to obtain crowd snapshots for crowds previously located at the identified POI. For each crowd previously located at the identified POI the MAP server determines whether the crowd is expected to be located at the identified POI within the predefined amount of time based on the crowd snapshots for that crowd. For example if it is currently Friday afternoon and the crowd snapshots for a crowd indicate that the crowd has historically visited the identified POI every Friday afternoon then the prediction server determines that the crowd is expected to be located at the identified POI. Then the prediction server obtains crowd data for each crowd identified for the identified POI. In this embodiment some if not all of the crowd data for the crowd is included in the crowd snapshots for the crowd. As such in one embodiment at least some of the crowd data for the crowd is obtained from a most recent crowd snapshot for the crowd. Further the MAP server may generate any desired crowd data that is not included in the crowd snapshot. For each identified crowd the MAP server compares the crowd data for the crowd to the expected crowd criteria. If the crowd data for the crowd matches the expected crowd criteria to at least a predefined threshold degree then the corresponding POI is identified as a matching POI and is returned to the prediction server . In addition a time at which a crowd having crowd data matching the expected crowd criteria is expected to be at the matching POI may also be returned to the prediction server .

In addition or as an alternative to identifying matching POIs the MAP server may identify locations of current crowds that match the expected crowd criteria for the subject user. More specifically in one embodiment the MAP server first identifies crowds within a predefined geographic area around the current location of the subject user. In one embodiment the MAP server reactively generates the crowds at this time using for example the process of . In another embodiment the MAP server proactively generates crowds using for example the process of or . In this case the MAP server identifies the crowds within the predefined geographic area around the current location of the subject user by querying the datastore . The MAP server also obtains crowd data for each of the identified crowds. The crowd data for the identified crowds may be generated proactively reactively or a combination thereof. For each of the identified crowds the MAP server compares the crowd data for the crowd to the expected crowd criteria. If the crowd data for the crowd matches the expected crowd criteria to at least a predefined threshold degree then the location of the crowd is identified as a matching crowd location and is returned to the prediction server .

In addition or alternatively the MAP server may identify crowd locations of crowds that are expected to match the expected crowd criteria for the subject user at some future time. More specifically the MAP server may first identify crowds that are currently within a predefined geographic area around the current location of the subject user. In this embodiment the MAP server proactively forms crowds and provides the crowd tracking feature described above. As such the MAP server queries the datastore to identify the crowds that are currently within the predefined geographic area. For each identified crowd the MAP server analyzes historical crowd data for the crowd included in the crowd snapshots for the crowd to determine whether the crowd is expected to satisfy the expected crowd criteria for the subject user within a predefined amount of time e.g. on the current day within the next hour or the like . For example if it is currently Friday morning and the crowd snapshots for a crowd indicate that the crowd data for the crowd has historically matched the expected crowd criteria for the subject user to at least the predefined threshold degree on Friday afternoons then the crowd is identified as a matching crowd. The current location of the matching crowd is returned to the prediction server as a matching crowd location. In addition a time at which the crowd data of the matching crowd is expected to match the expected crowd criteria may also be returned to the prediction server .

Lastly the prediction server generates a prediction for movement to the one or more matching POIs and or matching crowd locations for the subject user step . More specifically in one embodiment the prediction server receives a list of matching POIs and or matching crowd locations from the MAP server . The prediction server then ranks the matching POIs and or matching crowd locations based on one or more ranking criteria. The ranking criteria may include for example distance of the matching POI or matching crowd location from the subject user amount of time until the expected crowd criteria are satisfied which is particularly applicable for matching POI or matching crowd locations that are expected to match the expected crowd criteria in the future or previous actions of the subject user. For example if the subject user has previously indicated that he does not like particular types of POIs e.g. bars the prediction server may assign any matching POIs that are bars a low ranking or remove them as predictions. At this point the prediction server returns the predictions to the requestor which for this example is the prediction consuming application .

In response the mobile device then operates to confirm the predictions step . More specifically in one embodiment the mobile device confirms the predictions by ranking or sorting the predictions based on one or more local criteria e.g. rules or parameters . The local criteria may require input from the user or may enable the mobile device to confirm the predictions automatically. For example the local criteria may indicate that the user is to manually rank the predictions. As another example the local criteria may indicate that the mobile device is to automatically rank the predications based on a historical record of the location of the user stored at the mobile device . For instance predictions for POIs that the user has frequently visited in the past may be assigned a high ranking whereas predictions for POIs that the user has never visited or rarely visits may be assigned a low ranking. In yet another example contextual information regarding the user or the mobile device is taken in to account in automatically determining the rankings of the predictions. The contextual information may include other users in proximity to the user current activity of the user time of day location and the like. For instance when the user is with a certain friend he has a high likelihood to visit a specific POI. The user may also be enabled to remove or delete predictions. Still further if confirmation is manually performed by the user the user may be enabled to input a reason for a high or low ranking of a POI or crowd location.

Once confirmation is complete the mobile device returns confirmation to the prediction server step . The confirmation preferably includes a list of confirmed predictions including revised rankings and optionally reasons for at least some of the rankings. The reasons for the rankings may thereafter be used by the prediction server to refine future predictions. The prediction server then returns the confirmed predictions to the prediction consuming application step . The confirmed predictions are then utilized by the prediction consuming application to provide a desired service such as for example targeted advertising.

Once all of the users in the crowd have been processed the aggregation engine generates a degree of correlation of between the user profile of the subject user and the user profiles of the users in the crowd step . In one embodiment the degree of correlation is a ratio of the number of user matches to the total number of users in the crowd. The number of user matches is a number of users in the crowd having at least one keyword in their user profile that matches a keyword in the user profile of the subject user. In another embodiment the degree of correlation is a ratio of the number of user matches to the total number of users in the crowd for each individual keyword in the user profile of the subject user. In another embodiment the degree of correlation may be computed based on the number of user matches for each individual keyword in the user profile of the subject user and weights assigned to the individual keywords. The keyword weights may be assigned by the subject user.

Note that while the process of generates the degree of correlation between the user profile of the subject user and the user profile of the users in the crowd a similar process may be used to generate a degree of correlation of the user profiles in the crowd to one another. Specifically the user profiles of the users in the crowd would be compared to one another. The degree of correlation of the user profiles in the crowd may then be expressed as a ratio of a number of user matches to the total number of users in the crowd. Here the number of user matches is the number of users in the crowd having at least one keyword in their user profiles that match at least one keyword in the user profile of another user in the crowd. In another embodiment the degree of correlation may be expressed as a ratio of the number of user matches to the total number of users in the crowd for each individual keyword appearing in any of the user profiles of the users in the crowd.

The crowd analyzer then determines whether the distance between the two closest crowd fragments is less than an optimal inclusion distance for a crowd fragment step . In one embodiment the optimal inclusion distance for a crowd fragment is a predefined static value. In another embodiment the optimal inclusion distance of the crowd may vary. As such the optimal inclusion distance for a crowd fragment within the crowd may be defined as a fraction of the optimal inclusion distance of the crowd such that the optimal inclusion distance for a crowd fragment within the crowd varies along with the optimal inclusion distance for the crowd itself.

If the distance between the two closest crowd fragments is less than the optimal inclusion distance for a crowd fragment then the two closest crowd fragments are combined step and a new crowd fragment center is computed for the resulting crowd fragment step . The crowd fragment center may be computed using for example a center of mass algorithm. At this point the process returns to step and is repeated. Once the two closest crowd fragments in the crowd are separated by more than the optimal inclusion distance for a crowd fragment the process ends. At this point the crowd analyzer has created the crowd fragments or defined the crowd fragments for the crowd. The crowd data for the crowd may then include the degree of fragmentation of the crowd which may be provided as the number of crowd fragments in the crowd and or an average number of users per crowd fragment as the degree of fragmentation of the crowd.

The crowd analyzer then determines whether the DOS between the two users is less than a predefined maximum DOS for a crowd fragment step . For example the predefined maximum DOS may be three. However other maximum DOS values may be used to achieve the desired crowd fragmentation. If the DOS between the two users is not less than the predefined maximum DOS the process proceeds to step . If the DOS between the two users is less than the predefined maximum DOS the crowd analyzer determines whether a bidirectionality requirement is satisfied step . The bidirectionality requirement specifies whether the relationship between the two users must be bidirectional i.e. the first user must directly or indirectly know the second user and the second user must directly or indirectly know the first user . Bidirectionality may or may not be required depending on the particular embodiment. If the two users satisfy the bidirectionality requirement the crowd analyzer combines the pair of crowd fragments step and computes a new crowd fragment center for the resulting crowd fragment step . The process then returns to step and is repeated for a next pair of crowd fragments. If the two users do not satisfy the bidirectionality requirement the process proceeds to step .

At this point whether proceeding from step or step the crowd analyzer determines whether all user pairs from the two crowd fragments have been processed step . If not the process returns to step and is repeated for a new pair of users from the two crowd fragments. If all user pairs from the two crowd fragments have been processed the crowd analyzer then determines whether all crowd fragments have been processed step . If not the process returns to step and is repeated until all crowd fragments have been processed. Once this process is complete the crowd analyzer has determined the number of crowd fragments in the crowd. The crowd data for the crowd may then include the degree of fragmentation of the crowd which may be provided as the number of crowd fragments and or the average number of users per crowd fragment.

The crowd analyzer then computes a best case average DOS for the crowd using a best case DOS for the user pairs in the crowd for which explicit relationships are not defined step . In this embodiment the best case average DOS is 1. The best case average DOS may computed as 

The crowd analyzer also computes the worst case average DOS for the crowd using a worst case DOS for the user pairs in the crowd for which explicit relationships are not defined step . In this embodiment the worst case DOS is a greatest possible DOS that the crowd analyzer considers which may be for example a DOS of greater than or equal to 7. For instance the worst case DOS may be 10. However other values for the worst case DOS may be used. The worst case average DOS may computed as 

At this point whether proceeding from step step or step the crowd analyzer determines whether the user has more friends to process step . If so the process returns to step and is repeated for the next friend of the user. Once all of the friends of the user have been processed the crowd analyzer determines whether there are more users in the crowd fragment step . If so the process returns to step and is repeated for the next user in the crowd fragment. Once steps through have been performed for all of the users in the crowd fragment the crowd analyzer computes a ratio of the bidirectional count i.e. the number of bidirectional friend relationships over the connection count i.e. the number of unidirectional and bidirectional friend relationships for the crowd fragment step . At this point the process ends. In this embodiment the ratio of the bidirectionality count to the connection count reflects the degree of bidirectionality of friendship relationships for the crowd fragment and may be included in the crowd data for the crowd.

Those skilled in the art will recognize improvements and modifications to the preferred embodiments of the present invention. All such improvements and modifications are considered within the scope of the concepts disclosed herein and the claims that follow.

