---

title: Systems and methods for a snapshot of data
abstract: In one embodiment, a user or client device is connected to a distributed file system comprised of one or more physical nodes. The data on each of the physical nodes store metadata about files and directories within the file system. Some of the embodiments permit a user to take a snapshot of data stored on the file system. The snapshot may include a single file, a single directory, a plurality of files within a directory, a plurality of directories, a path on the file system that includes nested files and subdirectories, or more than one path on the file system that each includes nested files and directories. In an embodiment, a snapshot tracking data structure is maintained for efficient creation and deletion of the snapshot.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08356013&OS=08356013&RS=08356013
owner: EMC Corporation
number: 08356013
owner_city: Hopkinton
owner_country: US
publication_date: 20101217
---
This application is a continuation of and claims benefit of priority under 35 U.S.C. 120 to U.S. patent application Ser. No. 11 507 069 filed Aug. 18 2006 entitled Systems and Methods for a Snapshot of Data which is hereby incorporated by reference herein in its entirety and which was filed on the same day as the following applications with the same title Systems and Methods for a Snapshot of Data U.S. application Ser. Nos. 11 506 596 11 506 610 which issued as U.S. Pat. No. 7 680 836 on Mar. 16 2010 and Ser. No. 11 506 591 which issued as U.S. Pat. No. 7 680 842 on Mar. 16 2010 all three of which are hereby incorporated by reference in their entirety herein.

This invention relates generally to a computer system and more specifically to taking snapshots of data in a computer system.

The amount of data stored on digital computing systems has increased dramatically in recent years. Accordingly users have become increasingly reliant on the storage devices of these systems to store this data. Typically the data stored on the storage devices undergo modifications. These modifications may arise from user intervention periodic system updates or alterations computer initiated processes or some other source. Whatever the source of the modifications it is often useful to preserve and permit access to previous versions of the data such as for example files and directories. Some instances of when access to previous versions may be useful include but are not limited to inadvertently deleted or overwritten data providing external access to older versions of data while newer versions are being updated and determining changes to storage device usage over time.

One response to preserving older versions of files has been to copy the entire contents of the storage device to a backup or second storage device. A digital computing system employing this technique will often encounter numerous problems. One copying entire data systems is time consuming and delays write requests to data on the storage device. Second this type of backup is financially expensive because it often requires the purchase of additional storage space. Finally this option does not permit system flexibility. Backups of portions of the file system can reduce the time and expense encountered with traditional methods.

Moreover the aforementioned problems are amplified when modern large capacity storage devices and distributed storage systems comprising numerous large capacity storage devices are considered.

Because of the foregoing challenges and limitations there is a need to provide a more efficient manner in which to provide snapshots of data in a system.

The embodiments disclosed herein generally relate to a computer system and more specifically to taking snapshots of data in a computer system.

One embodiment of the present invention includes a method for taking a snapshot of a portion of a file system including files and directories. The method may include accepting at least one path that represents a portion of a file system where the portion is less than the entire file system retrieving at least one data structure that represents the top most level of the at least one path and prior to any modifications of the portion of the file system represented by the at least one path indicating in the at least one data structure that the at least one path is governed by a snapshot.

Another embodiment of the present invention includes a data structure for tracking modifications in a file system. The data structure may include a first representation of a snapshot that is associated with the data structure and a second representation of data structures governed by the snapshot that have been modified.

An additional embodiment of the present invention includes a data structure associated with files or directories in a file system. The data structure may include an identification field comprised of a first portion and second portion wherein the first portion is common to versions of the data structure and the second portion is unique to a particular version of the data structure a representation of snapshots that govern the data structure and a last access field that indicates when the representation was last updated.

A further embodiment of the present invention includes a system for accessing snapshot data in a file system. The system may include a storage device comprising a file system and a processor operably coupled to the storage device configured to accept an access request to a path corresponding to a portion of the file system determine that the portion of the file system is governed by a snapshot identify locations in the storage device that store snapshot data retrieve the snapshot data and generate an indication that the snapshot data is not the current version of the data.

Another embodiment of the present invention includes a data storage system with per file snapshot capability. The data storage system may include directory and file nodes forming a data structure tree and a software snapshot module configured to allow for preservation of data on a per file basis as of a given point in time.

An additional embodiment of the present invention includes a data storage system with snapshot capability on a per directory and downstream files basis. The data storage system may include a directory and file nodes forming a data structure tree and a software snapshot module configured to preserve data stored in all directories and files downstream of the directory which is both closest to the files that include the desired data to be preserved as of a given time and from which directory paths lead down to all said files including the desired snapshot data.

A further embodiment of the present invention includes a method of preserving data stored in a storage system as of a selected time. The method may include identifying the file within the storage system that includes the desired data to be preserved as of a selected time and preserving all the data within said file as of said selected time.

An additional embodiment of the present invention includes a method of preserving data stored in a storage system as of a selected time. The method may include identifying the files within the storage system that include the desired data to be preserved as of a selected time identifying the directory in the directory file tree closest to all the identified files and from which paths lead down to the identified files and preserving the data in all the files downstream of the identified directory including all downstream files if any that were not identified as including data desired to be preserved as of said selected time.

Another embodiment of the present invention includes a method of modifying data in a file stored in a processor accessible storage system while preserving data stored in the file as of a point in time. The method may include locating the desired file within a hierarchical storage structure and checking a node at least one level up the hierarchical storage structure leading to the desired file for an indication that data existing in the file prior to modification should be preserved.

A further embodiment of the present invention includes a processor accessible data storage system allowing for the preservation of data in a file as of a point in time. The system may include a hierarchical structure for storing data including directory nodes and file nodes and an indication that the data in a file should be preserved as of specified point in time stored initially at a node other than the file node.

An additional embodiment of the present invention includes a method of accessing the data stored in a storage system as of a selected point in time. The method may include locating the desired file within an index storage structure using a file identifier and a snapshot identifier and checking the index storage structure for the desired file to determine if any information stored in the file has been modified since the selected point in time.

A further embodiment of the present invention includes a method of tracking files to be traversed. The method may include storing a set of data structures that correspond to a plurality of files that are logically stored in a tree tracking a set of snapshots that govern subsets of files in the tree receiving an identifier for a first file to be modified and determining whether the first file is governed by any of the set of snapshots by traversing at least a portion of the tree.

Another embodiment of the present invention may include a system for tracking snapshots of a file system. The system may include a file structure comprising a plurality of files that are logically stored in a tree for each of the plurality of files a data structure corresponding to each of the files and directories the data structure comprising an indication of the snapshot data currentness of the data structure a modification module configured to receive a request to modify one of the plurality of files and an update module configured to update at least one of the data structures to determine whether the at least one data structure is governed by a snapshot.

A further embodiment of the invention includes a processor accessible data storage system allowing for the storage of data representing a file system with a root accessible directory level snapshot structure. The system may include a hierarchical structure for storing data including a root directory node directory nodes and file nodes and a representation of a snapshot of at least one branch of the hierarchical structure at least one branch comprising a top node a sequence of at least one mini snapshot node representing a path from the root directory node to the top node at the time of the creation of the snapshot each mini snapshot node comprising a reference from the mini snapshot node to a child mini snapshot node or the top node.

An additional embodiment of the invention includes a method of maintaining path accessibility for snapshots in subnodes of a hierarchical structure. The method may include receiving an indication of at least one branch of a hierarchical structure at least one branch comprising a top node and generating a mini snapshot of an ancestor node of the top node the mini snapshot comprising a reference from the mini snapshot node to a child mini snapshot node or the top node.

Another embodiment of the invention includes a data storage system capable of preserving data snapshots of portions of the stored data as of selected points in time. The data structure may include a data storage tree structure to store current data in directories and files a snapshot module configured to create snapshots in time of directories and files and snapshot data structures of snapshot versions of a file wherein the snapshot file version identifies blocks of data modified from the next more recent version of the file.

A further embodiment of the invention includes a method of preserving snapshots of data as of selected points in time in a hierarchical data storage structure including files. The method may include creating a first snapshot file version of a current file when a snapshot of a portion of data in the data storage structure which includes said file is taken wherein said first snapshot file version is separate and independent of the current file version and references blocks of the next more recent snapshot version of the file that are the same as the first snapshot file version and stores direct references to blocks which are different from the next more recent snapshot version of the file wherein the next more recent snapshot version of the file is the current file creating a second snapshot file version of a current file when a snapshot of a portion of data in the data storage structure which includes said file is taken wherein said second snapshot file version is separate and independent of the current file version and references blocks of the next more recent snapshot version of the file that are the same as the current snapshot file version and stores direct references to blocks which are different from the next more recent snapshot version of the file and wherein the next more recent snapshot version of the file for the second snapshot file version is the current file and the next more recent snapshot version of the file for the first snapshot file is the second snapshot file version.

An additional embodiment of the invention may include a data storage system capable of preserving data snapshots of portions of the stored data as of selected points in time. The system may include a data storage tree structure to store current data in directories and files a snapshot module configured to create snapshots in time of directories and files and snapshot data structures of snapshot versions of a directory wherein the snapshot directory version identifies children of the directory that are different from the next more recent version of the directory.

A further embodiment of the present invention includes a data storage system accessible by a processor. The data storage system may include a hierarchical data storage structure with directory nodes and file nodes in a tree structure at least some of said directory nodes having a plurality of file nodes as children a snapshot identifier associated with a directory to designate a snapshot as of a given time the snapshot including the directory and all subdirectories if any and all files under the directory and the same snapshot identifier associated with each of the subdirectories if any and files under the directory.

An additional embodiment of the present invention includes a method of traversing a portion of data stored hierarchically in a data storage system in which the portion of the data represents a snapshot of the data stored in said system as of a point in time. The method may include identifying the desired snapshot point in time and the desired file or files within the storage system and traversing the nodes of the storage system that are identified at the nodes as associated with the desired snapshot to find the desired file or files.

Another embodiment of the present invention includes a storage system that track of a plurality of versions of selected data portions as of selected points in time. The storage system may include a snapshot module configured to track multiple snapshots of the same and or different portions of the data stored in said storage system at substantially the same and or different points in time a data structure configured to store the current data of the storage system and to store the snapshot versions of the data generally only to the extent the snapshot versions of the data differ from the storage system s current data snapshot data structures related to the snapshot versions configured to store information about nodes within the snapshot versions that have been modified and said snapshot module further configured to permit deletion of any one or more of the snapshot versions of the data after reviewing the modified nodes indicated in the snapshot data structures that correspond to the one or more snapshot versions to be deleted.

A further embodiment of the present invention includes a method for keeping track of snapshots in a storage system. The method may include creating a snapshot tracking file when a snapshot is created wherein the snapshot identifies certain data stored in the storage system to be preserved as of a particular point in time adding a data identifier to the snapshot tracking file whenever data stored in the storage system and covered by the snapshot is modified and using the information in the snapshot tracking file to recreate the snapshot data when this is desired.

An additional embodiment of the present invention includes a method of deleting a snapshot in a storage system wherein the storage system is comprised of a hierarchical data structure of directory and file nodes wherein generally only the portions of blocks of data that have been modified by the system are stored in the snapshot portion of the storage system to permit recreation of the data as of the point in time of the snapshot the method of deletion of a snapshot. The method may include vesting all files covered by the snapshot which have been modified since the creation of the snapshot deleting the reference to the snapshot in the active snapshot list and deleting blocks of data no longer in use.

For purposes of this summary certain aspects advantages and novel features of the invention are described herein. It is to be understood that not necessarily all such advantages may be achieved in accordance with any particular embodiment of the invention. Thus for example those skilled in the art will recognize that the invention may be embodied or carried out in a manner that achieves one advantage or group of advantages as taught herein without necessarily achieving other advantages as may be taught or suggested herein.

Systems methods processes and data structures which represent one embodiment of an example application of the invention will now be described with reference to the drawings. Variations to the systems methods processes and data structures which represent other embodiments will also be described.

For purposes of illustration some embodiments will be described in the context of a distributed file system. Embodiments of a distributed file system suitable for accommodating embodiments of snapshots disclosed herein are disclosed in U.S. patent application Ser. No. 10 007 003 titled SYSTEMS AND METHODS FOR PROVIDING A DISTRIBUTED FILE SYSTEM UTILIZING METADATA TO TRACK INFORMATION ABOUT DATA STORED THROUGHOUT THE SYSTEM filed Nov. 9 2001 which claims priority to Application No. 60 309 803 filed Aug. 3 2001 U.S. patent application Ser. No. 10 281 467 entitled SYSTEMS AND METHODS FOR PROVIDING A DISTRIBUTED FILE SYSTEM INCORPORATING A VIRTUAL HOT SPARE filed Oct. 25 2002 and U.S. patent application Ser. No. 10 714 326 entitled SYSTEMS AND METHODS FOR RESTRIPING FILES IN A DISTRIBUTED FILE SYSTEM filed Nov. 14 2003 which claims priority to Application No. 60 426 464 filed Nov. 14 2002 all of which are hereby incorporated by reference herein in their entirety.

For purposes of illustration some embodiments will also be described with reference to updating data structures in a file system using information stored in related data structures of the file system. Embodiments of a file system capable of updating data structures with information stored in related data structures of a file system are disclosed in U.S. patent application Ser. No. 11 255 337 titled SYSTEMS AND METHODS FOR ACCESSING AND UPDATING DISTRIBUTED DATA and is hereby incorporated by reference in its entirety.

In one embodiment of a distributed file system metadata structures also referred to as inodes are used to monitor and manipulate the files and directories within the system. An inode is a data structure that describes a file or directory and may be stored in a variety of locations including on disk and or in memory. The inode in memory may include a copy of the on disk data plus additional data used by the system including fields associated with the data structure.

As used herein a file is a collection of data stored in one unit under a filename. A directory similar to a file is a collection of data stored in one unit under a directory name. A directory however is a specialized collection of data regarding elements in a file system. In one embodiment a file system is organized in a tree like structure. Directories are organized like the branches of trees. Directories may begin with a root directory and or may include other branching directories. Files resemble the leaves or the fruit of the tree. Files typically do not include other elements in the file system such as files and directories. In other words files do not typically branch. Although in the illustrated embodiment an inode represents either a file or a directory in other embodiments an inode may include metadata for other elements in a distributed file system in other distributed systems in other file systems or other systems.

As used herein data structures are collections of associated data elements such as a group or set of variables or parameters. In one embodiment a structure may be implemented as a C language struct. One skilled in the art will appreciate that many suitable data structures may be used.

Some of the figures and descriptions relate to an embodiment of the invention wherein the environment is that of a distributed file system. The present invention is not limited by the type of environment in which the systems methods processes and data structures are used. The systems methods structures and processes may be used in other environments such as for example other file systems other distributed systems the Internet the World Wide Web a private network for a hospital a broadcast network for a government agency an internal network of a corporate enterprise an intranet a local area network a wide area network a wired network a wireless network and so forth. It is also recognized that in other embodiments the systems methods structures and processes may be implemented as a single module and or implemented in conjunction with a variety of other modules and the like.

In one embodiment a user or client device is connected to a distributed file system comprised of one or more physical nodes for example storage devices . The data on each of the physical nodes are arranged according to inodes which store metadata about files and directories within the file system. In particular each inode points to locations on a physical disk that store the data associated with a file or directory.

Some of the embodiments disclosed herein permit a user to take a snapshot of data stored on the file system. The snapshot may include a single file a single directory a plurality of files within a directory a plurality of directories a path on the file system that includes nested files and subdirectories or more than one path on the file system that each includes nested files and directories.

A path to a file or directory specified to create a snapshot will be referred to herein as the root of the snapshot. For example the command snap create ifs data dir creates a snapshot of directory dir and the files and directories nested within dir. Accordingly dir is the root of the snapshot. In one embodiment if the root of the snapshot is a file then the snapshot is of the file only. Thus the file is governed by the snapshot. If the root of the snapshot is a directory then the root of the snapshot and all files and directories nested within the root of the snapshot as well as their descendents are governed by the snapshot. Accordingly in some embodiments more than one snapshot may govern a particular file or directory.

Additionally the most current version of data on the file system will be referred to as the current version HEAD version or active version whereas previous versions will be referred to as snapshot data the snapshot version or past versions. In one embodiment if the current version of a file or a directory has been deleted from the system it is possible for a file or directory to have snapshot versions but not have a current version.

In one embodiment when a snapshot is created it is created in constant time. That is no copying of data is required. Instead a snapshot is created by creating a snapshot tracking data structure associated with the new snapshot a mini snapshot s if applicable and an indication in the governance list field of the metadata structure associated with the root of the snapshot. A snapshot is said to be created in constant time because substantially little time is required to create the snapshot. Accordingly snapshot creation does not substantially interfere with read requests to files and directories governed by the snapshot. This feature and other features of the embodiments disclosed herein will be described in more detail below.

In a distributed file system comprises various physical nodes that communicate over a communication medium . In one embodiment the communication medium is the World Wide Web. In other embodiments as described above the distributed file system may be comprised of one or more hard wired connections between the physical nodes or any combination of communication types known to one with ordinary skill in the art.

In the depicted embodiment the physical nodes are either interfaces such as a personal computer a mainframe terminal or a client application or data storage systems . It will be appreciated by one with ordinary skill in the art that the distributed file system may comprise one or a plurality of interfaces and one or a plurality of data storage systems. In one embodiment the interfaces may comprise data storage systems such as for example data storage systems and .

In one embodiment the snapshot module is capable of executing the processes and methods described herein. The word module refers to logic embodied in hardware or firmware or to a collection of software instructions possibly having entry and exit points written in a programming language such as for example C or C . A software module may be compiled and linked into an executable program installed in a dynamically linked library or may be written in an interpreted programming language such as for example BASIC Perl or Python. It will be appreciated that software modules may be callable from other modules or from themselves and or may be invoked in response to detected events or interrupts. Software instructions may be embedded in firmware such as an EPROM. It will be further appreciated that hardware modules may be comprised of connected logic units such as gates and flip flops and or may be comprised of programmable units such as programmable gate arrays or processors. The modules described herein are preferably implemented as software modules but may be represented in hardware or firmware. Moreover although in some embodiments a module may be separately compiled in other embodiments a module may represent a subset of instructions of a separately compiled program and may not have an interface available to other logical program units.

In one embodiment the processor receives and processes requests to create snapshots to delete snapshots to read snapshot data to modify data governed by a snapshot and or other snapshot related processes. In other embodiments the processor executes some or all of the processes and or methods described herein. In yet other embodiments the processor calls the snapshot module to execute snapshot related processes.

In one embodiment the storage device stores files and directories of the file system and the inode metadata associated with the files and directories. Examples of the arrangements of files and directories stored on the storage device can be found in . In some embodiments the storage device may be a physical disk. In other embodiments the storage device may comprise a plurality of physical disks in communication with one another and or the bus. In yet other embodiments the storage device may include a magnetic storage medium an optical disk a random access memory a hard drive and a partitioned portion of a hard drive.

The data storage system may run on a variety of computer systems such as for example a computer a server a smart storage unit and so forth. In one embodiment the computer may be a general purpose computer using one or more microprocessors such as for example an Intel Pentium processor an Intel Pentium II processor an Intel Pentium Pro processor an Intel Pentium IV processor an Intel Pentium D processor an Intel Core processor an xx86 processor an 8051 processor a MIPS processor a Power PC processor a SPARC processor an Alpha processor and so forth. The computer may run a variety of operating systems that perform standard operating system functions such as for example opening reading writing and closing a file. It is recognized that other operating systems may be used such as for example Microsoft Windows 3.X Microsoft Windows 98 Microsoft Windows 2000 Microsoft Windows NT Microsoft Windows CE Microsoft Windows ME Microsoft Windows XP Palm Pilot OS Apple MacOS Disk Operating System DOS UNIX IRIX Solaris SunOS FreeBSD Linux or IBM OS 2 operating systems.

As depicted the root of the file system is ifs . From here files and directories branch outward each with a corresponding inode. In one embodiment inodes that correspond to directories may have one or more child inodes and possibly even one or more grandchild great grandchild inodes and or other descendents. In another embodiment inodes that correspond to files do not have any child inodes. For example inode four corresponds to the directory data and has child inodes one hundred five thousand and nine thousand. The grandchild inodes of inode four include inodes one hundred one one hundred two five thousand one and five thousand two the great grandchild inodes of inode four include inodes five thousand three and five thousand four. In other embodiments inodes corresponding to files may have child inodes grandchild inodes and so forth.

The dashed lines in correspond to snapshots of the file system . In one embodiment each of the snapshots has a snapshot identifier snapshot ID . In one embodiment the snapshot ID provides an indication as to the relative time the snapshot was created. For example if the snapshot ID of snapshot A is greater than the snapshot ID of snapshot B it is understood that snapshot A was created after snapshot B. In one embodiment the snapshot ID is assigned to snapshots based on a monotonically increasing global snapshot counter global count . In other embodiments the snapshot ID may be randomly assigned or otherwise be unrelated to the relative time the snapshot was created.

In snapshot one has snapshot ID . The root of snapshot one is data and is represented by the path ifs data . Thus directory data is the root of snapshot one . Accordingly data and all of the files and directories nested within data are governed by snapshot one .

Snapshot two has snapshot ID . The root of snapshot two is represented by the path ifs data dir. Thus directory dir is the root of the snapshot two . Accordingly dir and all of the files and directories nested within dir are governed by snapshot two . Additionally because dir is also governed by snapshot one dir and all of the nested files and directories under dir are governed by both snapshot one and snapshot two .

Snapshot three has snapshot ID . The root of snapshot three is represented by the path ifs data dir dir file . Thus file is the root of snapshot three . Because no files or directories are nested within file file is the only file or directory governed by snapshot three . However file is also governed by snapshot one because it is a file nested within data which is governed by snapshot one .

In the depicted embodiment current versions of the files and directories within the file system are represented using rectangles for example data . Virtual directories that provide access to snapshot data are represented using double rectangles for example .snapshot . Files and directories associated with snapshot one are represented using ovals for example data files and directories associated with snapshot two are represented using triangles for example data and files and directories associated with snapshot three are represented using trapezoids for example data . In one embodiment the snapshot versions of files and directories on a file system are virtual files and directories.

As shown in the top level .snapshot directory is a subdirectory of the root of the file system ifs. The top level .snapshot directory includes subdirectories for each of the three snapshots snap for snapshot one snap for snapshot two and snap for snapshot . Using an operating system compatible change directory command for example cd for UNIX a user can access the snapshot data for snapshot one using the path ifs .snapshot snap . Once at this path the file system will appear as the file system at the time snapshot one was created. For example file from snapshot one can be accessed using the path ifs .snapshot snap data dir dir file .

The ifs .snapshot snap subdirectory is similar in many respects to the snap subdirectory . The file system appears as it did at the time of snapshot two was created. However because snapshot two governs only dir and the files nested within it the parent directory to dir data includes enough information to access the snapshot version of dir . As used herein ancestor directories that are not governed by a snapshot but include children files or directories to navigate to snapshot data are referred to as mini snapshots. For example though the current version of data has as its children file dir and dir the mini snapshot of data for snapshot two has its only child dir .

Mini snapshots serve as stand ins for the portions of the directory tree between the file system root and the root of a snapshot. Consequently snapshot data can be accessed in an intuitive way without being computationally expensive.

For example the .snapshot snap directory utilizes three mini snapshot directories data dir and dir to provide access to the snapshot version of file governed by snapshot three . Accordingly each of the mini snapshot directories do not store information unrelated to accessing file data does not store information related to fuel or dir dir does not store information related to file and dir does not store information related to file.

The embodiment depicted in also shows how snapshot data can be accessed via .snapshot subdirectories nested within the file system hierarchy . Each directory that includes or in some instances formerly included data with a snapshot version also has a .snapshot subdirectory. These .snapshot subdirectories are similar to the .snapshot subdirectory of ifs in that they preserve the intuitive feel of the file system when accessing snapshot versions. Accordingly the .snapshot subdirectories also utilize mini snapshots.

One example of a nested .snapshot subdirectory can be found within data . The .snapshot subdirectory includes three subdirectories snap snap and snap . Because data is the root of snapshot one the subdirectories and files located within snap appear as the subdirectories and files of data at the time that snapshot one was created.

Similarly dir includes a .snapshot subdirectory that includes snapshot data related to snapshot one snap and snapshot three snap . The data within snap can be accessed as if ifs data dir was accessed at the time that snapshot one was taken. However the data within snap is limited to only file because snapshot three only governs file . Accordingly dir and dir are mini snapshots that provide access to file .

The .snapshot subdirectory found within dir also includes data associated with snapshot one and snapshot three . Subdirectory snap includes the snapshot versions of file and file . In contrast subdirectory snap only includes the snapshot version of file because file is the root of snapshot three .

Subdirectory dir also includes a .snapshot subdirectory . Nested within .snapshot are subdirectories snap and snap . Each of snap and snap include versions of file and file that correspond to the versions of file and file at the times that snapshot one and snapshot two were created.

In one embodiment the .snapshot subdirectories are virtual directories that are not explicitly represented on disk. Information necessary to create the snapshot data found in each virtual directory can be found by consulting the inode of the parent of the virtual directory and the snapshot tracking data structures associated with each snapshot version of the files and or directories nested within the parent. The virtual directory can be created by a determining which snapshots govern each of the files and directories and b accessing the data associated with each version. In some embodiments to preserve the intuitive feel of the file system the subdirectories to the .snapshot directories that specify the snapshot version for example snap snap and snap are also virtual directories. In other embodiments the .snapshot directories and or their subdirectory s are non virtual directories that are explicitly represented on disk.

In the depicted embodiment the fields in the inode metadata structure include but are not limited to the mode field the LIN field the last snapshot identifier field last snapshot ID and the governance list field . In other embodiments the metadata structure may include fewer or more fields such as a reverse lookup hint field a name field and or a field indicating the amount of data referenced by the inode. In addition the metadata structure may be stored using a different type of data structure.

The governance list field includes all of the snapshot IDs that govern the particular inode. In other words if the inode corresponds to a version s of a file or directory the snapshot ID associated with the version s appears in the governance list of the inode. For example when a snapshot of a file or a directory is created but before any modifications to the file or directory have been made the governance list of the current version will include the snapshot ID of the newly created snapshot. However when that file or directory is modified the inode associated with the snapshot version will have the snapshot ID in the governance list and the current version will store an empty set in its governance list. Accordingly a current version of a file without any snapshot versions will also store an empty set in its governance list. The governance list may be implemented using a variety of data structures known to one with ordinary skill in the art such as a linked list or an array.

The last snapshot ID field includes information about the corresponding file or directory that was modified. After modification the version of the modified file or directory is updated or painted with the global count that is the snapshot ID at the time the modification is made . In one embodiment updating the inode with the global count serves to indicate the last time the governance list of the inode was modified.

In one embodiment the metadata is implemented using an array. In another embodiment the metadata is implemented using a linked list. A person with ordinary skill in the art will recognize that the metadata can be implemented using a variety of data structures.

In one embodiment a snapshot tracking data structure or snapshot tracking file is created each time a snapshot is created. Accordingly a snapshot tracking file is associated with each snapshot. The snapshot tracking file provides information regarding each file or directory governed by a snapshot that was modified or deleted after the snapshot was taken.

In one embodiment the snapshot tracking file can be used to determine which files and directories of a particular version are examined when deleting a snapshot. In another embodiment the snapshot tracking file can be used to track information about a particular snapshot. This information may include but is not limited to disk usage.

In one embodiment the snapshot tracking file LIN field is a unique identifier associated with the snapshot tracking file and is similar in purpose to the LIN associated with a file or a directory.

In one embodiment the snapshot ID field is the genesis snapshot ID of the snapshot that the snapshot tracking file corresponds to. In one embodiment the genesis snapshot ID is equal to the global count at the moment the corresponding snapshot was created. In another embodiment the snapshot ID field is equal to the time or a representation of the time that the snapshot was created. In yet another embodiment the snapshot ID field is some other identifier that indicates a correspondence with a related snapshot.

In one embodiment the LIN field s stores the LINs associated with files or directories that have been modified or deleted from the file system after the corresponding snapshot was created. In another embodiment the LIN field s stores the LINs of files or directories that have been read after the snapshot was created. In yet another embodiment the LIN field s stores the LINs of files and directories accessed before a subsequent snapshot is created. While illustrates a set of six LIN fields it is recognized that a wide number of LIN fields may be included and or a variable number of LIN fields may be used depending on the number of modified LINs.

In one embodiment the snapshot tracking file is a fixed length array that stores empty sets for LIN fields that have not yet been populated. In other embodiments the snapshot tracking file is a linked list that adds entries each time a file or directory is modified or deleted. A person with ordinary skill in the art will recognize that a snapshot tracking file can be implemented using a variety of suitable data structures.

In one embodiment the LIN table comprises a plurality of rows . Each row stores data for a particular version of a file or a directory. Each row is comprised of several fields which may include but are not limited to a LIN field a snapshot ID field a mini snapshot flag and a reference or pointer field . In another embodiment the LIN field and the snapshot ID field comprise a single field. For example the LIN snapshot ID pair may be represented using a sixteen byte binary value with the LIN occupying the most significant bits of the sixteen byte value and the snapshot ID occupying the least significant bits. In another embodiment the LIN table may include fewer or more fields such as for example the mode the governance list the creation date and so forth.

The LIN field includes the LIN of the inode version that a particular row in the LIN table references.

The snapshot ID field includes the genesis snapshot ID of the inode version that a particular row in the LIN table references.

In one embodiment the mini snapshot flag field indicates whether a directory is a mini snapshot rather than a version of a directory in the file system. In some embodiments a mini snapshot is indicated when the flag is set. In other embodiments a mini snapshot is indicated when the flag has been cleared.

In one embodiment the reference field includes a pointer to the inode that corresponds to a LIN snapshot ID pair represented in the LIN table. For example row includes the LIN snapshot ID pair which points to inode . Accordingly inode four hundred fifty includes in its metadata the same LIN . Also inode four hundred fifty includes a governance list that provides a representation of the snapshots that govern this version of inode four hundred fifty. In one embodiment the governance list does not store the same value s as the genesis snapshot ID stored in the LIN table .

In some embodiments the LIN table references inodes that further reference metatrees . Metatrees are data structures specific to a version of a file or directory. In one embodiment metatrees associated with a directory inode store references to the children of the inode. For example the metatree for inode four stores references to children with LIN one hundred LIN five thousand and LIN nine thousand . Thus the current version of inode four has three children. Metatree has only one entry because it is a mini snapshot for a file or directory nested within inode one hundred. Therefore though the current version and a previous version indicate that inode four has three children the inode associated with the mini snapshot only references the child necessary to access data governed by snapshot .

Row in the LIN table has the mini flag set in the mini snapshot flag field . In the depicted embodiment when the flag is set the row in the LIN table references a mini snapshot. Accordingly row references inode which is a mini snapshot associated with snapshot ID . In one embodiment the metadata for an inode associated with a mini snapshot does not include a governance list. In this embodiment a governance list is not needed because no data stored in the data blocks of the inode can be altered because subsequent versions of mini snapshots cannot exist. That is mini snapshots are only used to facilitate downward navigation to snapshot data.

Row in the LIN table references inode . In one embodiment the snapshot ID associated with row is MAX INT. MAX INT represents a binary value wherein all of the bits are set for example all bits are set to 1 . In one embodiment the value MAX INT is used to represent the current version of a file or directory. For example whenever the user wishes to modify a file or directory with snapshot ID MAX INT the user knows that the current version of the file is being modified. In another embodiment the current version can be assigned a snapshot ID wherein all bits are cleared for example all bits are set to 0 . In a further embodiment the current version can be assigned a snapshot ID with an empty set or some other representation that identifies the current version.

In one embodiment each row is implemented using a fixed length array. In another embodiment each row is implemented using a linked list. In yet another embodiment the rows are associated with one another using an array or a linked list. A person with ordinary skill in the art will recognize that the LIN table can be implemented using a variety of different data structures.

Next a snapshot tracking file is created with fields including for example the snapshot ID field and the LIN field s empty. Then the global count is accessed and added to the snapshot ID field of the snapshot tracking file .

After the snapshot tracking file has been created and the global count added decision block determines whether the root of the snapshot is also the root of the file system. If it is the root of the file system the operations in blocks and can be skipped. However if it is not the root of the file system a for loop for all ancestors of the root of the snapshot to the root of the file system is initiated.

For all of these ancestors a mini snapshot is created . In one embodiment creating a mini snapshot includes two steps. First an inode is created. The inode comprises at least a mode field and a LIN field. In one embodiment the mode field indicates that the inode is associated with a directory because in the exemplary embodiment files cannot have children. In other embodiments where either files or directories may have children the mode field indicates either a file or a directory. The LIN field indicates the LIN of the corresponding ancestor of the root of the snapshot. Second a reference is created that points to a child of the ancestor in the path to the root of the snapshot. In some embodiments a mini snapshot is a virtual data structure that is created when a snapshot version with mini snapshots is accessed.

In one embodiment after the mini snapshots for all ancestors up until but not including the root have been created the for loop ends . In another embodiment the for loop ends when mini snapshots have been created for all ancestors including the root directory. After the for loop ends the genesis snapshot ID is added to the governance list of the inode associated with the current version of the root of the snapshot .

In another embodiment multiple paths to multiple roots of a snapshot are accepted. It is recognized that a person with ordinary skill in the art would be capable of modifying process to accommodate a snapshot that has multiple roots.

While illustrates one embodiment of a create snapshot operation it is recognized that other embodiments may be used. For example the inputs and outputs may be passed as values references and or stores in an accessible memory location.

The process of modifying a file or directory begins by executing the painting operation depicted in . After the painting process terminates decision block determines whether the file or directory that will be modified is governed by a snapshot. The painting process in part can determine whether the file or directory is governed by a snapshot. If the file or directory is governed by a snapshot then the create snapshot version of file or directory process is executed. However if the file or directory is not governed by a snapshot the create version of file or directory process is skipped.

Next decision block determines whether a file or a directory is being modified. If a file is being modified the file COW process is executed. However if a directory is being modified the directory COW process is executed. Then after either the file COW process or the directory COW process finishes executing the operation ends .

While illustrates one embodiment of a create snapshot operation it is recognized that other embodiments may be used. For example the inputs and outputs may be passed as values references and or stores in an accessible memory location.

In one embodiment the painting process begins at decision block by asking whether the last snapshot ID stored in the file or directory to be modified or target file dir is less than the global count. As discussed previously the global count can be used to indicate the relative time when a snapshot was created or when the governance list of a particular inode was updated. Thus in the depicted embodiment the global count is a value that is greater than or equal to any snapshot ID stored in the system. If the last snapshot ID is not less than the global count then we know that the snapshot ID is equal to the global count and the governance list of the inode is therefore up to date. Then the process ends .

However if the last snapshot ID is less than the global count two variables are initialized EXAMINED MINIMUM last snapshot ID 1 and EXAMINED DIRECTORY parent inode of the target file dir. Next a while loop initiates and executes the operations nested within it while EXAMINED MINIMUM is less than or equal to the global snapshot count. Therefore even if the snapshot ID was one less than the global count the operations in the while loop will execute at least once because EXAMINED MINIMUM must be greater than the global snapshot count to terminate the while loop .

Next a for loop considers each inode version of the EXAMINED DIRECTORY. Within for loop is nested for loop which considers snapshot ID in the governance list of the considered inode version.

Thus for each snapshot ID of a particular inode version decision block asks whether the snapshot ID is greater than or equal to EXAMINED MINIMUM. If it is not the next snapshot ID is considered . In other words if the snapshot ID is not greater than or equal to EXAMINED MINIMUM the governance list of the target file dir was updated after the particular snapshot was taken. Thus the snapshot ID is ignored because it would already be included in the governance list of the target file dir.

However if the snapshot ID is greater than or equal to EXAMINED MINIMUM the snapshot ID is added to the governance list of the target file dir . In other words the snapshot associated with the particular snapshot ID is more recent than the last time the target file dir was painted . Thus the governance list of the target file dir is updated .

Next after each snapshot ID in a particular version has been considered the for loop ends and the next version of EXAMINED DIRECTORY as dictated by for loop is considered. Then after all of the snapshot IDs of all of the inode versions of EXAMINED DIRECTORY have been considered for loop ends .

Decision block then determines whether EXAMINED DIRECTORY is the root of the file system. If it is the root of the file system the while loop breaks . After breaking the last snapshot ID field of the target file dir is updated with the global snapshot count to indicate when it was last painted. Then the painting process ends.

However if EXAMINED DIRECTORY is not the root of the file system EXAMINED MINIMUM is assigned a value equal to the greater of EXAMINED MINIMUM and last snapshot ID of EXAMINED DIRECTORY 1 . In other words block determines whether the EXAMINED DIRECTORY or the child of the EXAMINED DIRECTORY which was previously considered by for loops and was last painted. Then if EXAMINED DIRECTORY is not out of date as determined by the global snapshot count and the condition presented in the while loop EXAMINED DIRECTORY is updated to be the parent of the previous EXAMINED DIRECTORY given these conditions a trivial operation and the while loop ends because EXAMINED MINIMUM is equal to the global count. Then the last snapshot ID field of the target file dir is updated with the global count to indicate when it was last painted and the process ends .

Alternatively if EXAMINED MINIMUM is still less than or equal the global snapshot count the operation of reassigning EXAMINED DIRECTORY to the parent of the previous EXAMINED DIRECTORY is meaningful because the snapshot IDs of all inode versions of the new EXAMINED DIRECTORY are considered in order to update the governance list of the target file dir . The while loop persists until one of two conditions occur the EXAMINED DIRECTORY is the root of the file system or the EXAMINED DIRECTORY is one that is not out of date . When either of these conditions occur as explained above the last snapshot ID of the target file directory is updated and the process ends .

While illustrates one embodiment of a painting operation it is recognized that other embodiments may be used. For example the process may also paint ancestors of the target file dir or may use other looping instructions. Alternatively the inputs and outputs may be passed as values references and or stores in an accessible memory location.

In one embodiment the creating a snapshot version process begins by adding the LIN of the target file dir to the snapshot tracking file associated with the governing snapshot . As stated previously a list of all modified files or directories governed by a snapshot can be used when deleting the snapshot or performing other functions. Next the inode of the target file dir is copied . The copy is then added to the LIN table . The LIN table stores the UN of the target file dir and the highest snapshot ID in the governance list of the file to be modified. Then the create snapshot version process ends.

While illustrates one embodiment of a creating a snapshot version operation it is recognized that other embodiments may be used. For example the inputs and outputs may be passed as values references and or stores in an accessible memory location.

In the depicted embodiment the process begins in decision block which determines whether there is a previous version of the target file. If there is not a previous version of the target file the version of the target file can be modified without performing a COW. A COW is unnecessary when a version of the target file does not have a previous version because that version does not need to be preserved. After the version of the target file has been modified the process ends .

However if there is a previous version of the target file decision block asks whether there is a ditto record or indicator for the block address location s BADDR to be modified in the previous version. As used herein BADDRs are used to refer to the physical address of a data block on disk. In the illustrated embodiments files are comprised of inodes which store the metadata. The inode references a plurality of BADDR locations stored in a metatree. The BADDR locations can either point to a data block located on a physical disk or reference the next version of the target file referred to herein as a ditto record . If a BADDR location is accessed and it includes an address then it will use the address to locate data on the physical disk. However if the BADDR location includes a ditto record the process will look to that BADDR location in the metatree of the next most recent version. If a ditto record is located in that BADDR location the process will look to the BADDR location in the metatree of the same BADDR location in the metatree of the next most recent version. This process continues until a BADDR location is reached that includes an address. Then the data is retrieved from the physical disk or the cache.

In one embodiment the metatree is comprised of an array. In other embodiments the metatree is comprised of a linked list. In yet other embodiments the metatree is comprised of a hybrid of a linked list and a plurality of arrays. A person with ordinary skill in the art will recognize that other data structures are considered suitable for storing information related to file data.

In decision block if a ditto record is not found at a BADDR location s an address has been found. Thus the data has already been COWed to the BADDR location s . In other words the corresponding BADDR location s has been modified at least once the snapshot was created. Therefore the BADDR location s can be modified in the current version directly and the process ends .

However if a ditto record exists at the BADDR location s the ditto record is removed . Then data from the BADDR location s of the target file is copied to the BADDR location s of the previous version . Next the BADDR location s of the target file are modified and the process ends .

While illustrates one embodiment of a file COW operation it is recognized that other embodiments may be used. For example the inputs and outputs may be passed as values references and or stores in an accessible memory location. Additionally other embodiments may represent and store data common to more than one version using different data structures such as for example using a physical model a hybrid model or a log based model.

In the depicted embodiment process begins in decision block by determining whether the entry is being added to a target directory or whether an entry within the target directory is being modified or removed. In one embodiment if an entry is being added to the current version it is unnecessary to COW the new entry because previous versions of the target directory do not include the new entry. Consequently the entry can be added to the metatree associated with the target directory . Then the genesis snapshot ID of the entry in the metatree of the target directory is set to the global snapshot count and the process ends .

If however an entry in the target directory is being modified or removed decision block asks whether the genesis snapshot ID of the entry is more recent than the most recent snapshot ID in the governance list of the target directory. If the snapshot ID of the entry is more recent than the most recent governing snapshot the entry is not governed by a snapshot. Therefore the entry can be removed or modified without COWing the entry to a previous version of the target directory.

However if the snapshot ID of the entry is not as recent as the latest governing snapshot the entry is copied to the next most previous version of the target directory before the target directory can be removed or modified . In some embodiments the entry is copied to the same location in the metatree of the previous version.

After the target directory has been modified the genesis snapshot ID of the entry is set to the global count and the process ends .

While illustrates one embodiment of a directory COW operation it is recognized that other embodiments may be used. For example an entry may be added removed or modified in any version of the directory. Additionally the inputs and outputs may be passed as values references and or stores in an accessible memory location.

The delete snapshot process begins by accepting a delete snapshot request from a user client application application or other source. Next a for loop considers all files and or directories in the snapshot tracking file. As previously discussed in one embodiment the snapshot tracking file comprises a list of all files and directories that were modified or deleted after the snapshot was created.

For each considered file decision block asks whether a previous snapshot governs the snapshot to be deleted. If there is not a previous governing snapshot the snapshot version of the considered file or directory can be deleted . In one embodiment the version of the file or directory is deleted without any copy operations because previous versions do not store data referenced by future versions.

Next the inode associated with the snapshot of the considered file or directory is deleted . Then the LIN snapshot ID pair for the considered version of the file or directory is deleted from the LIN table . Then for loop considers the next file or directory in the snapshot tracking file.

However in decision block if there is a previous snapshot decision block asks whether a file or directory is being considered by the for loop . If a file is being considered data is copied to BADDR locations in a previous version of the file if the particular BADDR location includes a ditto entry referencing the deleted snapshot.

If however decision block considers a directory for loop considers each file or directory referenced by the directory considered by for loop . For each referenced file or directory process considers whether the snapshot ID of the referenced file or directory is less than or equal to the highest snapshot ID in the governance list of the previous snapshot . If it is the reference to the file or directory is copied to the previous version. This comparison of snapshot IDs determines whether the referenced file or directory was created after the next most previous snapshot was created. Thus if the referenced file or directory was created after the previous snapshot then COWing the referenced file or directory is unnecessary because the referenced file or directory did not exist at the time the previous snapshot was created. After all of the referenced files or directories have been considered the for loop ends .

After the file or directory in the snapshot tracking file has been COWed operations and execute. Then after all of the files and directories in the snapshot tracking file have been considered the for loop ends . Next the snapshot tracking file associated with the snapshot is deleted and the delete snapshot process ends .

While illustrates one embodiment of a delete snapshot operation it is recognized that other embodiments may be used. For example the inputs and outputs may be passed as values references and or stores in an accessible memory location.

In one embodiment the read file process begins by receiving the LIN of the file version to be read and the snapshot ID of the file version . In another embodiment the path to the file version is received. In one embodiment the snapshot ID of the file version is stored in an in memory cache structure. In embodiments that utilize the user interface described with respect to the path includes a .snapshot subdirectory if a snapshot version is sought.

Next the process gets the inode that corresponds to the received LIN snapshot ID pair. This step can be performed using lookup techniques known to those with ordinary skill in the art.

After the inode has been retrieved a for loop considers each BADDR location in the portion of the metatree being read. Then for each BADDR location decision block asks whether there is a real BADDR record exists. If a real BADDR record exists the process looks up the BADDR on the physical disk and retrieves data. However if a real BADDR record does not exist the process reads the next inode version . Again the process will determine if a real BADDR record exists in the next version . The process will continue looking to subsequent versions until it finds a real BADDR record in the considered BADDR location. When a real BADDR record is found the process looks up the BADDR on the physical disk and retrieves the data.

After all of the BADDR locations in the portion of the metatree being read have been considered the for loop ends and the read file process ends .

While illustrates one embodiment of a read file operation it is recognized that other embodiments may be used. For example the inputs and outputs may be passed as values references and or stores in an accessible memory location.

In one embodiment the directory lookup process begins by receiving a target file or directory. The target file or directory is the version of a file or directory a user or client application wishes to access from a particular snapshot. Next the process receives the LIN snapshot ID of the particular snapshot the relevant snapshot of a parent directory the relevant directory that may or may not include the target file or directory.

Then a for loop considers all snapshots of the relevant directory that have a snapshot ID greater than or equal to the snapshot ID of the relevant snapshot. In one embodiment the range of snapshots are considered from oldest to newest. Considering the snapshots in this way can speed up the lookup operation for target files or directories that have been modified frequently. That is if the target file or directory has been modified frequently the COWed version of the target file or directory is more likely to appear as an entry in an older version of the relevant directory rather than a newer version of the relevant directory. In other embodiments the for loop considers the range of snapshots from newest to oldest. Considering snapshots in this order is more efficient for target files directories that are rarely if ever modified because they are more likely to appear in a newer version of the relevant directory.

For the snapshot being considered the process performs a lookup in the metatree of the relevant directory for the target file or directory. In other embodiments the lookup may be performed in another data structure that stores entries corresponding to the children of the relevant directory.

Next decision block asks whether an entry matching the target file or directory is found in the metatree of the considered version of the relevant directory. If it is not the next snapshot is considered and the lookup is repeated . However if a matching entry is found in the considered version decision block asks whether the genesis snapshot ID of the matching entry is less than the snapshot ID of the relevant version. If the genesis snapshot ID of the entry is less than the snapshot ID of the relevant version the for loop breaks and the location or path of the appropriate version of the target file or directory is returned . Then the process ends .

However if the genesis snapshot ID of the matching entry is not less than the snapshot ID of the relevant version the matching entry was a version created after the relevant snapshot and was therefore not an entry in the relevant version of the relevant directory. The process then considers the next snapshot within the range. If the for loop considers every snapshot within the range and is unable to find a matching entry with a genesis snapshot ID less than the snapshot ID of the relevant version the for loop ends . Thus the process returns an indication that the target file or directory was not found .

While illustrates one embodiment of a directory operation it is recognized that other embodiments may be used. For example the inputs and outputs may be passed as values references and or stores in an accessible memory location.

Because the depicted embodiment returns only one entry from the relevant version at a time an index is used. The index serves as a bookmark that indicates which entry in the relevant version the read directory operation returned last. In the depicted embodiment the bookmark is implemented using a variable named NEXT INDEX. In one embodiment NEXT INDEX is the key of the directory entry in the B tree structure of the relevant directory. It will be appreciated by one with skill in the art that the key is a value that is a identifier of the entry that is unique to at least one of a file system a B tree a storage node and a storage device. Accordingly NEXT NAME is the name of the entry that has a key equal to NEXT INDEX.

Additionally because the read directory operation returns one entry at a time the process returns an entry in response to an index value PREVIOUS INDEX that corresponds to the key of the last entry returned by the operation. The use of PREVIOUS INDEX helps ensure that process does not return entries that were previously returned. Thus process is a function of PREVIOUS INDEX.

The process begins by receiving the snapshot ID of the relevant snapshot . Then the process gets all snapshots with snapshot IDs greater than or equal to the snapshot ID of the relevant snapshot . In one embodiment the process retrieves this range of snapshots because entries for a particular version of a directory are stored either as an entry in that directory version or in subsequent versions. Thus the process looks at the relevant version or look ahead to retrieve entries located within the relevant version. After the inodes are retrieved the process creates the variable NEXT NAME and the variable NEXT INDEX initializing it to a value of MAX INT .

Then a for loop considers each of the retrieved inodes. Next a nested for loop considers each entry in the version considered by for loop starting at a location in the relevant directory corresponding to PREVIOUS INDEX 1.

Decision block asks whether the index of the considered entry is greater than NEXT INDEX. For the first entry considered the index of the entry will not be greater than NEXT INDEX because NEXT INDEX is initialized to MAX INT. However for subsequent considered entries if the index of the entry is greater than NEXT INDEX the for loop breaks and the next version of the relevant directory is considered .

If the index of the considered entry is not greater than NEXT INDEX decision block asks whether the genesis snapshot ID of the entry is less than or equal to the snapshot ID of the relevant version. If it is not the next entry in the version is considered .

However if the genesis snapshot ID of the considered entry is less than or equal to the snapshot ID of the relevant version the entry was created before the relevant version and is therefore a child of the relevant version of the relevant directory. Thus NEXT NAME is assigned a value that corresponds to the name of the considered entry and NEXT INDEX is assigned a value that corresponds to the index of the entry . Next for loop breaks and the next inode version is considered . However if all of the entries in the considered version have neither an entry index greater than NEXT INDEX nor a genesis snapshot ID less than or equal to the snapshot ID of the relevant version for loop ends and the next version is considered .

Even if the operation of block executes in a previous iteration of for loop the next version is considered because there could exist an entry that has an index that is greater than PREVIOUS INDEX 1 but less than the present value of NEXT INDEX. After all versions of the relevant directory within the range have been considered for loop ends . Next decision block asks whether NEXT NAME stores a value. If it does store a value an entry within the relevant version with an index greater than PREVIOUS INDEX was found and the process returns NEXT NAME and NEXT INDEX . However if NEXT NAME does not store a value no entry in the relevant version with an index greater than PREVIOUS INDEX was found and the process returns NO MORE ENTRIES EXIST .

While illustrates one embodiment of a directory operation it is recognized that other embodiments may be used. For example all entries may be returned by recursively calling operations and reassigning PREVIOUS INDEX to equal NEXT INDEX each time the operations are called. Additionally the inputs and outputs may be passed as values references and or stores in an accessible memory location.

In the embodiment discussed above inodes associated with files reference BADDR locations in a metatree that store either real BADDR records or ditto records which reference the next version of the file. For ease of reference this file structure implementation will be referred to as the logical model. However it is recognized that other file structure implementations exist such as for example a physical model a hybrid model and a log based model. Each of these models is described in detail below.

The snapshot version of the file only references data blocks on the physical disk that have been modified and thereby COWed since the snapshot was created. Accordingly because BADDR locations were modified BADDR locations reference data blocks . The remaining BADDR locations in the snapshot version include ditto records which reference the next most recent version . Accordingly ditto records such as and can represent large amounts of data by acting as a compact place holder.

The snapshot version of the file references data blocks in the same way that the current version references data blocks. BADDR locations references the same data blocks as BADDR locations because the data was not modified after the snapshot was created and BADDR locations similarly reference the same data blocks as BADDR locations . However BADDR locations reference different data blocks than BADDR locations because this portion of the file was modified and consequently COWed. Accordingly BADDR locations reference data blocks .

The physical model offers identical snapshot version and current version read times because real BADDR locations are stored in all BADDR locations of the snapshot version. That is the indirection of the physical model is not present. However the physical model may be less desirable than the logical model because unchanged portions of the metatree cannot be compactly stored using ditto records.

The hybrid model may be more desirable than the logical model when a large number of snapshots have been modified frequently because the indirection in between data structured in the logical model may slow down read operations. However lookups for delete snapshot operations in a potentially large metatree of the hybrid model may be computationally expensive.

The log based model may be more desirable than the other models because snapshot data can be stored compactly permitting tracking of even single byte modifications. However the log based model may be less desirable than the other models because read operations are more computationally expensive.

Before the snapshot governed the file the governance list of the file stored an empty set indicating that no snapshots govern the file. Reference to illustrates the creation of the snapshot of the file shown in . The process received the path of the file as the root of the snapshot. Next a snapshot tracking data structure not shown in was created that corresponds to the snapshot taken of the file . The global count at the time the snapshot was created is added to the snapshot tracking data structure . This value is the snapshot ID. In this example the snapshot ID is .

Because the file is not the root of the file system a mini snapshot is created for each of the ancestors of the file to the root of the file system . Next the snapshot ID is added to the governance list of the inode associated with the current version of the file . Thus though the governance list of the snapshot was formerly an empty set the snapshot of the file is created once the snapshot ID is added to the governance list of the file s inode .

Additionally the LIN table includes an entry that references the current version of the file. The entry indicates the LIN of the file and the genesis snapshot ID of the inode MAX INT. MAX INT is used to indicate that the entry references the most current version of the file. In the depicted embodiment the LIN table does not include an entry for snapshot ID either before or after snapshot creation because the current version was not modified after the snapshot was created. In this embodiment if a user or client application wishes to access snapshot a lookup in the LIN will reveal no entry for snapshot and consequently the inode with the next highest snapshot ID MAX INT is accessed. In other embodiments the LIN table may include an entry with LIN and genesis snapshot ID that references the current version of the file. In other words there would be two entries in the LIN table that reference the same inode.

When the second snapshot was created process of was executed in a similar manner as described above with respect to snapshot . For this snapshot the global count was at the time the second snapshot was created. Therefore the governance list of the inode associated with the current version listed snapshot IDs and . Immediately after snapshot was created the LIN table did not change. Thus a lookup for snapshot ID would yield no match and the next highest snapshot ID MAX INT would be accessed.

Next the data associated with BADDR locations in the current version were modified. Reference to illustrates the relevant operations for modifying the current version of the file. The process begins by calling the painting process depicted in . In the painting process decision block asks whether the snapshot ID of the target file dir is less than the global count. Because we assume that the global count is the snapshot ID is equal to the global count. Thus the operations of the painting process are not required and process ends .

Next decision block asks whether the file is governed by a snapshot. The governance list of the current version indicates that both snapshots and govern the current version of the file. Thus the create snapshot version of file dir process is called. First the LIN of the file is added to the tracking file of the governing snapshot not shown . Next the inode of the file is copied . The copy of the inode is represented by data structure in . Accordingly the inodes of the current version and snapshot version differ in that the snapshot version is governed by snapshot IDs and whereas the current version is no longer governed by a snapshot. Finally the LIN of the snapshot version is added to the LIN table . As depicted LIN with snapshot ID is added to the LIN table. Notably snapshot ID does not have to be added to the LIN table because snapshots and reference the same metatree locations.

Then decision block asks whether a file or a directory is being modified. Because a file is being modified the file COW process of is called. The file COW process first asks whether a previous version of a file exists . In this example previous versions corresponding to snapshot IDs and exist. Thus decision block asks whether there is a ditto record for the BADDR locations to be modified in the previous version. Because there have been no previous modifications to the file all BADDR locations in the previous version include a ditto record. Thus the ditto record from BADDR locations in the snapshot version are removed and the original data from BADDR locations in the current version are copied to BADDR locations in the snapshot version . Next the BADDR locations in the current version can be modified . Thus the snapshot version includes ditto records for BADDR locations and . BADDR locations includes references to the portion of the physical disk that stores the COWed data.

As discussed above with respect to the snapshot creation process adds the snapshot ID of the snapshot to the governance list of the current version . Assuming that the global snapshot count at the time the snapshot is taken is snapshot ID is added to the governance list of the current version and a snapshot tracking file associated with snapshot not shown is created.

Next a user or client application wishes to modify the data associated with BADDR locations in the current version. Assuming that the global count is the painting process is bypassed because the snapshot ID is equal to the global count . Next the LIN is added to the snapshot tracking file associated with snapshot the inode of the current version is copied so as to correspond to snapshot and the new inode is added to the LIN table . As shown the LIN table includes new row with the LIN snapshot ID pair . This row points to the inode associated with snapshot .

Next because a file is being modified the file COW process is called. Because there exists a previous version of the file with a ditto record in the BADDR locations to be modified the data in BADDR locations from the current version are copied to BADDR locations of snapshot . Next the data associated with BADDR locations in the current version may be modified. Thus in snapshot BADDR locations include a reference to the physical disk and BADDR locations include ditto records.

Notably in order to modify the current version governed by snapshot changes to the metatrees associated with snapshot IDs and are not required. Therefore snapshot version is read in the following way for BADDR locations the ditto record references version which includes references to the physical disk for BADDR locations ditto records in version and reference the current version which includes references to the physical disk BADDR locations include direct references to the physical disk and for BADDR locations ditto records in version and reference the current version which includes references to the physical disk. Therefore to read the entire contents of version the metatrees for version version and the current version need to be accessed.

Then the inode and metatree associated with version can be deleted and the reference in the LIN table to snapshot can be deleted . In other embodiments the entire row in the LIN table may be deleted. Because only one file was under consideration for loop ends and the snapshot tracking file associated with snapshot is deleted.

After the deletion of snapshot a read operation on version proceeds in the following manner. First the inode of the file is received and each BADDR location in the region being read is considered. For locations data can be accessed by performing a lookup of the BADDR locations on the physical disk because a real BADDR record exists for these locations. However for BADDR locations the next inode version needs to be read to find a real BADDR record. Thus a lookup on the physical disk relies on real BADDR records . Similarly a read on BADDR locations occurs in a similar way to BADDR locations because a real BADDR record exists. A read on BADDR locations occurs in a similar way to BADDR locations because a ditto record exists.

Assuming the global snapshot count is at the time the first snapshot of dir is created creation of a snapshot with a root of dir first creates a snapshot tracking file and adding snapshot ID to the snapshot tracking file . Then a mini snapshot for each parent of dir to the root is created because dir is not the root of the file system . Next snapshot ID is added to the governance list of the current version of dir .

Then the directory COW process is executed because a file included in dir is being modified. When removing an entry the directory COW process asks whether the genesis snapshot ID of file is more recent than the snapshot . Because the genesis snapshot ID of file is and the governing snapshot ID is the entry for file is copied to the same key location in the metatree for snapshot . Next file is removed from the current version . Generally after a file is modified the genesis snapshot ID of the file in the current version is set to the global snapshot count . However in this example the genesis snapshot ID for file is not set to the global snapshot count because file was deleted from the current version.

As discussed above with respect to snapshot is created by adding snapshot ID to the governance list of the current version. Additionally a snapshot tracking file with snapshot ID is created. Then when a request to modify file is accepted the inode of the current version is copied. The copied inode includes the snapshot ID in its governance list and the governance list of the current version includes an empty set. Before file can be modified it is copied to snapshot because its snapshot ID is greater than genesis snapshot ID of file. After the COW is complete file is modified in the current version . Accordingly the genesis snapshot ID of file in the current version is set to global count indicating when file was last modified.

Next file with LIN is added to dir when the global count was . illustrates how an entry may be added to a directory governed by a snapshot. First the entry is added to the metatree associated with the inode of the current version .

Then in the LIN table the snapshot ID for the entry is the same as the snapshot ID of the current version . Also the genesis snapshot ID of file in the metatree of the current version of dir is set to the global count.

In order to perform a lookup operation for a particular file or directory in a particular version of dir the directory lookup process first receives the target file or directory and the LIN snapshot ID pair of the relevant directory . For example assume that the target file or directory is file and that the lookup operation is directed to the version of dir snapshot ID pair .

For loop first examines snapshot and determines that there is no matching entry in the local portion of the tree . Next snapshot is considered. A matching entry for file exists in the local portion of the tree . Thus to determine if the matching entry was included in the current version of dir decision block asks whether the snapshot ID is less than the snapshot ID of the relevant version. Here the snapshot ID for file in snapshot is and the snapshot ID of the relevant version is . Therefore the for loop breaks and the location and or the path of file with genesis snapshot ID is returned.

In order to perform a read directory operation for a particular version of dir the read directory process first receives the inodes for the snapshot versions that have snapshot IDs greater than the snapshot ID of the relevant version. For example assume that the read directory operation is directed to snapshot of the dir . Accordingly the inodes for snapshot and the current version are received. To retrieve each entry in version of dir the read directory operation examines each entry in each received inode version . If the genesis snapshot ID of the considered entry is less than or equal to the snapshot ID of the relevant version the process returns the name of the entry . However if the snapshot ID of the entry is greater than the snapshot ID of the relevant entry the process considers the next entry .

In the illustrated example the process first considers file in version . It is returned as an entry in this version of dir because its snapshot ID is less than the relevant snapshot ID . Similarly the snapshot ID of each entry in the current version is considered. Therefore dir is the only entry returned because the entries for file and file each have snapshot IDs greater than the snapshot ID of the relevant version. Thus a read directory operation for the entire contents of snapshot version of dir would indicate that dir includes file with genesis snapshot ID and dir with genesis snapshot ID .

While certain embodiments of the invention have been described these embodiments have been presented by way of example only and are not intended to limit the scope of the present invention. Accordingly the breadth and scope of the present invention should be defined in accordance with the following claims and their equivalents.

By way of example the following alternatives are also contemplated. Although the data structures described herein have been directed to a distributed system some embodiments of the invention may be used in a single file system. Additionally or alternatively it will be recognized by one with ordinary skill in the art that the depicted embodiments may be modified to accommodate file structures under the logical model physical model hybrid model and or log based model. Further in addition to adding the snapshot ID to the root of the snapshot upon snapshot creation the snapshot ID may be added to some or all of the files and directories governed by the snapshot. Additionally it is recognized that the root of a snapshot can be a single file or directory or more than one file or directory. Embodiments of systems and methods for performing a reverse lookup are disclosed in U.S. patent application Ser. No. 11 507 075 now U.S. Pat. No. 7 590 652 issued Sep. 15 2009 titled SYSTEMS AND METHODS OF REVERSE LOOKUP filed Aug. 18 2006 and hereby incorporated by reference in its entirety.

The above mentioned alternatives are examples of other embodiments and they do not limit the scope of the invention. It is recognized that a variety of data structures with various fields and data sets may be used. In addition other embodiments of the flow charts may be used.

