---

title: Scalable push-based architecture for web applications
abstract: Disclosed is a fully push-based and scalable web application architecture unifying discrete and persistent web services. It houses a database slave on the web server machine to leverage the replication capabilities of common database systems. In doing so, the replication of data between a database master (located on a separate machine) and a slave (located on the web server machine) serves to prompt the web server software of any changes in the data, with which it may then generate an updated web service response to push to the relevant clients. Neither the clients nor the web servers ever need to blindly poll a data source for changes. Furthermore, data is transmitted in the same RESTful style using a persistent (i.e. WebSocket) connection as it would be using the corresponding discrete HTTP request.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09137288&OS=09137288&RS=09137288
owner: Yahoo! Inc.
number: 09137288
owner_city: Sunnyvale
owner_country: US
publication_date: 20101220
---
The present disclosure relates to web applications and more specifically to a scalable push based architecture for web applications.

The architecture used by large scale web applications is ill suited to serve clients in need of long lived persistent connections. Traditionally web content has been delivered via short lived discrete connections initiated exclusively by the client device. For real time applications in which the client monitors web service data for changes over time the industry standard has been to require the client to poll the web service intermittently. With the introduction of persistent connections in the browser i.e. Web Sockets data transmission can occur in real time with changes communicated i.e. pushed by the web server to the client as they occur rather than through polling on the client side. A push based model significantly reduces the amount of data transmitted between client and web server but it also requires that the web server know when changes occur in the data it is serving to the client. Large scale web applications make this difficult because for scale and availability data is typically kept on database servers separate from the web servers with which the client interacts directly. Hence when a request is made by a client device to a web server the web server must similarly poll a database for the data required to respond to the client.

This disclosure provides a fully push based and scalable web application architecture unifying discrete and persistent web services. It houses a database slave on the web server machine to leverage the replication capabilities of common database systems. In doing so the replication of data between a database master located on a separate machine and a slave located on the web server machine serves to prompt the web server software of any changes in the data with which it may then generate an updated web service response to push to the relevant clients. Neither the clients nor the web servers ever need to blindly poll a data source for changes. Furthermore data is transmitted in the same RESTful style using a persistent i.e. Web Socket connection as it would be using the corresponding discrete HTTP request.

In one aspect a server computer receives from a client computer in communication with the server computer a request to update a web resource. The server computer writes the new data to a master database located external to the server computer. A slave database located on the server computer receives from the master database a replication message to update the same data in the slave database. In response to receiving the replication message the web server will regenerate a response for its connected clients and transmit the response if it has changed.

In one embodiment the server computer establishes a persistent connection with the client computer such as via WebSocket. In one embodiment the web resource was previously transmitted by the server computer to the client computer. In one embodiment a hash value is calculated on the web resource and stored in a cache on the web server before transmitting the web resource to the client computer. In one embodiment the receiving of a request to update the web resource further includes receiving the new web resource sent from the client to the web server. In one embodiment the server computer determines if a hash of the new web resource equals the web resource stored in the slave database. In one embodiment the server computer sets the web resource stored in the slave database to a hash of the new web resource. In one embodiment the new web resource is transmitted to a plurality of client computers listening for that web resource.

In one embodiment the updating step represents a state changing e.g. POST PUT DELETE HTTP command from the client computer.

In another aspect a server computer receives from a client computer in communication with the server computer a request to read a web resource. The web resource is retrieved from a slave database located on the server computer and corresponding to a master database located external to the server computer. The server computer transmits the web resource to the client computer.

In one embodiment the retrieving and transmitting steps represent a non state changing HTTP e.g. GET HEAD request from the client computer. In one embodiment a persistent connection is established with the client computer by the server computer.

These and other aspects and embodiments will be apparent to those of ordinary skill in the art by reference to the following detailed description and the accompanying drawings.

Embodiments are now discussed in more detail referring to the drawings that accompany the present application. In the accompanying drawings like and or corresponding elements are referred to by like reference numbers.

Various embodiments are disclosed herein however it is to be understood that the disclosed embodiments are merely illustrative of the disclosure that can be embodied in various forms. In addition each of the examples given in connection with the various embodiments is intended to be illustrative and not restrictive. Further the figures are not necessarily to scale some features may be exaggerated to show details of particular components and any size material and similar details shown in the figures are intended to be illustrative and not restrictive . Therefore specific structural and functional details disclosed herein are not to be interpreted as limiting but merely as a representative basis for teaching one skilled in the art to variously employ the disclosed embodiments.

The present invention is described below with reference to block diagrams and operational illustrations of methods and devices to select and present media related to a specific topic. It is understood that each block of the block diagrams or operational illustrations and combinations of blocks in the block diagrams or operational illustrations can be implemented by means of analog or digital hardware and computer program instructions. These computer program instructions can be provided to a processor of a general purpose computer special purpose computer ASIC or other programmable data processing apparatus such that the instructions which execute via the processor of the computer or other programmable data processing apparatus implements the functions acts specified in the block diagrams or operational block or blocks.

In some alternate implementations the functions acts noted in the blocks can occur out of the order noted in the operational illustrations. For example two blocks shown in succession can in fact be executed substantially concurrently or the blocks can sometimes be executed in the reverse order depending upon the functionality acts involved. Furthermore the embodiments of methods presented and described as flowcharts in this disclosure are provided by way of example in order to provide a more complete understanding of the technology. The disclosed methods are not limited to the operations and logical flow presented herein. Alternative embodiments are contemplated in which the order of the various operations is altered and in which sub operations described as being part of a larger operation are performed independently.

In one embodiment this request is a request to establish a WebSocket connection with the server computer . WebSocket is a technology providing for bi directional full duplex communication channels over a single Transmission Control Protocol TCP socket. To establish a WebSocket connection the first client computer transmits a WebSocket handshake request to the server computer and the server computer sends a WebSocket handshake response to the first client computer . Once a WebSocket connection is established data can be sent back and forth between the first client computer and the server computer in full duplex mode. The WebSocket protocol defines a ws and wss prefix to indicate a WebSocket and WebSocket Secure connection respectively.

In step a persistent connection e.g. via the WebSocket protocol is established between the first client computer and the server computer . The server computer reads the data pertaining to the requested resource from the local slave database step to generate the web resource response widget step . The server computer stores a hash of the web resource response in a cache indexed by the resource identifier e.g. cache widget hash widget step and transmits the response to the first client computer step . The slave database is in communication with a master database externally located from the server computer .

Client computers and are connected to the HTTP and WebSocket interfaces on the server computer . Persistent WebSocket clients are connected with solid lines and discrete HTTP clients are connected with dashed lines. illustrates how the two interfaces interact as part of a unified web service for both persistent and discrete connections.

In one embodiment the server computer reads the requested resource in response to a connection with the client computer . In another embodiment the client computer transmits an explicit read request to the server computer instructing the server computer to read the resource.

The first client computer then transmits a Write request to the server computer to write to the web resource widget . The server computer receives the Write request and a new widget from the first client computer steps and . The server computer writes the new widget to its master database shown with arrow in step . The master database replicates the new widget to the slave database arrow of step . In one embodiment the master database replicates the new widget to one or more other slave databases located on other server computers. The slave database detects the replication as shown with arrow in from the master database step . The server computer then reads the new widget from the slave database step . If hash new widget does not equal cache widget then the server computer sets the cache widget hash new widget . The server computer then transmits the new widget to the first client computer over the persistent connection step . In one embodiment the server computer transmits the new widget to each of the client computers that are listening for that widget as shown with arrows of .

Housing a slave database on the server computer or conversely placing the web server software on the database slave machine to leverage the replication capabilities of the database system provides a fully push based scalable web application solution. The web application listens for triggers from the database master to revalidate requests from clients that are connected persistently to the server computer . This configuration also offers a unifying model for discrete and persistent web services.

Within this model activities on persistent connections e.g. WebSocket connections which begin with an HTTP handshake map to certain conventional HTTP operations. A WebSocket connection to a URI in this case represents a persistent GET request where the client receives updates to the state of the resource as they happen. Meanwhile a client may write to the WebSocket potentially restricted as with any HTTP transaction by its cookie headers or other session information at connection time in which case a POST is performed on the resource. Though a client computer cannot delete a given resource while it is connected persistently to the resource a discrete HTTP DELETE on that resource would effectively disconnect any other client computers which are. By submitting a discrete HTTP GET request to the deleted resource those clients could then discover via a conventional HTTP response code that the resource had been deleted or no longer exists. Thus a custom protocol within WebSockets is not needed when both WebSockets and regular discrete HTTP are available on the client side. This also unifies the model for development of both discrete and persistent web services.

The messages transmitted between the client computer and the server computer are format agnostic so the content of the message whether in an HTTP POST or as a write to the socket can be XML JSON comma separated values hex encoded binary or anything else. In one embodiment the format depends on the format imposed by the server computer . However for a given resource e.g. websocket if a server allows the client computer to write to the resource the write issued by the client computer should be the same format and conform to the same schema if applicable of the content that the server would send to the client on a read request.

For example the resource at www1.yahoo.com widget could be the following XML document sent to the client on a read request 

For example a Representational State Transfer REST web service can be a directory of people. The web service model would in one embodiment look like the following 

Memory interfaces with computer bus so as to provide information stored in memory to CPU during execution of software programs such as an operating system application programs device drivers and software modules that comprise program code and or computer executable process steps incorporating functionality described herein e.g. one or more of process flows described herein. CPU first loads computer executable process steps from storage e.g. memory storage medium media removable media drive and or other storage device. CPU can then execute the stored process steps in order to execute the loaded computer executable process steps. Stored data e.g. data stored by a storage device can be accessed by CPU during the execution of computer executable process steps.

Persistent storage medium media is a computer readable storage medium s that can be used to store software and data e.g. an operating system and one or more application programs. Persistent storage medium media can also be used to store device drivers such as one or more of a digital camera driver monitor driver printer driver scanner driver or other device drivers web pages content files playlists and other files. Persistent storage medium media can further include program modules and data files used to implement one or more embodiments of the present disclosure.

For the purposes of this disclosure a computer readable medium stores computer data which data can include computer program code that is executable by a computer in machine readable form. By way of example and not limitation a computer readable medium may comprise computer readable storage media for tangible or fixed storage of data or communication media for transient interpretation of code containing signals. Computer readable storage media as used herein refers to physical or tangible storage as opposed to signals and includes without limitation volatile and non volatile removable and non removable media implemented in any method or technology for the tangible storage of information such as computer readable instructions data structures program modules or other data. Computer readable storage media includes but is not limited to RAM ROM EPROM EEPROM flash memory or other solid state memory technology CD ROM DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other physical or material medium which can be used to tangibly store the desired information or data or instructions and which can be accessed by a computer or processor.

For the purposes of this disclosure a module is a software hardware or firmware or combinations thereof system process or functionality or component thereof that performs or facilitates the processes features and or functions described herein with or without human interaction or augmentation . A module can include sub modules. Software components of a module may be stored on a computer readable medium. Modules may be integral to one or more servers or be loaded and executed by one or more servers. One or more modules may be grouped into an engine or an application.

Those skilled in the art will recognize that the methods and systems of the present disclosure may be implemented in many manners and as such are not to be limited by the foregoing exemplary embodiments and examples. In other words functional elements being performed by single or multiple components in various combinations of hardware and software or firmware and individual functions may be distributed among software applications at either the client or server or both. In this regard any number of the features of the different embodiments described herein may be combined into single or multiple embodiments and alternate embodiments having fewer than or more than all of the features described herein are possible. Functionality may also be in whole or in part distributed among multiple components in manners now known or to become known. Thus myriad software hardware firmware combinations are possible in achieving the functions features interfaces and preferences described herein. Moreover the scope of the present disclosure covers conventionally known manners for carrying out the described features and functions and interfaces as well as those variations and modifications that may be made to the hardware or software or firmware components described herein as would be understood by those skilled in the art now and hereafter.

While the system and method have been described in terms of one or more embodiments it is to be understood that the disclosure need not be limited to the disclosed embodiments. It is intended to cover various modifications and similar arrangements included within the spirit and scope of the claims the scope of which should be accorded the broadest interpretation so as to encompass all such modifications and similar structures. The present disclosure includes any and all embodiments of the following claims.

