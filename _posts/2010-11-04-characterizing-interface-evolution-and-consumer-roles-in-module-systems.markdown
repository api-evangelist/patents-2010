---

title: Characterizing interface evolution and consumer roles in module systems
abstract: The disclosed embodiments provide a system that facilitates the development and maintenance of a software program. This system includes a software development kit (SDK) and a runtime system for the software program. During operation, the system obtains a role associated with a dependency of a consumer in the software program on an interface. Next, the system obtains a compatibility policy for the interface. Finally, the system uses the role and the compatibility policy to manage use of the interface by the consumer in the software program.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09454360&OS=09454360&RS=09454360
owner: ORACLE INTERNATIONAL CORPORATION
number: 09454360
owner_city: Redwood Shores
owner_country: US
publication_date: 20101104
---
The subject matter of this application is related to the subject matter in a non provisional application by inventors Mark B. Reinhold Alexander R. Buckley Jonathan J. Gibbons and Karen M P Kinnear entitled Polyphasic Modules for Software Development having Ser. No. 12 771 121 and filing date 30 Apr. 2010.

The present embodiments relate to module systems for software development. More specifically the present embodiments relate to techniques for characterizing interface evolution and consumer roles in module systems.

Within software systems increasing sophistication and functionality are typically accompanied by corresponding increases in code size and complexity. For example the addition of new features to a software program may require the implementation of new components which in turn may increase the number of dependencies within the software program. Over time changes to the software program may lead to increases in defects debugging time redundancy and lack of readability. The continued development of a software system without effective complexity management may consequently reduce performance and increase maintenance risk to the point of rendering the software system unusable and or unmanageable.

Issues associated with increasing software complexity may be mitigated by modularizing software systems. Modular software utilizes components that are self contained and that facilitate a separation of concerns. For example individual modules may be developed tested and used independently of each other in a software system. In addition a module s functionality and dependencies may be explicitly declared through an interface provided by the module. Modularized software may thus be significantly more maintainable easier to understand and less complex than monolithic software.

Hence increased use of modularity may improve the design maintenance performance scalability and growth of software systems.

The disclosed embodiments provide a system that facilitates the development and maintenance of a software program. This system includes a software development kit SDK and a runtime system for the software program. During operation the system obtains a role associated with a dependency of a consumer in the software program on an interface. Next the system obtains a compatibility policy for the interface. Finally the system uses the role and the compatibility policy to manage use of the interface by the consumer in the software program.

In some embodiments using the role and the compatibility policy to facilitate use of the interface by the consumer involves using the compatibility policy to characterize a change in the interface. If the change is characterized as a binary incompatible change the system disables use of the interface by the caller. If the change is characterized as a source incompatible change the system disables use of the interface by the implementer.

In some embodiments the binary incompatible change includes a removal of an existing function from the interface and the source incompatible change includes an addition of a new function to the interface.

In some embodiments the change is characterized using a version of the interface and or a reverse dependency constraint associated with the interface.

In some embodiments the role is declared by the consumer or inferred from type declarations in the consumer.

In some embodiments the compatibility policy is applied to the interface a set of interfaces or the software program.

The following description is presented to enable any person skilled in the art to make and use the embodiments and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present disclosure. Thus the present invention is not limited to the embodiments shown but is to be accorded the widest scope consistent with the principles and features disclosed herein.

The data structures and code described in this detailed description are typically stored on a computer readable storage medium which may be any device or medium that can store code and or data for use by a computer system. The computer readable storage medium includes but is not limited to volatile memory non volatile memory magnetic and optical storage devices such as disk drives magnetic tape CDs compact discs DVDs digital versatile discs or digital video discs or other media capable of storing code and or data now known or later developed.

The functions and processes described in the detailed description section can be embodied as code and or data which can be stored in a computer readable storage medium as described above. When a computer system reads and executes the code and or data stored on the computer readable storage medium the computer system performs the functions and processes embodied as data structures and code and stored within the computer readable storage medium.

Furthermore functions and processes described herein can be included in hardware modules or apparatus. These modules or apparatus may include but are not limited to an application specific integrated circuit ASIC chip a field programmable gate array FPGA a dedicated or shared processor that executes a particular software module or a piece of code at a particular time and or other programmable logic devices now known or later developed. When the hardware modules or apparatus are activated they perform the functions and processes included within them.

After testing packaging of the software program may involve creating a software package in an archive format from the software program s executable code. The software package may then undergo deployment and installation on a computer system. For example a web application may be deployed and installed on a server computer while a native application may be deployed and installed on multiple personal computers. Finally execution of the software program allows the software program s intended functionality to be provided to an end user.

Those skilled in the art will appreciate that changes such as patches upgrades maintenance and or new releases may be periodically made to the software program. Moreover such changes may be propagated through some or all of the phases of the life cycle. For example the addition of new features to the software program may require that the software program be recompiled tested packaged deployed installed and executed with the new features.

Those skilled in the art will also appreciate that changes to the software program may increase the complexity of the software program which may eventually interfere with the maintainability usability and or performance of the software program. For example modifications to the software program may be difficult to document and or track across all phases of the software program s life cycle. Over time such modifications may interfere with the continued use and development of the software program by obscuring the design of the software program increasing redundancy and introducing new unknown dependencies among components in the software program.

To mitigate issues associated with increased software complexity a module system may be used to facilitate the development and maintenance of the software program. In one or more embodiments module system uses modular information at all phases of the life cycle to manage dependencies in the software program. Such polyphasic modularization may facilitate the development of the software program by improving transparency cohesion performance scalability and maintainability in the software program. Management of polyphasic modules is discussed in a co pending non provisional application by inventors Mark Reinhold Alexander Buckley Jonathan Gibbons and Karen Kinnear entitled Polyphasic Modules for Software Development having Ser. No. 12 771 121 and filing date 30 Apr. 2010 which is incorporated herein by reference.

As mentioned above module system may use polyphasic modules to facilitate the development of software program . In particular polyphasic modularization of software program may begin with the creation of module declarations for a set of modules to be used in software program .

In one or more embodiments modules correspond to standalone components in software program that may be independently programmed tested and modified. Each module may be defined organized and used through a corresponding module identity and module declaration. In addition an interface to a module may be based on the members of the module. For example the module may be accessed through public functions and or data in the module s members. Logical boundaries between modules may further be enforced by enabling inter module interaction only through the interfaces to the modules thus effectively hiding implementation details of modules from one another.

In other words modules may correspond to encapsulated abstractions of functionality in software program with well defined capabilities and dependencies. Modules may thus provide a large amount of flexibility in organizing the structure of software program . For example Java classes may be grouped into modules based on the functionality and or use of the classes in software program instead of language based constraints such as package membership.

In one or more embodiments module declarations for modules are obtained separately from source code for software program . For example module declarations for modules in a Java program may be stored in module definition files that are separate from source files containing Java classes interfaces enumerations and or annotation types. Such decoupling of module declarations from module implementations may further enable the creation of modules based on factors that facilitate the design and development of software program such as separation of concerns scalability and performance.

The independent creation and procurement of module declarations may additionally allow module system to begin modularizing software program before software program is compiled. For example module system may allow module declarations for modules to be created e.g. using SDK before development of source code for software program is complete. Module system may proceed with using the module declarations to manage dependencies in software program through the compilation testing packaging deployment installation and execution phases of the life cycle of software program .

In one or more embodiments SDK and runtime system provide mechanisms for characterizing the evolution of interfaces for modules and determining the impact that changes to the interfaces may have on consumers of modules . First SDK and runtime system may obtain a role associated with a dependency of a consumer in software program on an interface. The role may identify the consumer as a caller of the interface and or an implementer of the interface. Next SDK and runtime system may obtain a compatibility policy for the interface. The compatibility policy may characterize changes to the interface over time.

SDK and runtime system may then use the role and compatibility policy to assess the compatibility of the interface with the consumer. In particular SDK and runtime system may use the compatibility policy to characterize a change in the interface as binary incompatible and or source incompatible.

The binary incompatible change may correspond to removal of an existing function from the interface while the source incompatible change may correspond to addition of a new function to the interface. As a result use of the interface may be disabled for callers of the interface if the change is binary incompatible. Conversely if the change is source incompatible use of the interface may be disabled for implementers of the interface. SDK and runtime system may thus use the compatibility policy and role to manage use of the interface by the consumer in software program as discussed in further detail below.

Interface may define a set of functions through which components in the software program may interact. For example interface may correspond to an application programming interface API an abstract class or type a module interface and or other entity that provides a point of interaction between software components. Consequently consumer may include a dependency on interface if consumer uses interface to interact with other components in the software program. For example consumer may be a Java compilation unit that declares a dependency on interface through a module declaration package import statement method call and or implementation of interface .

Furthermore the dependency of consumer on interface may be associated with a role . As mentioned above role may identify consumer as a caller and or implementer of interface . In particular role may identify consumer as a caller of interface if consumer calls functions defined in interface or role may identify consumer as an implementer of interface if consumer implements functions defined in interface .

Role may also be obtained in a variety of ways. For example role may be explicitly declared in a module and or package declaration for consumer using an identifier such as calls or implements or role may be inferred from the use of Java keywords such as extends or implements in type declarations .

In one or more embodiments role facilitates use of interface by allowing changes to interface to be characterized in terms of compatibility with consumer . Such characterization may further be enabled by obtaining a compatibility policy that describes the evolution of interface over time as new functions are added to interface and existing functions are modified and or removed. For example compatibility policy may identify the types of changes e.g. additions modifications deletions included in newer versions of interface as well as the functions affected by the changes. As with role compatibility policy may be explicitly stated or inferred. For example compatibility policy may be specified using one or more reverse dependency constraints of interface as discussed below with respect to . Alternatively compatibility policy may be deduced by identifying patterns in changes made across different versions of interface .

More specifically role may be compared with compatibility policy to determine if a given version of interface is compatible with consumer . First changes included in version of interface may be characterized using compatibility policy . In addition each change may be characterized as a binary incompatible change that removes an existing function from interface and or as a source incompatible change that adds a new function to interface . The binary incompatible change may thus produce an error e.g. runtime error if a call to the removed function is attempted while the source incompatible change may produce an error e.g. compilation error if an implementation of interface does not include the added function and is thus incomplete. Conversely the binary incompatible function removal may not interfere with an implementation of interface that still contains the removed function. Along the same lines the source incompatible function addition may not affect calls to existing functions defined by interface .

As a result use of version of interface by consumer may be disabled if role identifies consumer as a caller and version contains a binary incompatible change. Likewise use of version of interface by consumer may be disabled if role identifies consumer as an implementer and version contains a source incompatible change. Incompatibilities between consumer and version may then be resolved by matching consumer with older versions of interface that do not conflict with the method calls and or implementations of consumer .

Those skilled in the art will appreciate that changes to interface may prevent both callers and implementers from using interface unless corresponding changes are made to the method calls to and or implementations of interface . For example a new version of interface may contain both function additions and deletions and or modify existing functions from a previous version of interface . To mitigate changes required of consumers e.g. consumer to maintain compatibility with new versions of interface compatibility policy may specify a set of rules that guide the creation of new versions of interface based on changes to interface .

For example compatibility policy may allow binary incompatible changes to be made to interface when a minor component of version is incremented e.g. y in version x.y.z and source incompatible changes to be made when a major component of version is incremented e.g. x in version x.y.z . As a result a version increase from 1.0 to 1.1 may be used by implementers of version 1.0 but not by callers of version 1.0. However a version increase from 1.0 to 2.0 may contain significant changes that prevent both callers and implementers of version 1. from using version 2.0.

Conversely compatibility policy may allow source incompatible changes when a minor component of version is incremented and binary incompatible changes when a major component of version is incremented. Callers of version 1.0 may thus be able to use any version that is at least 1.0 and less than 2.0 while implementers of version 1.0 may not be able to use even version 1.1.

As another example compatibility policy may allow binary incompatible changes to be included in odd numbered minor versions and source incompatible changes to be included in even numbered minor versions. Consequently a version change from 1.0 to 1.1 may be used by implementers of version 1.0 but not by callers of version 1.0. In turn a version change from 1.1 to 1.2 may be used by callers of version 1.1 but not by implementers of version 1.1.

Furthermore compatibility policy may be applied to interface a set of interfaces containing interface and or the software program. In other words compatibility policy may have a scope that is local to interface specific to a set of interfaces and or global. Local compatibility policies may additionally override global compatibility policies to allow interface providers to select compatibility policies for individual interfaces. For example a compatibility policy for one interface may utilize a three component version e.g. 1.0.0 for the interface to enable finer grained tracking of changes to the interface while another compatibility policy for a different interface may use a two component version e.g. 3.1 to describe changes to the interface.

Those skilled in the art will also appreciate that roles and compatibility policies may be used to manage interaction among software components outside module based environments. In particular consumer roles and compatibility policies may be utilized in any environment that decouples software functionality from implementation and or manages dependencies among software components. For example roles and compatibility policies may mitigate incompatibility and or simplify dependency resolution among components of object oriented software programs distributed objects and or software frameworks.

Moreover the identifiers calls and implements in module declarations for modules may identify module as a caller of O 1.5 and module as an implementer of O 1.1. In other words roles associated with the dependencies of modules on interfaces provided by other modules e.g. modules may be explicitly declared in the module declarations for modules .

Similarly reverse dependency constraints of modules may specify compatibility policies for the interfaces provided by modules . First module includes a reverse dependency constraint of permits caller this 1.0 2.0 . As a result the compatibility policy for module may allow other modules to call functions in module if the other modules express a dependency on a module with the same name as module e.g. O and a version ranging between 1.0 inclusive and 2.0 exclusive. Because module claims a dependency on version 1.5 or higher of module O module is able to use module as a caller.

On the other hand the second reverse dependency constraint of module e.g. permits implementer this 1.6 may prevent module from using module as an implementer because module claims a dependency on a version e.g. 1.1 of module O that is too low to meet the reverse dependency constraint. For example module may not be allowed to implement module because the interface provided by module includes functions that are not in the interface of the O 1.1 module that module claims to implement. Instead module may use the interface of module which has a reverse dependency constraint e.g. permits implementer this 1.0 2.0 that is satisfied by the dependency of module .

First a role associated with a dependency of a consumer in a software program on an interface is obtained operation . The role may identify the consumer e.g. module package class as a caller and or an implementer of the interface. In addition the role may be declared by the consumer or inferred from type declarations in the consumer.

Next a compatibility policy for the interface is obtained operation . As with the role the compatibility policy may be declared by the interface or inferred from changes in the interface over time. Finally the role and the compatibility policy are used to manage use of the interface by the consumer in the software program operation . Role based management of interaction between consumers and interfaces is discussed in further detail below with respect to .

Initially the compatibility policy is used to characterize a change in the interface operation . For example the compatibility policy may specify a set of rules that guide the creation of new versions of the interface based on changes to the interface. The characterized change may be a binary incompatible change operation that removes an existing function from the interface. If the change is characterized as a binary incompatible change use of the interface by a caller is disabled operation to prevent the caller from calling the removed function. If the change is not binary incompatible callers may continue using the interface safely.

On the other hand the characterized change may be a source incompatible change operation that adds a new function to the interface. If the change is characterized as a source incompatible change use of the interface by an implementer is disabled operation to prevent the implementer from attempting to implement the interface without implementing the new function. If the change is neither binary incompatible nor source incompatible both callers and implementers may continue to use the interface.

Computer system may include functionality to execute various components of the present embodiments. In particular computer system may include an operating system not shown that coordinates the use of hardware and software resources on computer system as well as one or more applications that perform specialized tasks for the user. To perform tasks for the user applications may obtain the use of hardware resources on computer system from the operating system as well as interact with the user through a hardware and or software framework provided by the operating system.

In one or more embodiments computer system provides a system for facilitating the development and maintenance of a software program. The system may include an SDK and a runtime system. The SDK and runtime system may obtain a role associated with a dependency of a consumer in the software program on an interface. The SDK and runtime system may also obtain a compatibility policy for the interface. The SDK and runtime system may then use the role and the compatibility policy to manage use of the interface by the consumer in the software program.

In addition one or more components of computer system may be remotely located and connected to the other components over a network. Portions of the present embodiments e.g. SDK runtime system etc. may also be located on different nodes of a distributed system that implements the embodiments. For example the present embodiments may be implemented using a cloud computing system that provides a module system for managing the life cycles of software programs.

The foregoing descriptions of various embodiments have been presented only for purposes of illustration and description. They are not intended to be exhaustive or to limit the present invention to the forms disclosed. Accordingly many modifications and variations will be apparent to practitioners skilled in the art. Additionally the above disclosure is not intended to limit the present invention.

